(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	new _vue2.default({
		el: '#app',
		delimiters: ['${', '}'],
		data: {
			heroCurrentSlide: 1,
			heroTotalSlides: 0,
			heroInterval: null,
			heroSlideDirection: 'slide-up',
			contactName: '',
			contactEmail: '',
			contactSubject: '',
			contactMessage: '',
			contactConfirmation: '',
			contactError: '',
			scrollToTop: false,
			currentSection: 'hero',
			tattooAlbums: [],
			activeTattooAlbum: 0,
			tattooOverlay: false,
			activeTattooPicture: 0,
			staggerTattooAlbums: 0,
			year: 2020
		},
		mounted: function mounted() {
			this.year = new Date().getFullYear();
			this.heroTotalSlides = document.querySelector('.hero').childElementCount - 2;
			this.initHeroSlider();

			var app = this;

			window.addEventListener('scroll', function () {
				app.getCurrentMenuLink();
			});

			// Facebook API

			window.fbAsyncInit = function () {
				FB.init({
					appId: '1700806313540957',
					xfbml: true,
					version: 'v3.2'
				});

				FB.api('/inkdependenttattoos?fields=albums.limit(50){name,count,cover_photo{source}, photos{source}}&access_token=1700806313540957|zFZcPCz9esyC1su57MnuDsLtRwg', function (response) {
					var albums = response.albums.data;
					albums.forEach(function (album) {
						if (album.id === '10161284757175582') {
							// Marcin 2019
							album.name = 'Marcin';
							album.order = 0;
							app.tattooAlbums.push(album);
						}

						if (album.id === '10160033361505582') {
							// Marek 2018
							album.name = 'Marek';
							album.order = 1;
							app.tattooAlbums.push(album);
						}

						if (album.id === '10153556071625582') {
							// Daniel

							album.order = 2;
							app.tattooAlbums.push(album);
						}

						if (album.id === '10156539880325582') {
							// Wojtek

							album.order = 3;
							app.tattooAlbums.push(album);
						}

						if (album.id === '10159146265255582') {
							// Gzy

							album.name = 'Gzy Ex Silesia';
							album.order = 4;
							app.tattooAlbums.push(album);
						}

						if (album.id === '10160843000760582') {
							// Karol

							album.name = 'Karol';
							album.order = 5;
							app.tattooAlbums.push(album);
						}

						if (album.id === '10160543615490582') {
							// Sofia

							album.name = 'Sofia';
							album.order = 6;
							app.tattooAlbums.push(album);
						}

						if (album.id === '10158468256865582') {
							// Ash

							album.name = 'Ash';
							album.order = 7;
							app.tattooAlbums.push(album);
						}
					});

					app.tattooAlbums.sort(function (a, b) {
						return a.order > b.order ? 1 : -1;
					});

					setInterval(function () {
						if (app.staggerTattooAlbums < app.tattooAlbums.length) {
							app.staggerTattooAlbums++;
						}
					}, 500);
				});
			};
		},
		methods: {
			initHeroSlider: function initHeroSlider() {
				var app = this;
				clearInterval(app.heroInterval);
				app.heroInterval = setInterval(function () {
					app.heroSlideDirection = 'slide-right';
					if (app.heroCurrentSlide === app.heroTotalSlides) {
						app.heroCurrentSlide = 1;
					} else {
						app.heroCurrentSlide++;
					}
				}, 8000);
			},
			changeSlide: function changeSlide(slide) {
				if (slide < this.heroCurrentSlide) {
					this.heroSlideDirection = 'slide-left';
				} else {
					this.heroSlideDirection = 'slide-right';
				}

				if (slide > this.heroTotalSlides) {
					slide = 1;
				}

				if (slide === 0) {
					slide = this.heroTotalSlides;
				}

				this.heroCurrentSlide = slide;
				this.initHeroSlider();
			},
			getCurrentMenuLink: function getCurrentMenuLink() {
				if (window.pageYOffset > 0) {
					this.scrollToTop = true;
				} else {
					this.scrollToTop = false;
				}

				var app = this;

				var sections = document.querySelectorAll('section');
				var currentScroll = window.pageYOffset;

				sections.forEach(function (section) {
					var sectionPosition = section.offsetTop;
					if (currentScroll + 100 > sectionPosition) {
						app.currentSection = section.getAttribute('id');
					}
				});
			},
			openTattooAlbum: function openTattooAlbum(album) {
				this.activeTattooAlbum = album;
				this.tattooOverlay = true;
				this.activeTattooPicture = 0;
			},
			closeTattooAlbum: function closeTattooAlbum() {
				this.tattooOverlay = false;
			},
			changeTattooPicture: function changeTattooPicture(picture) {
				this.tattooOverlay = true;
				this.activeTattooPicture = picture;
			},
			sendEmail: function sendEmail(event) {
				event.preventDefault();

				if (this.contactEmail !== '' && this.contactSubject !== '' && this.contactMessage !== '' && this.contactName != '') {
					(0, _smtp.emailSend)({
						Host: 'smtp.elasticemail.com',
						Username: 'kfalencik@gmail.com',
						Password: 'e6b6b50b-415b-4cdf-8dd6-72f774eef952',
						To: 'kfalencik@gmail.com',
						From: 'kfalencik@gmail.com',
						Subject: this.contactSubject,
						Body: 'Message from: ' + this.contactName + ', ' + this.contactEmail + ' - ' + this.contactMessage
					});

					this.contactMessage = '';
					this.contactName = '';
					this.contactEmail = '';
					this.contactSubject = '';

					this.contactError = '';
					this.contactConfirmation = 'Thank you for your message! We will be in touch as soon as possible.';
				} else {
					this.contactError = 'Please fill in all fields and try again.';
					this.contactConfirmation = '';
				}
			}
		}
	});
};

var _vue = require('./vendor/vue');

var _vue2 = _interopRequireDefault(_vue);

var _smtp = require('./vendor/smtp');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./vendor/smtp":6,"./vendor/vue":7}],2:[function(require,module,exports){
/* This is the starting point of the code, everything gets kicked off here */

'use strict';

require('./vendor/polyfills');

var _mainVue = require('./main-vue');

var _mainVue2 = _interopRequireDefault(_mainVue);

var _scrollReveal = require('./scroll-reveal');

var _scrollReveal2 = _interopRequireDefault(_scrollReveal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _mainVue2.default)();
(0, _scrollReveal2.default)();

mapboxgl.accessToken = 'pk.eyJ1Ijoia2ZhbGVuY2lrIiwiYSI6Im5KTlFLZjQifQ._3v1pa90DdSiutiwCiIccg';

var map = new mapboxgl.Map({
	container: 'map',
	style: 'mapbox://styles/kfalencik/cjumgmouk05dg1fmx9xw1c6hp',
	center: [-3.2179, 55.9446],
	zoom: 16.7
});

map.on('load', function () {
	map.loadImage('./images/marker.png', function (error, image) {
		if (error) {
			throw error;
		}

		map.addImage('custom-marker', image);
		map.addLayer({
			id: 'markers',
			type: 'symbol',
			/* Source: A data source specifies the geographic coordinate where the image marker gets placed. */
			source: {
				type: 'geojson',
				data: {
					type: 'FeatureCollection',
					features: [{
						type: 'Feature',
						properties: {},
						geometry: {
							type: 'Point',
							coordinates: [-3.2176257, 55.9446]
						}
					}]
				}
			},
			layout: {
				'icon-image': 'custom-marker'
			}
		});
	});
});

map.scrollZoom.disable();

},{"./main-vue":1,"./scroll-reveal":3,"./vendor/polyfills":4}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function () {
	(0, _scrollreveal2.default)().reveal('.about p', { cleanup: true, delay: 1000, duration: 1000, distance: '250px', origin: 'bottom', interval: 300 });
	(0, _scrollreveal2.default)().reveal('.artists .artists__item:nth-child(2n + 1)', { cleanup: true, delay: 1000, duration: 1000, distance: '50px', origin: 'bottom', interval: 300 });
	(0, _scrollreveal2.default)().reveal('.artists .artists__item:nth-child(2n + 2)', { cleanup: true, delay: 1000, duration: 1000, distance: '50px', origin: 'top', interval: 300 });
	(0, _scrollreveal2.default)().reveal('.contact .h2, .social .h2, .artists .h2, .about .h2', { cleanup: true, delay: 500, duration: 1000, distance: '250px', origin: 'top', interval: 300 });
	(0, _scrollreveal2.default)().reveal('.contact p', { cleanup: true, delay: 500, duration: 1000, distance: '250px', origin: 'left', interval: 300 });
	(0, _scrollreveal2.default)().reveal('.contact input, .contact textarea, .contact button', { cleanup: true, delay: 1000, duration: 1000, distance: '250px', origin: 'top', interval: 300 });
	(0, _scrollreveal2.default)().reveal('.contact p, .social p', { cleanup: true, delay: 500, duration: 1000, distance: '250px', origin: 'left', interval: 300 });
	(0, _scrollreveal2.default)().reveal('.social a', { cleanup: true, delay: 1000, duration: 1000, distance: '250px', origin: 'right', interval: 300 });
	(0, _scrollreveal2.default)().reveal('.tattoo .row', { cleanup: true, delay: 500, duration: 1000, distance: '50px', origin: 'bottom', interval: 300 });
	(0, _scrollreveal2.default)().reveal('.tattoo .tattoo__item:nth-child(2n + 2)', { cleanup: true, delay: 5000, duration: 1000, distance: '50px', origin: 'top', interval: 300 });
};

var _scrollreveal = require('./vendor/scrollreveal');

var _scrollreveal2 = _interopRequireDefault(_scrollreveal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./vendor/scrollreveal":5}],4:[function(require,module,exports){
'use strict';

if (typeof Object.assign !== 'function') {
	// Must be writable: true, enumerable: false, configurable: true
	Object.defineProperty(Object, 'assign', {
		value: function assign(target) {
			// .length of function is 2
			'use strict';

			if (target === null) {
				// TypeError if undefined or null
				throw new TypeError('Cannot convert undefined or null to object');
			}

			var to = Object(target);

			for (var index = 1; index < arguments.length; index++) {
				var nextSource = arguments[index];

				if (nextSource !== null) {
					// Skip over if undefined or null
					for (var nextKey in nextSource) {
						// Avoid bugs when hasOwnProperty is shadowed
						if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
							to[nextKey] = nextSource[nextKey];
						}
					}
				}
			}
			return to;
		},
		writable: true,
		configurable: true
	});
}

if ('NodeList' in window && !NodeList.prototype.forEach) {
	console.info('polyfill for IE11');
	NodeList.prototype.forEach = function (callback, thisArg) {
		thisArg = thisArg || window;
		for (var i = 0; i < this.length; i++) {
			callback.call(thisArg, this[i], i, this);
		}
	};
}

Number.isNaN = Number.isNaN || function (value) {
	return value !== value;
};

if (!String.prototype.startsWith) {
	Object.defineProperty(String.prototype, 'startsWith', {
		value: function value(search, pos) {
			pos = !pos || pos < 0 ? 0 : +pos;
			return this.substring(pos, pos + search.length) === search;
		}
	});
}

if (!Array.prototype.fill) {
	Object.defineProperty(Array.prototype, 'fill', {
		value: function value(_value) {

			// Steps 1-2.
			if (this === null) {
				throw new TypeError('this is null or not defined');
			}

			var O = Object(this);

			// Steps 3-5.
			var len = O.length >>> 0;

			// Steps 6-7.
			var start = arguments[1];
			var relativeStart = start >> 0;

			// Step 8.
			var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);

			// Steps 9-10.
			var end = arguments[2];
			var relativeEnd = end === undefined ? len : end >> 0;

			// Step 11.
			var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);

			// Step 12.
			while (k < final) {
				O[k] = _value;
				k++;
			}

			// Step 13.
			return O;
		}
	});
}

if (!String.prototype.repeat) {
	String.prototype.repeat = function (count) {
		'use strict';

		if (this === null) throw new TypeError('can\'t convert ' + this + ' to object');

		var str = '' + this;
		// To convert string to integer.
		count = +count;
		// Check NaN
		if (count != count) count = 0;

		if (count < 0) throw new RangeError('repeat count must be non-negative');

		if (count === Infinity) throw new RangeError('repeat count must be less than infinity');

		count = Math.floor(count);
		if (str.length === 0 || count === 0) return '';

		// Ensuring count is a 31-bit integer allows us to heavily optimize the
		// main part. But anyway, most current (August 2014) browsers can't handle
		// strings 1 << 28 chars or longer, so:
		if (str.length * count >= 1 << 28) throw new RangeError('repeat count must not overflow maximum string size');

		var maxCount = str.length * count;
		count = Math.floor(Math.log(count) / Math.log(2));
		while (count) {
			str += str;
			count--;
		}
		str += str.substring(0, maxCount - str.length);
		return str;
	};
}

},{}],5:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! @license ScrollReveal v4.0.5

	Copyright 2018 Fisssion LLC.

	Licensed under the GNU General Public License 3.0 for
	compatible open source projects and non-commercial use.

	For commercial sites, themes, projects, and applications,
	keep your source code private/proprietary by purchasing
	a commercial license from https://scrollrevealjs.org/
*/
(function (global, factory) {
	(typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.ScrollReveal = factory();
})(undefined, function () {
	'use strict';

	var defaults = {
		delay: 0,
		distance: '0',
		duration: 600,
		easing: 'cubic-bezier(0.5, 0, 0, 1)',
		interval: 0,
		opacity: 0,
		origin: 'bottom',
		rotate: {
			x: 0,
			y: 0,
			z: 0
		},
		scale: 1,
		cleanup: false,
		container: document.documentElement,
		desktop: true,
		mobile: true,
		reset: false,
		useDelay: 'always',
		viewFactor: 0.0,
		viewOffset: {
			top: 0,
			right: 0,
			bottom: 0,
			left: 0
		},
		afterReset: function afterReset() {},
		afterReveal: function afterReveal() {},
		beforeReset: function beforeReset() {},
		beforeReveal: function beforeReveal() {}
	};

	function failure() {
		document.documentElement.classList.remove('sr');

		return {
			clean: function clean() {},
			destroy: function destroy() {},
			reveal: function reveal() {},
			sync: function sync() {},
			get noop() {
				return true;
			}
		};
	}

	function success() {
		document.documentElement.classList.add('sr');

		if (document.body) {
			document.body.style.height = '100%';
		} else {
			document.addEventListener('DOMContentLoaded', function () {
				document.body.style.height = '100%';
			});
		}
	}

	var mount = { success: success, failure: failure

		/*! @license is-dom-node v1.0.4
  
  	Copyright 2018 Fisssion LLC.
  
  	Permission is hereby granted, free of charge, to any person obtaining a copy
  	of this software and associated documentation files (the "Software"), to deal
  	in the Software without restriction, including without limitation the rights
  	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  	copies of the Software, and to permit persons to whom the Software is
  	furnished to do so, subject to the following conditions:
  
  	The above copyright notice and this permission notice shall be included in all
  	copies or substantial portions of the Software.
  
  	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  	SOFTWARE.
  
  */
	};function isDomNode(x) {
		return _typeof(window.Node) === 'object' ? x instanceof window.Node : x !== null && (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && typeof x.nodeType === 'number' && typeof x.nodeName === 'string';
	}

	/*! @license is-dom-node-list v1.2.1
 
 	Copyright 2018 Fisssion LLC.
 
 	Permission is hereby granted, free of charge, to any person obtaining a copy
 	of this software and associated documentation files (the "Software"), to deal
 	in the Software without restriction, including without limitation the rights
 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 	copies of the Software, and to permit persons to whom the Software is
 	furnished to do so, subject to the following conditions:
 
 	The above copyright notice and this permission notice shall be included in all
 	copies or substantial portions of the Software.
 
 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 	SOFTWARE.
 
 */
	function isDomNodeList(x) {
		var prototypeToString = Object.prototype.toString.call(x);
		var regex = /^\[object (HTMLCollection|NodeList|Object)\]$/;

		return _typeof(window.NodeList) === 'object' ? x instanceof window.NodeList : x !== null && (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && typeof x.length === 'number' && regex.test(prototypeToString) && (x.length === 0 || isDomNode(x[0]));
	}

	/*! @license Tealight v0.3.6
 
 	Copyright 2018 Fisssion LLC.
 
 	Permission is hereby granted, free of charge, to any person obtaining a copy
 	of this software and associated documentation files (the "Software"), to deal
 	in the Software without restriction, including without limitation the rights
 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 	copies of the Software, and to permit persons to whom the Software is
 	furnished to do so, subject to the following conditions:
 
 	The above copyright notice and this permission notice shall be included in all
 	copies or substantial portions of the Software.
 
 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 	SOFTWARE.
 
 */
	function tealight(target, context) {
		if (context === void 0) {
			context = document;
		}

		if (target instanceof Array) {
			return target.filter(isDomNode);
		}
		if (isDomNode(target)) {
			return [target];
		}
		if (isDomNodeList(target)) {
			return Array.prototype.slice.call(target);
		}
		if (typeof target === "string") {
			try {
				var query = context.querySelectorAll(target);
				return Array.prototype.slice.call(query);
			} catch (err) {
				return [];
			}
		}
		return [];
	}

	function isObject(x) {
		return x !== null && x instanceof Object && (x.constructor === Object || Object.prototype.toString.call(x) === '[object Object]');
	}

	function each(collection, callback) {
		if (isObject(collection)) {
			var keys = Object.keys(collection);
			return keys.forEach(function (key) {
				return callback(collection[key], key, collection);
			});
		}
		if (collection instanceof Array) {
			return collection.forEach(function (item, i) {
				return callback(item, i, collection);
			});
		}
		throw new TypeError('Expected either an array or object literal.');
	}

	function logger(message) {
		var details = [],
		    len = arguments.length - 1;
		while (len-- > 0) {
			details[len] = arguments[len + 1];
		}if (this.constructor.debug && console) {
			var report = "%cScrollReveal: " + message;
			details.forEach(function (detail) {
				return report += "\n — " + detail;
			});
			console.log(report, 'color: #ea654b;'); // eslint-disable-line no-console
		}
	}

	function rinse() {
		var this$1 = this;

		var struct = function struct() {
			return {
				active: [],
				stale: []
			};
		};

		var elementIds = struct();
		var sequenceIds = struct();
		var containerIds = struct();

		/**
   * Take stock of active element IDs.
   */
		try {
			each(tealight('[data-sr-id]'), function (node) {
				var id = parseInt(node.getAttribute('data-sr-id'));
				elementIds.active.push(id);
			});
		} catch (e) {
			throw e;
		}
		/**
   * Destroy stale elements.
   */
		each(this.store.elements, function (element) {
			if (elementIds.active.indexOf(element.id) === -1) {
				elementIds.stale.push(element.id);
			}
		});

		each(elementIds.stale, function (staleId) {
			return delete this$1.store.elements[staleId];
		});

		/**
   * Take stock of active container and sequence IDs.
   */
		each(this.store.elements, function (element) {
			if (containerIds.active.indexOf(element.containerId) === -1) {
				containerIds.active.push(element.containerId);
			}
			if (element.hasOwnProperty('sequence')) {
				if (sequenceIds.active.indexOf(element.sequence.id) === -1) {
					sequenceIds.active.push(element.sequence.id);
				}
			}
		});

		/**
   * Destroy stale containers.
   */
		each(this.store.containers, function (container) {
			if (containerIds.active.indexOf(container.id) === -1) {
				containerIds.stale.push(container.id);
			}
		});

		each(containerIds.stale, function (staleId) {
			var stale = this$1.store.containers[staleId].node;
			stale.removeEventListener('scroll', this$1.delegate);
			stale.removeEventListener('resize', this$1.delegate);
			delete this$1.store.containers[staleId];
		});

		/**
   * Destroy stale sequences.
   */
		each(this.store.sequences, function (sequence) {
			if (sequenceIds.active.indexOf(sequence.id) === -1) {
				sequenceIds.stale.push(sequence.id);
			}
		});

		each(sequenceIds.stale, function (staleId) {
			return delete this$1.store.sequences[staleId];
		});
	}

	function clean(target) {
		var this$1 = this;

		var dirty;
		try {
			each(tealight(target), function (node) {
				var id = node.getAttribute('data-sr-id');
				if (id !== null) {
					dirty = true;
					var element = this$1.store.elements[id];
					if (element.callbackTimer) {
						window.clearTimeout(element.callbackTimer.clock);
					}
					node.setAttribute('style', element.styles.inline.generated);
					node.removeAttribute('data-sr-id');
					delete this$1.store.elements[id];
				}
			});
		} catch (e) {
			return logger.call(this, 'Clean failed.', e.message);
		}

		if (dirty) {
			try {
				rinse.call(this);
			} catch (e) {
				return logger.call(this, 'Clean failed.', e.message);
			}
		}
	}

	function destroy() {
		var this$1 = this;

		/**
   * Remove all generated styles and element ids
   */
		each(this.store.elements, function (element) {
			element.node.setAttribute('style', element.styles.inline.generated);
			element.node.removeAttribute('data-sr-id');
		});

		/**
   * Remove all event listeners.
   */
		each(this.store.containers, function (container) {
			var target = container.node === document.documentElement ? window : container.node;
			target.removeEventListener('scroll', this$1.delegate);
			target.removeEventListener('resize', this$1.delegate);
		});

		/**
   * Clear all data from the store
   */
		this.store = {
			containers: {},
			elements: {},
			history: [],
			sequences: {}
		};
	}

	/*! @license Rematrix v0.3.0
 
 	Copyright 2018 Julian Lloyd.
 
 	Permission is hereby granted, free of charge, to any person obtaining a copy
 	of this software and associated documentation files (the "Software"), to deal
 	in the Software without restriction, including without limitation the rights
 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 	copies of the Software, and to permit persons to whom the Software is
 	furnished to do so, subject to the following conditions:
 
 	The above copyright notice and this permission notice shall be included in
 	all copies or substantial portions of the Software.
 
 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 	THE SOFTWARE.
 */
	/**
  * @module Rematrix
  */

	/**
  * Transformation matrices in the browser come in two flavors:
  *
  *  - `matrix` using 6 values (short)
  *  - `matrix3d` using 16 values (long)
  *
  * This utility follows this [conversion guide](https://goo.gl/EJlUQ1)
  * to expand short form matrices to their equivalent long form.
  *
  * @param  {array} source - Accepts both short and long form matrices.
  * @return {array}
  */
	function format(source) {
		if (source.constructor !== Array) {
			throw new TypeError('Expected array.');
		}
		if (source.length === 16) {
			return source;
		}
		if (source.length === 6) {
			var matrix = identity();
			matrix[0] = source[0];
			matrix[1] = source[1];
			matrix[4] = source[2];
			matrix[5] = source[3];
			matrix[12] = source[4];
			matrix[13] = source[5];
			return matrix;
		}
		throw new RangeError('Expected array with either 6 or 16 values.');
	}

	/**
  * Returns a matrix representing no transformation. The product of any matrix
  * multiplied by the identity matrix will be the original matrix.
  *
  * > **Tip:** Similar to how `5 * 1 === 5`, where `1` is the identity.
  *
  * @return {array}
  */
	function identity() {
		var matrix = [];
		for (var i = 0; i < 16; i++) {
			i % 5 == 0 ? matrix.push(1) : matrix.push(0);
		}
		return matrix;
	}

	/**
  * Returns a 4x4 matrix describing the combined transformations
  * of both arguments.
  *
  * > **Note:** Order is very important. For example, rotating 45°
  * along the Z-axis, followed by translating 500 pixels along the
  * Y-axis... is not the same as translating 500 pixels along the
  * Y-axis, followed by rotating 45° along on the Z-axis.
  *
  * @param  {array} m - Accepts both short and long form matrices.
  * @param  {array} x - Accepts both short and long form matrices.
  * @return {array}
  */
	function multiply(m, x) {
		var fm = format(m);
		var fx = format(x);
		var product = [];

		for (var i = 0; i < 4; i++) {
			var row = [fm[i], fm[i + 4], fm[i + 8], fm[i + 12]];
			for (var j = 0; j < 4; j++) {
				var k = j * 4;
				var col = [fx[k], fx[k + 1], fx[k + 2], fx[k + 3]];
				var result = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];

				product[i + k] = result;
			}
		}

		return product;
	}

	/**
  * Attempts to return a 4x4 matrix describing the CSS transform
  * matrix passed in, but will return the identity matrix as a
  * fallback.
  *
  * > **Tip:** This method is used to convert a CSS matrix (retrieved as a
  * `string` from computed styles) to its equivalent array format.
  *
  * @param  {string} source - `matrix` or `matrix3d` CSS Transform value.
  * @return {array}
  */
	function parse(source) {
		if (typeof source === 'string') {
			var match = source.match(/matrix(3d)?\(([^)]+)\)/);
			if (match) {
				var raw = match[2].split(', ').map(parseFloat);
				return format(raw);
			}
		}
		return identity();
	}

	/**
  * Returns a 4x4 matrix describing X-axis rotation.
  *
  * @param  {number} angle - Measured in degrees.
  * @return {array}
  */
	function rotateX(angle) {
		var theta = Math.PI / 180 * angle;
		var matrix = identity();

		matrix[5] = matrix[10] = Math.cos(theta);
		matrix[6] = matrix[9] = Math.sin(theta);
		matrix[9] *= -1;

		return matrix;
	}

	/**
  * Returns a 4x4 matrix describing Y-axis rotation.
  *
  * @param  {number} angle - Measured in degrees.
  * @return {array}
  */
	function rotateY(angle) {
		var theta = Math.PI / 180 * angle;
		var matrix = identity();

		matrix[0] = matrix[10] = Math.cos(theta);
		matrix[2] = matrix[8] = Math.sin(theta);
		matrix[2] *= -1;

		return matrix;
	}

	/**
  * Returns a 4x4 matrix describing Z-axis rotation.
  *
  * @param  {number} angle - Measured in degrees.
  * @return {array}
  */
	function rotateZ(angle) {
		var theta = Math.PI / 180 * angle;
		var matrix = identity();

		matrix[0] = matrix[5] = Math.cos(theta);
		matrix[1] = matrix[4] = Math.sin(theta);
		matrix[4] *= -1;

		return matrix;
	}

	/**
  * Returns a 4x4 matrix describing 2D scaling. The first argument
  * is used for both X and Y-axis scaling, unless an optional
  * second argument is provided to explicitly define Y-axis scaling.
  *
  * @param  {number} scalar    - Decimal multiplier.
  * @param  {number} [scalarY] - Decimal multiplier.
  * @return {array}
  */
	function scale(scalar, scalarY) {
		var matrix = identity();

		matrix[0] = scalar;
		matrix[5] = typeof scalarY === 'number' ? scalarY : scalar;

		return matrix;
	}

	/**
  * Returns a 4x4 matrix describing X-axis translation.
  *
  * @param  {number} distance - Measured in pixels.
  * @return {array}
  */
	function translateX(distance) {
		var matrix = identity();
		matrix[12] = distance;
		return matrix;
	}

	/**
  * Returns a 4x4 matrix describing Y-axis translation.
  *
  * @param  {number} distance - Measured in pixels.
  * @return {array}
  */
	function translateY(distance) {
		var matrix = identity();
		matrix[13] = distance;
		return matrix;
	}

	var getPrefixedCssProp = function () {
		var properties = {};
		var style = document.documentElement.style;

		function getPrefixedCssProperty(name, source) {
			if (source === void 0) source = style;

			if (name && typeof name === 'string') {
				if (properties[name]) {
					return properties[name];
				}
				if (typeof source[name] === 'string') {
					return properties[name] = name;
				}
				if (typeof source["-webkit-" + name] === 'string') {
					return properties[name] = "-webkit-" + name;
				}
				throw new RangeError("Unable to find \"" + name + "\" style property.");
			}
			throw new TypeError('Expected a string.');
		}

		getPrefixedCssProperty.clearCache = function () {
			return properties = {};
		};

		return getPrefixedCssProperty;
	}();

	function style(element) {
		var computed = window.getComputedStyle(element.node);
		var position = computed.position;
		var config = element.config;

		/**
   * Generate inline styles
   */
		var inline = {};
		var inlineStyle = element.node.getAttribute('style') || '';
		var inlineMatch = inlineStyle.match(/[\w-]+\s*:\s*[^;]+\s*/gi) || [];

		inline.computed = inlineMatch ? inlineMatch.map(function (m) {
			return m.trim();
		}).join('; ') + ';' : '';

		inline.generated = inlineMatch.some(function (m) {
			return m.match(/visibility\s?:\s?visible/i);
		}) ? inline.computed : inlineMatch.concat(['visibility: visible']).map(function (m) {
			return m.trim();
		}).join('; ') + ';';

		/**
   * Generate opacity styles
   */
		var computedOpacity = parseFloat(computed.opacity);
		var configOpacity = !isNaN(parseFloat(config.opacity)) ? parseFloat(config.opacity) : parseFloat(computed.opacity);

		var opacity = {
			computed: computedOpacity !== configOpacity ? "opacity: " + computedOpacity + ";" : '',
			generated: computedOpacity !== configOpacity ? "opacity: " + configOpacity + ";" : ''
		};

		/**
   * Generate transformation styles
   */
		var transformations = [];

		if (parseFloat(config.distance)) {
			var axis = config.origin === 'top' || config.origin === 'bottom' ? 'Y' : 'X';

			/**
    * Let’s make sure our our pixel distances are negative for top and left.
    * e.g. { origin: 'top', distance: '25px' } starts at `top: -25px` in CSS.
    */
			var distance = config.distance;
			if (config.origin === 'top' || config.origin === 'left') {
				distance = /^-/.test(distance) ? distance.substr(1) : "-" + distance;
			}

			var ref = distance.match(/(^-?\d+\.?\d?)|(em$|px$|%$)/g);
			var value = ref[0];
			var unit = ref[1];

			switch (unit) {
				case 'em':
					distance = parseInt(computed.fontSize) * value;
					break;
				case 'px':
					distance = value;
					break;
				case '%':
					/**
      * Here we use `getBoundingClientRect` instead of
      * the existing data attached to `element.geometry`
      * because only the former includes any transformations
      * current applied to the element.
      *
      * If that behavior ends up being unintuitive, this
      * logic could instead utilize `element.geometry.height`
      * and `element.geoemetry.width` for the distaince calculation
      */
					distance = axis === 'Y' ? element.node.getBoundingClientRect().height * value / 100 : element.node.getBoundingClientRect().width * value / 100;
					break;
				default:
					throw new RangeError('Unrecognized or missing distance unit.');
			}

			if (axis === 'Y') {
				transformations.push(translateY(distance));
			} else {
				transformations.push(translateX(distance));
			}
		}

		if (config.rotate.x) {
			transformations.push(rotateX(config.rotate.x));
		}
		if (config.rotate.y) {
			transformations.push(rotateY(config.rotate.y));
		}
		if (config.rotate.z) {
			transformations.push(rotateZ(config.rotate.z));
		}
		if (config.scale !== 1) {
			if (config.scale === 0) {
				/**
     * The CSS Transforms matrix interpolation specification
     * basically disallows transitions of non-invertible
     * matrixes, which means browsers won't transition
     * elements with zero scale.
     *
     * That’s inconvenient for the API and developer
     * experience, so we simply nudge their value
     * slightly above zero; this allows browsers
     * to transition our element as expected.
     *
     * `0.0002` was the smallest number
     * that performed across browsers.
     */
				transformations.push(scale(0.0002));
			} else {
				transformations.push(scale(config.scale));
			}
		}

		var transform = {};
		if (transformations.length) {
			transform.property = getPrefixedCssProp('transform');
			/**
    * The default computed transform value should be one of:
    * undefined || 'none' || 'matrix()' || 'matrix3d()'
    */
			transform.computed = {
				raw: computed[transform.property],
				matrix: parse(computed[transform.property])
			};

			transformations.unshift(transform.computed.matrix);
			var product = transformations.reduce(multiply);

			transform.generated = {
				initial: transform.property + ": matrix3d(" + product.join(', ') + ");",
				final: transform.property + ": matrix3d(" + transform.computed.matrix.join(', ') + ");"
			};
		} else {
			transform.generated = {
				initial: '',
				final: ''
			};
		}

		/**
   * Generate transition styles
   */
		var transition = {};
		if (opacity.generated || transform.generated.initial) {
			transition.property = getPrefixedCssProp('transition');
			transition.computed = computed[transition.property];
			transition.fragments = [];

			var delay = config.delay;
			var duration = config.duration;
			var easing = config.easing;

			if (opacity.generated) {
				transition.fragments.push({
					delayed: "opacity " + duration / 1000 + "s " + easing + " " + delay / 1000 + "s",
					instant: "opacity " + duration / 1000 + "s " + easing + " 0s"
				});
			}

			if (transform.generated.initial) {
				transition.fragments.push({
					delayed: transform.property + " " + duration / 1000 + "s " + easing + " " + delay / 1000 + "s",
					instant: transform.property + " " + duration / 1000 + "s " + easing + " 0s"
				});
			}

			/**
    * The default computed transition property should be one of:
    * undefined || '' || 'all 0s ease 0s' || 'all 0s 0s cubic-bezier()'
    */
			if (transition.computed && !transition.computed.match(/all 0s/)) {
				transition.fragments.unshift({
					delayed: transition.computed,
					instant: transition.computed
				});
			}

			var composed = transition.fragments.reduce(function (composition, fragment, i) {
				composition.delayed += i === 0 ? fragment.delayed : ", " + fragment.delayed;
				composition.instant += i === 0 ? fragment.instant : ", " + fragment.instant;
				return composition;
			}, {
				delayed: '',
				instant: ''
			});

			transition.generated = {
				delayed: transition.property + ": " + composed.delayed + ";",
				instant: transition.property + ": " + composed.instant + ";"
			};
		} else {
			transition.generated = {
				delayed: '',
				instant: ''
			};
		}

		return {
			inline: inline,
			opacity: opacity,
			position: position,
			transform: transform,
			transition: transition
		};
	}

	function animate(element, force) {
		if (force === void 0) force = {};

		var pristine = force.pristine || this.pristine;
		var delayed = element.config.useDelay === 'always' || element.config.useDelay === 'onload' && pristine || element.config.useDelay === 'once' && !element.seen;

		var shouldReveal = element.visible && !element.revealed;
		var shouldReset = !element.visible && element.revealed && element.config.reset;

		if (force.reveal || shouldReveal) {
			return triggerReveal.call(this, element, delayed);
		}

		if (force.reset || shouldReset) {
			return triggerReset.call(this, element);
		}
	}

	function triggerReveal(element, delayed) {
		var styles = [element.styles.inline.generated, element.styles.opacity.computed, element.styles.transform.generated.final];
		if (delayed) {
			styles.push(element.styles.transition.generated.delayed);
		} else {
			styles.push(element.styles.transition.generated.instant);
		}
		element.revealed = element.seen = true;
		element.node.setAttribute('style', styles.filter(function (s) {
			return s !== '';
		}).join(' '));
		registerCallbacks.call(this, element, delayed);
	}

	function triggerReset(element) {
		var styles = [element.styles.inline.generated, element.styles.opacity.generated, element.styles.transform.generated.initial, element.styles.transition.generated.instant];
		element.revealed = false;
		element.node.setAttribute('style', styles.filter(function (s) {
			return s !== '';
		}).join(' '));
		registerCallbacks.call(this, element);
	}

	function registerCallbacks(element, isDelayed) {
		var this$1 = this;

		var duration = isDelayed ? element.config.duration + element.config.delay : element.config.duration;

		var beforeCallback = element.revealed ? element.config.beforeReveal : element.config.beforeReset;

		var afterCallback = element.revealed ? element.config.afterReveal : element.config.afterReset;

		var elapsed = 0;
		if (element.callbackTimer) {
			elapsed = Date.now() - element.callbackTimer.start;
			window.clearTimeout(element.callbackTimer.clock);
		}

		beforeCallback(element.node);

		element.callbackTimer = {
			start: Date.now(),
			clock: window.setTimeout(function () {
				afterCallback(element.node);
				element.callbackTimer = null;
				if (element.revealed && !element.config.reset && element.config.cleanup) {
					clean.call(this$1, element.node);
				}
			}, duration - elapsed)
		};
	}

	var nextUniqueId = function () {
		var uid = 0;
		return function () {
			return uid++;
		};
	}();

	function sequence(element, pristine) {
		if (pristine === void 0) pristine = this.pristine;

		/**
   * We first check if the element should reset.
   */
		if (!element.visible && element.revealed && element.config.reset) {
			return animate.call(this, element, { reset: true });
		}

		var seq = this.store.sequences[element.sequence.id];
		var i = element.sequence.index;

		if (seq) {
			var visible = new SequenceModel(seq, 'visible', this.store);
			var revealed = new SequenceModel(seq, 'revealed', this.store);

			seq.models = { visible: visible, revealed: revealed };

			/**
    * If the sequence has no revealed members,
    * then we reveal the first visible element
    * within that sequence.
    *
    * The sequence then cues a recursive call
    * in both directions.
    */
			if (!revealed.body.length) {
				var nextId = seq.members[visible.body[0]];
				var nextElement = this.store.elements[nextId];

				if (nextElement) {
					cue.call(this, seq, visible.body[0], -1, pristine);
					cue.call(this, seq, visible.body[0], +1, pristine);
					return animate.call(this, nextElement, { reveal: true, pristine: pristine });
				}
			}

			/**
    * If our element isn’t resetting, we check the
    * element sequence index against the head, and
    * then the foot of the sequence.
    */
			if (!seq.blocked.head && i === [].concat(revealed.head).pop() && i >= [].concat(visible.body).shift()) {
				cue.call(this, seq, i, -1, pristine);
				return animate.call(this, element, { reveal: true, pristine: pristine });
			}

			if (!seq.blocked.foot && i === [].concat(revealed.foot).shift() && i <= [].concat(visible.body).pop()) {
				cue.call(this, seq, i, +1, pristine);
				return animate.call(this, element, { reveal: true, pristine: pristine });
			}
		}
	}

	function Sequence(interval) {
		var i = Math.abs(interval);
		if (!isNaN(i)) {
			this.id = nextUniqueId();
			this.interval = Math.max(i, 16);
			this.members = [];
			this.models = {};
			this.blocked = {
				head: false,
				foot: false
			};
		} else {
			throw new RangeError('Invalid sequence interval.');
		}
	}

	function SequenceModel(seq, prop, store) {
		var this$1 = this;

		this.head = [];
		this.body = [];
		this.foot = [];

		each(seq.members, function (id, index) {
			var element = store.elements[id];
			if (element && element[prop]) {
				this$1.body.push(index);
			}
		});

		if (this.body.length) {
			each(seq.members, function (id, index) {
				var element = store.elements[id];
				if (element && !element[prop]) {
					if (index < this$1.body[0]) {
						this$1.head.push(index);
					} else {
						this$1.foot.push(index);
					}
				}
			});
		}
	}

	function cue(seq, i, direction, pristine) {
		var this$1 = this;

		var blocked = ['head', null, 'foot'][1 + direction];
		var nextId = seq.members[i + direction];
		var nextElement = this.store.elements[nextId];

		seq.blocked[blocked] = true;

		setTimeout(function () {
			seq.blocked[blocked] = false;
			if (nextElement) {
				sequence.call(this$1, nextElement, pristine);
			}
		}, seq.interval);
	}

	function initialize() {
		var this$1 = this;

		rinse.call(this);

		each(this.store.elements, function (element) {
			var styles = [element.styles.inline.generated];

			if (element.visible) {
				styles.push(element.styles.opacity.computed);
				styles.push(element.styles.transform.generated.final);
				element.revealed = true;
			} else {
				styles.push(element.styles.opacity.generated);
				styles.push(element.styles.transform.generated.initial);
				element.revealed = false;
			}

			element.node.setAttribute('style', styles.filter(function (s) {
				return s !== '';
			}).join(' '));
		});

		each(this.store.containers, function (container) {
			var target = container.node === document.documentElement ? window : container.node;
			target.addEventListener('scroll', this$1.delegate);
			target.addEventListener('resize', this$1.delegate);
		});

		/**
   * Manually invoke delegate once to capture
   * element and container dimensions, container
   * scroll position, and trigger any valid reveals
   */
		this.delegate();

		/**
   * Wipe any existing `setTimeout` now
   * that initialization has completed.
   */
		this.initTimeout = null;
	}

	function isMobile(agent) {
		if (agent === void 0) agent = navigator.userAgent;

		return (/Android|iPhone|iPad|iPod/i.test(agent)
		);
	}

	function deepAssign(target) {
		var sources = [],
		    len = arguments.length - 1;
		while (len-- > 0) {
			sources[len] = arguments[len + 1];
		}if (isObject(target)) {
			each(sources, function (source) {
				each(source, function (data, key) {
					if (isObject(data)) {
						if (!target[key] || !isObject(target[key])) {
							target[key] = {};
						}
						deepAssign(target[key], data);
					} else {
						target[key] = data;
					}
				});
			});
			return target;
		} else {
			throw new TypeError('Target must be an object literal.');
		}
	}

	function reveal(target, options, syncing) {
		var this$1 = this;
		if (options === void 0) options = {};
		if (syncing === void 0) syncing = false;

		var containerBuffer = [];
		var sequence$$1;
		var interval = options.interval || defaults.interval;

		try {
			if (interval) {
				sequence$$1 = new Sequence(interval);
			}

			var nodes = tealight(target);
			if (!nodes.length) {
				throw new Error('Invalid reveal target.');
			}

			var elements = nodes.reduce(function (elementBuffer, elementNode) {
				var element = {};
				var existingId = elementNode.getAttribute('data-sr-id');

				if (existingId) {
					deepAssign(element, this$1.store.elements[existingId]);

					/**
      * In order to prevent previously generated styles
      * from throwing off the new styles, the style tag
      * has to be reverted to its pre-reveal state.
      */
					element.node.setAttribute('style', element.styles.inline.computed);
				} else {
					element.id = nextUniqueId();
					element.node = elementNode;
					element.seen = false;
					element.revealed = false;
					element.visible = false;
				}

				var config = deepAssign({}, element.config || this$1.defaults, options);

				if (!config.mobile && isMobile() || !config.desktop && !isMobile()) {
					if (existingId) {
						clean.call(this$1, element);
					}
					return elementBuffer; // skip elements that are disabled
				}

				var containerNode = tealight(config.container)[0];
				if (!containerNode) {
					throw new Error('Invalid container.');
				}
				if (!containerNode.contains(elementNode)) {
					return elementBuffer; // skip elements found outside the container
				}

				var containerId;
				{
					containerId = getContainerId(containerNode, containerBuffer, this$1.store.containers);
					if (containerId === null) {
						containerId = nextUniqueId();
						containerBuffer.push({ id: containerId, node: containerNode });
					}
				}

				element.config = config;
				element.containerId = containerId;
				element.styles = style(element);

				if (sequence$$1) {
					element.sequence = {
						id: sequence$$1.id,
						index: sequence$$1.members.length
					};
					sequence$$1.members.push(element.id);
				}

				elementBuffer.push(element);
				return elementBuffer;
			}, []);

			/**
    * Modifying the DOM via setAttribute needs to be handled
    * separately from reading computed styles in the map above
    * for the browser to batch DOM changes (limiting reflows)
    */
			each(elements, function (element) {
				this$1.store.elements[element.id] = element;
				element.node.setAttribute('data-sr-id', element.id);
			});
		} catch (e) {
			return logger.call(this, 'Reveal failed.', e.message);
		}

		/**
   * Now that element set-up is complete...
   * Let’s commit any container and sequence data we have to the store.
   */
		each(containerBuffer, function (container) {
			this$1.store.containers[container.id] = {
				id: container.id,
				node: container.node
			};
		});
		if (sequence$$1) {
			this.store.sequences[sequence$$1.id] = sequence$$1;
		}

		/**
   * If reveal wasn't invoked by sync, we want to
   * make sure to add this call to the history.
   */
		if (syncing !== true) {
			this.store.history.push({ target: target, options: options });

			/**
    * Push initialization to the event queue, giving
    * multiple reveal calls time to be interpreted.
    */
			if (this.initTimeout) {
				window.clearTimeout(this.initTimeout);
			}
			this.initTimeout = window.setTimeout(initialize.bind(this), 0);
		}
	}

	function getContainerId(node) {
		var collections = [],
		    len = arguments.length - 1;
		while (len-- > 0) {
			collections[len] = arguments[len + 1];
		}var id = null;
		each(collections, function (collection) {
			each(collection, function (container) {
				if (id === null && container.node === node) {
					id = container.id;
				}
			});
		});
		return id;
	}

	/**
  * Re-runs the reveal method for each record stored in history,
  * for capturing new content asynchronously loaded into the DOM.
  */
	function sync() {
		var this$1 = this;

		each(this.store.history, function (record) {
			reveal.call(this$1, record.target, record.options, true);
		});

		initialize.call(this);
	}

	var polyfill = function polyfill(x) {
		return (x > 0) - (x < 0) || +x;
	};
	var mathSign = Math.sign || polyfill;

	/*! @license miniraf v1.0.0
 
 	Copyright 2018 Fisssion LLC.
 
 	Permission is hereby granted, free of charge, to any person obtaining a copy
 	of this software and associated documentation files (the "Software"), to deal
 	in the Software without restriction, including without limitation the rights
 	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 	copies of the Software, and to permit persons to whom the Software is
 	furnished to do so, subject to the following conditions:
 
 	The above copyright notice and this permission notice shall be included in all
 	copies or substantial portions of the Software.
 
 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 	SOFTWARE.
 
 */
	var polyfill$1 = function () {
		var clock = Date.now();

		return function (callback) {
			var currentTime = Date.now();
			if (currentTime - clock > 16) {
				clock = currentTime;
				callback(currentTime);
			} else {
				setTimeout(function () {
					return polyfill$1(callback);
				}, 0);
			}
		};
	}();

	var index = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || polyfill$1;

	function getGeometry(target, isContainer) {
		/**
   * We want to ignore padding and scrollbars for container elements.
   * More information here: https://goo.gl/vOZpbz
   */
		var height = isContainer ? target.node.clientHeight : target.node.offsetHeight;
		var width = isContainer ? target.node.clientWidth : target.node.offsetWidth;

		var offsetTop = 0;
		var offsetLeft = 0;
		var node = target.node;

		do {
			if (!isNaN(node.offsetTop)) {
				offsetTop += node.offsetTop;
			}
			if (!isNaN(node.offsetLeft)) {
				offsetLeft += node.offsetLeft;
			}
			node = node.offsetParent;
		} while (node);

		return {
			bounds: {
				top: offsetTop,
				right: offsetLeft + width,
				bottom: offsetTop + height,
				left: offsetLeft
			},
			height: height,
			width: width
		};
	}

	function getScrolled(container) {
		var top, left;
		if (container.node === document.documentElement) {
			top = window.pageYOffset;
			left = window.pageXOffset;
		} else {
			top = container.node.scrollTop;
			left = container.node.scrollLeft;
		}
		return { top: top, left: left };
	}

	function isElementVisible(element) {
		if (element === void 0) element = {};

		var container = this.store.containers[element.containerId];
		if (!container) {
			return;
		}

		var viewFactor = Math.max(0, Math.min(1, element.config.viewFactor));
		var viewOffset = element.config.viewOffset;

		var elementBounds = {
			top: element.geometry.bounds.top + element.geometry.height * viewFactor,
			right: element.geometry.bounds.right - element.geometry.width * viewFactor,
			bottom: element.geometry.bounds.bottom - element.geometry.height * viewFactor,
			left: element.geometry.bounds.left + element.geometry.width * viewFactor
		};

		var containerBounds = {
			top: container.geometry.bounds.top + container.scroll.top + viewOffset.top,
			right: container.geometry.bounds.right + container.scroll.left - viewOffset.right,
			bottom: container.geometry.bounds.bottom + container.scroll.top - viewOffset.bottom,
			left: container.geometry.bounds.left + container.scroll.left + viewOffset.left
		};

		return elementBounds.top < containerBounds.bottom && elementBounds.right > containerBounds.left && elementBounds.bottom > containerBounds.top && elementBounds.left < containerBounds.right || element.styles.position === 'fixed';
	}

	function delegate(event, elements) {
		var this$1 = this;
		if (event === void 0) event = { type: 'init' };
		if (elements === void 0) elements = this.store.elements;

		index(function () {
			var stale = event.type === 'init' || event.type === 'resize';

			each(this$1.store.containers, function (container) {
				if (stale) {
					container.geometry = getGeometry.call(this$1, container, true);
				}
				var scroll = getScrolled.call(this$1, container);
				if (container.scroll) {
					container.direction = {
						x: mathSign(scroll.left - container.scroll.left),
						y: mathSign(scroll.top - container.scroll.top)
					};
				}
				container.scroll = scroll;
			});

			/**
    * Due to how the sequencer is implemented, it’s
    * important that we update the state of all
    * elements, before any animation logic is
    * evaluated (in the second loop below).
    */
			each(elements, function (element) {
				if (stale) {
					element.geometry = getGeometry.call(this$1, element);
				}
				element.visible = isElementVisible.call(this$1, element);
			});

			each(elements, function (element) {
				if (element.sequence) {
					sequence.call(this$1, element);
				} else {
					animate.call(this$1, element);
				}
			});

			this$1.pristine = false;
		});
	}

	function transformSupported() {
		var style = document.documentElement.style;
		return 'transform' in style || 'WebkitTransform' in style;
	}

	function transitionSupported() {
		var style = document.documentElement.style;
		return 'transition' in style || 'WebkitTransition' in style;
	}

	var version = "4.0.5";

	var boundDelegate;
	var boundDestroy;
	var boundReveal;
	var boundClean;
	var boundSync;
	var config;
	var debug;
	var instance;

	function ScrollReveal(options) {
		if (options === void 0) options = {};

		var invokedWithoutNew = typeof this === 'undefined' || Object.getPrototypeOf(this) !== ScrollReveal.prototype;

		if (invokedWithoutNew) {
			return new ScrollReveal(options);
		}

		if (!ScrollReveal.isSupported()) {
			logger.call(this, 'Instantiation failed.', 'This browser is not supported.');
			return mount.failure();
		}

		var buffer;
		try {
			buffer = config ? deepAssign({}, config, options) : deepAssign({}, defaults, options);
		} catch (e) {
			logger.call(this, 'Invalid configuration.', e.message);
			return mount.failure();
		}

		try {
			var container = tealight(buffer.container)[0];
			if (!container) {
				throw new Error('Invalid container.');
			}
		} catch (e) {
			logger.call(this, e.message);
			return mount.failure();
		}

		config = buffer;

		if (!config.mobile && isMobile() || !config.desktop && !isMobile()) {
			logger.call(this, 'This device is disabled.', "desktop: " + config.desktop, "mobile: " + config.mobile);
			return mount.failure();
		}

		mount.success();

		this.store = {
			containers: {},
			elements: {},
			history: [],
			sequences: {}
		};

		this.pristine = true;

		boundDelegate = boundDelegate || delegate.bind(this);
		boundDestroy = boundDestroy || destroy.bind(this);
		boundReveal = boundReveal || reveal.bind(this);
		boundClean = boundClean || clean.bind(this);
		boundSync = boundSync || sync.bind(this);

		Object.defineProperty(this, 'delegate', { get: function get() {
				return boundDelegate;
			} });
		Object.defineProperty(this, 'destroy', { get: function get() {
				return boundDestroy;
			} });
		Object.defineProperty(this, 'reveal', { get: function get() {
				return boundReveal;
			} });
		Object.defineProperty(this, 'clean', { get: function get() {
				return boundClean;
			} });
		Object.defineProperty(this, 'sync', { get: function get() {
				return boundSync;
			} });

		Object.defineProperty(this, 'defaults', { get: function get() {
				return config;
			} });
		Object.defineProperty(this, 'version', { get: function get() {
				return version;
			} });
		Object.defineProperty(this, 'noop', { get: function get() {
				return false;
			} });

		return instance ? instance : instance = this;
	}

	ScrollReveal.isSupported = function () {
		return transformSupported() && transitionSupported();
	};

	Object.defineProperty(ScrollReveal, 'debug', {
		get: function get() {
			return debug || false;
		},
		set: function set(value) {
			return debug = typeof value === 'boolean' ? value : debug;
		}
	});

	ScrollReveal();

	return ScrollReveal;
});

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
/* SmtpJS.com - v3.0.0 */

function emailSend(a) {
	return new Promise(function (n, e) {
		a.nocache = Math.floor(1e6 * Math.random() + 1), a.Action = "Send";var t = JSON.stringify(a);

		emailAjaxPost("https://smtpjs.com/v3/smtpjs.aspx?", t, function (e) {
			n(e);
		});
	});
}

function emailAjaxPost(e, n, t) {
	var a = emailCreateCORSRequest("POST", e);
	a.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), a.onload = function () {
		var e = a.responseText;console.log(e);null != t && t(e);
	}, a.send(n);
}

function emailAjax(e, n) {
	var t = emailCreateCORSRequest("GET", e);
	t.onload = function () {
		var e = t.responseText;
		null != n && n(e);
	}, t.send();
}

function emailCreateCORSRequest(e, n) {
	var t = new XMLHttpRequest();
	return "withCredentials" in t ? t.open(e, n, !0) : "undefined" != typeof XDomainRequest ? (t = new XDomainRequest()).open(e, n) : t = null, t;
}

exports.emailSend = emailSend;
exports.emailAjaxPost = emailAjaxPost;
exports.emailAjax = emailAjax;
exports.emailCreateCORSRequest = emailCreateCORSRequest;

},{}],7:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.6.9
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

(function (global, factory) {
  (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.Vue = factory());
})(undefined, function () {
  'use strict';

  /*  */

  var emptyObject = Object.freeze({});

  // These helpers produce better VM code in JS engines due to their
  // explicitness and function inlining.
  function isUndef(v) {
    return v === undefined || v === null;
  }

  function isDef(v) {
    return v !== undefined && v !== null;
  }

  function isTrue(v) {
    return v === true;
  }

  function isFalse(v) {
    return v === false;
  }

  /**
   * Check if value is primitive.
   */
  function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' ||
    // $flow-disable-line
    (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';
  }

  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */
  function isObject(obj) {
    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
  }

  /**
   * Get the raw type string of a value, e.g., [object Object].
   */
  var _toString = Object.prototype.toString;

  function toRawType(value) {
    return _toString.call(value).slice(8, -1);
  }

  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */
  function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
  }

  function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
  }

  /**
   * Check if val is a valid array index.
   */
  function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
  }

  function isPromise(val) {
    return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
  }

  /**
   * Convert a value to a string that is actually rendered.
   */
  function toString(val) {
    return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
  }

  /**
   * Convert an input value to a number for persistence.
   * If the conversion fails, return original string.
   */
  function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  }

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */
  function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? function (val) {
      return map[val.toLowerCase()];
    } : function (val) {
      return map[val];
    };
  }

  /**
   * Check if a tag is a built-in tag.
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * Check if an attribute is a reserved attribute.
   */
  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

  /**
   * Remove an item from an array.
   */
  function remove(arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1);
      }
    }
  }

  /**
   * Check whether an object has the property.
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }

  /**
   * Create a cached version of a pure function.
   */
  function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  }

  /**
   * Camelize a hyphen-delimited string.
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) {
      return c ? c.toUpperCase() : '';
    });
  });

  /**
   * Capitalize a string.
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });

  /**
   * Hyphenate a camelCase string.
   */
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
  });

  /**
   * Simple bind polyfill for environments that do not support it,
   * e.g., PhantomJS 1.x. Technically, we don't need this anymore
   * since native bind is now performant enough in most browsers.
   * But removing it would mean breaking code that was able to run in
   * PhantomJS 1.x, so this must be kept for backward compatibility.
   */

  /* istanbul ignore next */
  function polyfillBind(fn, ctx) {
    function boundFn(a) {
      var l = arguments.length;
      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
    }

    boundFn._length = fn.length;
    return boundFn;
  }

  function nativeBind(fn, ctx) {
    return fn.bind(ctx);
  }

  var bind = Function.prototype.bind ? nativeBind : polyfillBind;

  /**
   * Convert an Array-like object to a real Array.
   */
  function toArray(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret;
  }

  /**
   * Mix properties into target object.
   */
  function extend(to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to;
  }

  /**
   * Merge an Array of Objects into a single Object.
   */
  function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res;
  }

  /* eslint-disable no-unused-vars */

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
   */
  function noop(a, b, c) {}

  /**
   * Always return false.
   */
  var no = function no(a, b, c) {
    return false;
  };

  /* eslint-enable no-unused-vars */

  /**
   * Return the same value.
   */
  var identity = function identity(_) {
    return _;
  };

  /**
   * Generate a string containing static keys from compiler modules.
   */
  function genStaticKeys(modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || []);
    }, []).join(',');
  }

  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */
  function looseEqual(a, b) {
    if (a === b) {
      return true;
    }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i]);
          });
        } else if (a instanceof Date && b instanceof Date) {
          return a.getTime() === b.getTime();
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key]);
          });
        } else {
          /* istanbul ignore next */
          return false;
        }
      } catch (e) {
        /* istanbul ignore next */
        return false;
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b);
    } else {
      return false;
    }
  }

  /**
   * Return the first index at which a loosely equal value can be
   * found in the array (if value is a plain object, the array must
   * contain an object of the same shape), or -1 if it is not present.
   */
  function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Ensure a function is called only once.
   */
  function once(fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    };
  }

  var SSR_ATTR = 'data-server-rendered';

  var ASSET_TYPES = ['component', 'directive', 'filter'];

  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];

  /*  */

  var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  };

  /*  */

  /**
   * unicode letters used for parsing html tags, component names and property paths.
   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
   * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
   */
  var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

  /**
   * Check if a string starts with $ or _
   */
  function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F;
  }

  /**
   * Define a property.
   */
  function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * Parse simple path.
   */
  var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");
  function parsePath(path) {
    if (bailRE.test(path)) {
      return;
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) {
          return;
        }
        obj = obj[segments[i]];
      }
      return obj;
    };
  }

  /*  */

  // can we use __proto__?
  var hasProto = '__proto__' in {};

  // Browser environment sniffing
  var inBrowser = typeof window !== 'undefined';
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
  var isPhantomJS = UA && /phantomjs/.test(UA);
  var isFF = UA && UA.match(/firefox\/(\d+)/);

  // Firefox has a "watch" function on Object.prototype...
  var nativeWatch = {}.watch;

  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', {
        get: function get() {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      }); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV
  var _isServer;
  var isServerRendering = function isServerRendering() {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && !inWeex && typeof global !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer;
  };

  // detect devtools
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  /* istanbul ignore next */
  function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
  }

  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  /* istanbul ignore if */ // $flow-disable-line
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = /*@__PURE__*/function () {
      function Set() {
        this.set = Object.create(null);
      }
      Set.prototype.has = function has(key) {
        return this.set[key] === true;
      };
      Set.prototype.add = function add(key) {
        this.set[key] = true;
      };
      Set.prototype.clear = function clear() {
        this.set = Object.create(null);
      };

      return Set;
    }();
  }

  /*  */

  var warn = noop;
  var tip = noop;
  var generateComponentTrace = noop; // work around flow check
  var formatComponentName = noop;

  {
    var hasConsole = typeof console !== 'undefined';
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = function classify(str) {
      return str.replace(classifyRE, function (c) {
        return c.toUpperCase();
      }).replace(/[-_]/g, '');
    };

    warn = function warn(msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : '';

      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && !config.silent) {
        console.error("[Vue warn]: " + msg + trace);
      }
    };

    tip = function tip(msg, vm) {
      if (hasConsole && !config.silent) {
        console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
      }
    };

    formatComponentName = function formatComponentName(vm, includeFile) {
      if (vm.$root === vm) {
        return '<Root>';
      }
      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
      var name = options.name || options._componentTag;
      var file = options.__file;
      if (!name && file) {
        var match = file.match(/([^/\\]+)\.vue$/);
        name = match && match[1];
      }

      return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
    };

    var repeat = function repeat(str, n) {
      var res = '';
      while (n) {
        if (n % 2 === 1) {
          res += str;
        }
        if (n > 1) {
          str += str;
        }
        n >>= 1;
      }
      return res;
    };

    generateComponentTrace = function generateComponentTrace(vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;
        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];
            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue;
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }
          tree.push(vm);
          vm = vm.$parent;
        }
        return '\n\nfound in\n\n' + tree.map(function (vm, i) {
          return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
        }).join('\n');
      } else {
        return "\n\n(found in " + formatComponentName(vm) + ")";
      }
    };
  }

  /*  */

  var uid = 0;

  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */
  var Dep = function Dep() {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub(sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub(sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify() {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    if (!config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort(function (a, b) {
        return a.id - b.id;
      });
    }
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // The current target watcher being evaluated.
  // This is globally unique because only one watcher
  // can be evaluated at a time.
  Dep.target = null;
  var targetStack = [];

  function pushTarget(target) {
    targetStack.push(target);
    Dep.target = target;
  }

  function popTarget() {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
  }

  /*  */

  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = { child: { configurable: true } };

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  prototypeAccessors.child.get = function () {
    return this.componentInstance;
  };

  Object.defineProperties(VNode.prototype, prototypeAccessors);

  var createEmptyVNode = function createEmptyVNode(text) {
    if (text === void 0) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
  };

  function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
  }

  // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.
  function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned;
  }

  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */

  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);

  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

  /**
   * Intercept mutating methods and emit events
   */
  methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break;
        case 'splice':
          inserted = args.slice(2);
          break;
      }
      if (inserted) {
        ob.observeArray(inserted);
      }
      // notify change
      ob.dep.notify();
      return result;
    });
  });

  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * In some cases we may want to disable observation inside a component's
   * update computation.
   */
  var shouldObserve = true;

  function toggleObserving(value) {
    shouldObserve = value;
  }

  /**
   * Observer class that is attached to each observed
   * object. Once attached, the observer converts the target
   * object's property keys into getter/setters that
   * collect dependencies and dispatch updates.
   */
  var Observer = function Observer(value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods);
      } else {
        copyAugment(value, arrayMethods, arrayKeys);
      }
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  Observer.prototype.walk = function walk(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive$$1(obj, keys[i]);
    }
  };

  /**
   * Observe a list of Array items.
   */
  Observer.prototype.observeArray = function observeArray(items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

  /**
   * Augment a target Object or Array by intercepting
   * the prototype chain using __proto__
   */
  function protoAugment(target, src) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  /**
   * Augment a target Object or Array by defining
   * hidden properties.
   */
  /* istanbul ignore next */
  function copyAugment(target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */
  function observe(value, asRootData) {
    if (!isObject(value) || value instanceof VNode) {
      return;
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob;
  }

  /**
   * Define a reactive property on an Object.
   */
  function defineReactive$$1(obj, key, val, customSetter, shallow) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key];
    }

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter() {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        /* eslint-enable no-self-compare */
        if (customSetter) {
          customSetter();
        }
        // #7981: for accessor properties without setter
        if (getter && !setter) {
          return;
        }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }

  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */
  function set(target, key, val) {
    if (isUndef(target) || isPrimitive(target)) {
      warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
      return val;
    }
    if (!ob) {
      target[key] = val;
      return val;
    }
    defineReactive$$1(ob.value, key, val);
    ob.dep.notify();
    return val;
  }

  /**
   * Delete a property and trigger change if necessary.
   */
  function del(target, key) {
    if (isUndef(target) || isPrimitive(target)) {
      warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
      return;
    }
    if (!hasOwn(target, key)) {
      return;
    }
    delete target[key];
    if (!ob) {
      return;
    }
    ob.dep.notify();
  }

  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */
  function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }

  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */
  var strats = config.optionMergeStrategies;

  /**
   * Options with restrictions
   */
  {
    strats.el = strats.propsData = function (parent, child, vm, key) {
      if (!vm) {
        warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
      }
      return defaultStrat(parent, child);
    };
  }

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData(to, from) {
    if (!from) {
      return to;
    }
    var key, toVal, fromVal;

    var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      // in case the object is already observed...
      if (key === '__ob__') {
        continue;
      }
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
        mergeData(toVal, fromVal);
      }
    }
    return to;
  }

  /**
   * Data
   */
  function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal;
      }
      if (!parentVal) {
        return childVal;
      }
      // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.
      return function mergedDataFn() {
        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
      };
    } else {
      return function mergedInstanceDataFn() {
        // instance merge
        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData);
        } else {
          return defaultData;
        }
      };
    }
  }

  strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {
        warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

        return parentVal;
      }
      return mergeDataOrFn(parentVal, childVal);
    }

    return mergeDataOrFn(parentVal, childVal, vm);
  };

  /**
   * Hooks and props are merged as arrays.
   */
  function mergeHook(parentVal, childVal) {
    var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
    return res ? dedupeHooks(res) : res;
  }

  function dedupeHooks(hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
      if (res.indexOf(hooks[i]) === -1) {
        res.push(hooks[i]);
      }
    }
    return res;
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */
  function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);
    if (childVal) {
      assertObjectType(key, childVal, vm);
      return extend(res, childVal);
    } else {
      return res;
    }
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */
  strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) {
      parentVal = undefined;
    }
    if (childVal === nativeWatch) {
      childVal = undefined;
    }
    /* istanbul ignore if */
    if (!childVal) {
      return Object.create(parentVal || null);
    }
    {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
    }
    return ret;
  };

  /**
   * Other object hashes.
   */
  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
    if (childVal && "development" !== 'production') {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) {
      extend(ret, childVal);
    }
    return ret;
  };
  strats.provide = mergeDataOrFn;

  /**
   * Default strategy.
   */
  var defaultStrat = function defaultStrat(parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
  };

  /**
   * Validate component names
   */
  function checkComponents(options) {
    for (var key in options.components) {
      validateComponentName(key);
    }
  }

  function validateComponentName(name) {
    if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
      warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
    }
  }

  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */
  function normalizeProps(options, vm) {
    var props = options.props;
    if (!props) {
      return;
    }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        } else {
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val) ? val : { type: val };
      }
    } else {
      warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
    }
    options.props = res;
  }

  /**
   * Normalize all injections into Object-based format
   */
  function normalizeInject(options, vm) {
    var inject = options.inject;
    if (!inject) {
      return;
    }
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] };
      }
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
      }
    } else {
      warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
    }
  }

  /**
   * Normalize raw function directives into object format.
   */
  function normalizeDirectives(options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def$$1 = dirs[key];
        if (typeof def$$1 === 'function') {
          dirs[key] = { bind: def$$1, update: def$$1 };
        }
      }
    }
  }

  function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
      warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
    }
  }

  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */
  function mergeOptions(parent, child, vm) {
    {
      checkComponents(child);
    }

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);

    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }
      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
    }

    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField(key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
  }

  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */
  function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return;
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) {
      return assets[id];
    }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) {
      return assets[camelizedId];
    }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) {
      return assets[PascalCaseId];
    }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
    }
    return res;
  }

  /*  */

  function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (value === '' || value === hyphenate(key)) {
        // only cast empty string / same name to boolean if
        // boolean has higher priority
        var stringIndex = getTypeIndex(String, prop.type);
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    // check default value
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value;
  }

  /**
   * Get the default value of a prop.
   */
  function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined;
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if (isObject(def)) {
      warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
      return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
  }

  /**
   * Assert whether a prop is valid.
   */
  function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
      warn('Missing required prop: "' + name + '"', vm);
      return;
    }
    if (value == null && !prop.required) {
      return;
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i]);
        expectedTypes.push(assertedType.expectedType || '');
        valid = assertedType.valid;
      }
    }

    if (!valid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
      return;
    }
    var validator = prop.validator;
    if (validator) {
      if (!validator(value)) {
        warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
      }
    }
  }

  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

  function assertType(value, type) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
      var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
      valid = t === expectedType.toLowerCase();
      // for primitive wrapper objects
      if (!valid && t === 'object') {
        valid = value instanceof type;
      }
    } else if (expectedType === 'Object') {
      valid = isPlainObject(value);
    } else if (expectedType === 'Array') {
      valid = Array.isArray(value);
    } else {
      valid = value instanceof type;
    }
    return {
      valid: valid,
      expectedType: expectedType
    };
  }

  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */
  function getType(fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
  }

  function isSameType(a, b) {
    return getType(a) === getType(b);
  }

  function getTypeIndex(type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i;
      }
    }
    return -1;
  }

  function getInvalidTypeMessage(name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    var expectedValue = styleValue(value, expectedType);
    var receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += " with value " + expectedValue;
    }
    message += ", got " + receivedType + " ";
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
      message += "with value " + receivedValue + ".";
    }
    return message;
  }

  function styleValue(value, type) {
    if (type === 'String') {
      return "\"" + value + "\"";
    } else if (type === 'Number') {
      return "" + Number(value);
    } else {
      return "" + value;
    }
  }

  function isExplicable(value) {
    var explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(function (elem) {
      return value.toLowerCase() === elem;
    });
  }

  function isBoolean() {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }return args.some(function (elem) {
      return elem.toLowerCase() === 'boolean';
    });
  }

  /*  */

  function handleError(err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
      if (vm) {
        var cur = vm;
        while (cur = cur.$parent) {
          var hooks = cur.$options.errorCaptured;
          if (hooks) {
            for (var i = 0; i < hooks.length; i++) {
              try {
                var capture = hooks[i].call(cur, err, vm, info) === false;
                if (capture) {
                  return;
                }
              } catch (e) {
                globalHandleError(e, cur, 'errorCaptured hook');
              }
            }
          }
        }
      }
      globalHandleError(err, vm, info);
    } finally {
      popTarget();
    }
  }

  function invokeWithErrorHandling(handler, context, args, vm, info) {
    var res;
    try {
      res = args ? handler.apply(context, args) : handler.call(context);
      if (res && !res._isVue && isPromise(res) && !res._handled) {
        res.catch(function (e) {
          return handleError(e, vm, info + " (Promise/async)");
        });
        // issue #9511
        // avoid catch triggering multiple times when nested calls
        res._handled = true;
      }
    } catch (e) {
      handleError(e, vm, info);
    }
    return res;
  }

  function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info);
      } catch (e) {
        // if the user intentionally throws the original error in the handler,
        // do not log it twice
        if (e !== err) {
          logError(e, null, 'config.errorHandler');
        }
      }
    }
    logError(err, vm, info);
  }

  function logError(err, vm, info) {
    {
      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
    }
    /* istanbul ignore else */
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }

  /*  */

  var isUsingMicroTask = false;

  var callbacks = [];
  var pending = false;

  function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // Here we have async deferring wrappers using microtasks.
  // In 2.5 we used (macro) tasks (in combination with microtasks).
  // However, it has subtle problems when state is changed right before repaint
  // (e.g. #6813, out-in transitions).
  // Also, using (macro) tasks in event handler would cause some weird behaviors
  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
  // So we now use microtasks everywhere, again.
  // A major drawback of this tradeoff is that there are some scenarios
  // where microtasks have too high a priority and fire in between supposedly
  // sequential events (e.g. #4521, #6690, which have workarounds)
  // or even between bubbling of the same event (#6566).
  var timerFunc;

  // The nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore next, $flow-disable-line */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    timerFunc = function timerFunc() {
      p.then(flushCallbacks);
      // In problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
    isUsingMicroTask = true;
  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function timerFunc() {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
    isUsingMicroTask = true;
  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Techinically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function timerFunc() {
      setImmediate(flushCallbacks);
    };
  } else {
    // Fallback to setTimeout.
    timerFunc = function timerFunc() {
      setTimeout(flushCallbacks, 0);
    };
  }

  function nextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  }

  /*  */

  var mark;
  var measure;

  {
    var perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
      mark = function mark(tag) {
        return perf.mark(tag);
      };
      measure = function measure(name, startTag, endTag) {
        perf.measure(name, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
        // perf.clearMeasures(name)
      };
    }
  }

  /* not type checking this file because flow doesn't play well with Proxy */

  var initProxy;

  {
    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
    );

    var warnNonPresent = function warnNonPresent(target, key) {
      warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };

    var warnReservedPrefix = function warnReservedPrefix(target, key) {
      warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
    };

    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

    if (hasProxy) {
      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set(target, key, value) {
          if (isBuiltInModifier(key)) {
            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
            return false;
          } else {
            target[key] = value;
            return true;
          }
        }
      });
    }

    var hasHandler = {
      has: function has(target, key) {
        var has = key in target;
        var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);
        if (!has && !isAllowed) {
          if (key in target.$data) {
            warnReservedPrefix(target, key);
          } else {
            warnNonPresent(target, key);
          }
        }
        return has || !isAllowed;
      }
    };

    var getHandler = {
      get: function get(target, key) {
        if (typeof key === 'string' && !(key in target)) {
          if (key in target.$data) {
            warnReservedPrefix(target, key);
          } else {
            warnNonPresent(target, key);
          }
        }
        return target[key];
      }
    };

    initProxy = function initProxy(vm) {
      if (hasProxy) {
        // determine which proxy handler to use
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }

  /*  */

  var seenObjects = new _Set();

  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */
  function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }

  function _traverse(val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
      return;
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return;
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) {
        _traverse(val[i], seen);
      }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) {
        _traverse(val[keys[i]], seen);
      }
    }
  }

  /*  */

  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    };
  });

  function createFnInvoker(fns, vm) {
    function invoker() {
      var arguments$1 = arguments;

      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
        }
      } else {
        // return handler return value for single handlers
        return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
      }
    }
    invoker.fns = fns;
    return invoker;
  }

  function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
    var name, def$$1, cur, old, event;
    for (name in on) {
      def$$1 = cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      if (isUndef(cur)) {
        warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur, vm);
        }
        if (isTrue(event.once)) {
          cur = on[name] = createOnceHandler(event.name, cur, event.capture);
        }
        add(event.name, cur, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  /*  */

  function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook() {
      hook.apply(this, arguments);
      // important: remove merged hook to ensure it's called only once
      // and prevent memory leak
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  /*  */

  function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return;
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        {
          var keyInLowerCase = key.toLowerCase();
          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
            tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
          }
        }
        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
      }
    }
    return res;
  }

  function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true;
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true;
      }
    }
    return false;
  }

  /*  */

  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:

  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.
  function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children);
      }
    }
    return children;
  }

  // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.
  function normalizeChildren(children) {
    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
  }

  function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
  }

  function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === 'boolean') {
        continue;
      }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      //  nested
      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
          // merge adjacent text nodes
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c[0].text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res;
  }

  /*  */

  function initProvide(vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
    }
  }

  function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      toggleObserving(false);
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive$$1(vm, key, result[key], function () {
            warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
          });
        }
      });
      toggleObserving(true);
    }
  }

  function resolveInject(inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        // #6574 in case the inject object is observed...
        if (key === '__ob__') {
          continue;
        }
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break;
          }
          source = source.$parent;
        }
        if (!source) {
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
          } else {
            warn("Injection \"" + key + "\" not found", vm);
          }
        }
      }
      return result;
    }
  }

  /*  */

  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */
  function resolveSlots(children, context) {
    if (!children || !children.length) {
      return {};
    }
    var slots = {};
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data;
      // remove slot attribute if the node is resolved as a Vue slot node
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      // named slots should only be respected if the vnode was rendered in the
      // same context.
      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
        var name = data.slot;
        var slot = slots[name] || (slots[name] = []);
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    }
    // ignore slots that contains only whitespace
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots;
  }

  function isWhitespace(node) {
    return node.isComment && !node.asyncFactory || node.text === ' ';
  }

  /*  */

  function normalizeScopedSlots(slots, normalSlots, prevSlots) {
    var res;
    var isStable = slots ? !!slots.$stable : true;
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var key = slots && slots.$key;
    if (!slots) {
      res = {};
    } else if (slots._normalized) {
      // fast path 1: child component re-render only, parent did not change
      return slots._normalized;
    } else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
      // fast path 2: stable scoped slots w/ no normal slots to proxy,
      // only need to normalize once
      return prevSlots;
    } else {
      res = {};
      for (var key$1 in slots) {
        if (slots[key$1] && key$1[0] !== '$') {
          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
        }
      }
    }
    // expose normal slots on scopedSlots
    for (var key$2 in normalSlots) {
      if (!(key$2 in res)) {
        res[key$2] = proxyNormalSlot(normalSlots, key$2);
      }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (slots && Object.isExtensible(slots)) {
      slots._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res;
  }

  function normalizeScopedSlot(normalSlots, key, fn) {
    var normalized = function normalized() {
      var res = arguments.length ? fn.apply(null, arguments) : fn({});
      res = res && (typeof res === 'undefined' ? 'undefined' : _typeof(res)) === 'object' && !Array.isArray(res) ? [res] // single vnode
      : normalizeChildren(res);
      return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658
      ) ? undefined : res;
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
      Object.defineProperty(normalSlots, key, {
        get: normalized,
        enumerable: true,
        configurable: true
      });
    }
    return normalized;
  }

  function proxyNormalSlot(slots, key) {
    return function () {
      return slots[key];
    };
  }

  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */
  function renderList(val, render) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      if (hasSymbol && val[Symbol.iterator]) {
        ret = [];
        var iterator = val[Symbol.iterator]();
        var result = iterator.next();
        while (!result.done) {
          ret.push(render(result.value, ret.length));
          result = iterator.next();
        }
      } else {
        keys = Object.keys(val);
        ret = new Array(keys.length);
        for (i = 0, l = keys.length; i < l; i++) {
          key = keys[i];
          ret[i] = render(val[key], key, i);
        }
      }
    }
    if (!isDef(ret)) {
      ret = [];
    }
    ret._isVList = true;
    return ret;
  }

  /*  */

  /**
   * Runtime helper for rendering <slot>
   */
  function renderSlot(name, fallback, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
      // scoped slot
      props = props || {};
      if (bindObject) {
        if (!isObject(bindObject)) {
          warn('slot v-bind without argument expects an Object', this);
        }
        props = extend(extend({}, bindObject), props);
      }
      nodes = scopedSlotFn(props) || fallback;
    } else {
      nodes = this.$slots[name] || fallback;
    }

    var target = props && props.slot;
    if (target) {
      return this.$createElement('template', { slot: target }, nodes);
    } else {
      return nodes;
    }
  }

  /*  */

  /**
   * Runtime helper for resolving filters
   */
  function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
  }

  /*  */

  function isKeyNotMatch(expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1;
    } else {
      return expect !== actual;
    }
  }

  /**
   * Runtime helper for checking keyCodes from config.
   * exposed as Vue.prototype._k
   * passing in eventKeyName as last argument separately for backwards compat
   */
  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName);
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key;
    }
  }

  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */
  function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
      if (!isObject(value)) {
        warn('v-bind without argument expects an Object or Array value', this);
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function loop(key) {
          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
          }
          var camelizedKey = camelize(key);
          var hyphenatedKey = hyphenate(key);
          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on["update:" + key] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) {
          loop(key);
        }
      }
    }
    return data;
  }

  /*  */

  /**
   * Runtime helper for rendering static trees.
   */
  function renderStatic(index, isInFor) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
      return tree;
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
    );
    markStatic(tree, "__static__" + index, false);
    return tree;
  }

  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */
  function markOnce(tree, index, key) {
    markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
    return tree;
  }

  function markStatic(tree, key, isOnce) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], key + "_" + i, isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /*  */

  function bindObjectListeners(data, value) {
    if (value) {
      if (!isPlainObject(value)) {
        warn('v-on without argument expects an Object value', this);
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data;
  }

  /*  */

  function resolveScopedSlots(fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys, contentHashKey) {
    res = res || { $stable: !hasDynamicKeys };
    for (var i = 0; i < fns.length; i++) {
      var slot = fns[i];
      if (Array.isArray(slot)) {
        resolveScopedSlots(slot, res, hasDynamicKeys);
      } else if (slot) {
        // marker for reverse proxying v-slot without scope on this.$slots
        if (slot.proxy) {
          slot.fn.proxy = true;
        }
        res[slot.key] = slot.fn;
      }
    }
    if (contentHashKey) {
      res.$key = contentHashKey;
    }
    return res;
  }

  /*  */

  function bindDynamicKeys(baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
      var key = values[i];
      if (typeof key === 'string' && key) {
        baseObj[values[i]] = values[i + 1];
      } else if (key !== '' && key !== null) {
        // null is a speical value for explicitly removing a binding
        warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
      }
    }
    return baseObj;
  }

  // helper to dynamically append modifier runtime markers to event names.
  // ensure only append when value is already string, otherwise it will be cast
  // to string and cause the type check to miss.
  function prependModifier(value, symbol) {
    return typeof value === 'string' ? symbol + value : value;
  }

  /*  */

  function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
  }

  /*  */

  function FunctionalRenderContext(data, props, children, parent, Ctor) {
    var this$1 = this;

    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
      contextVm = Object.create(parent);
      // $flow-disable-line
      contextVm._original = parent;
    } else {
      // the context vm passed in is a functional context as well.
      // in this case we want to make sure we are able to get a hold to the
      // real context instance.
      contextVm = parent;
      // $flow-disable-line
      parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
      if (!this$1.$slots) {
        normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
      }
      return this$1.$slots;
    };

    Object.defineProperty(this, 'scopedSlots', {
      enumerable: true,
      get: function get() {
        return normalizeScopedSlots(data.scopedSlots, this.slots());
      }
    });

    // support for compiled functional template
    if (isCompiled) {
      // exposing $options for renderStatic()
      this.$options = options;
      // pre-resolve slots for renderSlot()
      this.$slots = this.slots();
      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }
        return vnode;
      };
    } else {
      this._c = function (a, b, c, d) {
        return createElement(contextVm, a, b, c, d, needNormalization);
      };
    }
  }

  installRenderHelpers(FunctionalRenderContext.prototype);

  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) {
        mergeProps(props, data.attrs);
      }
      if (isDef(data.props)) {
        mergeProps(props, data.props);
      }
    }

    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);
      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
      }
      return res;
    }
  }

  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    {
      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
    }
    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
  }

  function mergeProps(to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  /*  */

  /*  */

  /*  */

  /*  */

  // inline hooks to be invoked on component VNodes during patch
  var componentVNodeHooks = {
    init: function init(vnode, hydrating) {
      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },

    prepatch: function prepatch(oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(child, options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
      );
    },

    insert: function insert(vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },

    destroy: function destroy(vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
      return;
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
      {
        warn("Invalid Component definition: " + String(Ctor), context);
      }
      return;
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
      }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    // functional component
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children);
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot

      // work around flow
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // install component management hooks onto the placeholder node
    installComponentHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);

    return vnode;
  }

  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
  ) {
    var options = {
      _isComponent: true,
      _parentVnode: vnode,
      parent: parent
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
  }

  function installComponentHooks(data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var existing = hooks[key];
      var toMerge = componentVNodeHooks[key];
      if (existing !== toMerge && !(existing && existing._merged)) {
        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
      }
    }
  }

  function mergeHook$1(f1, f2) {
    var merged = function merged(a, b) {
      // flow complains about extra args which is why we use any
      f1(a, b);
      f2(a, b);
    };
    merged._merged = true;
    return merged;
  }

  // transform component v-model info (value and callback) into
  // prop and event handler respectively.
  function transformModel(options, data) {
    var prop = options.model && options.model.prop || 'value';
    var event = options.model && options.model.event || 'input';(data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
      if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
        on[event] = [callback].concat(existing);
      }
    } else {
      on[event] = callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // wrapper function for providing a more flexible interface
  // without getting yelled at by flow
  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
  }

  function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
      warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
      return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode();
    }
    // warn against non-primitive key
    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
      {
        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
      }
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) && typeof children[0] === 'function') {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
      var Ctor;
      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // platform built-in elements
        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(tag, data, children, undefined, undefined, context);
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
      return vnode;
    } else if (isDef(vnode)) {
      if (isDef(ns)) {
        applyNS(vnode, ns);
      }
      if (isDef(data)) {
        registerDeepBindings(data);
      }
      return vnode;
    } else {
      return createEmptyVNode();
    }
  }

  function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      ns = undefined;
      force = true;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
          applyNS(child, ns, force);
        }
      }
    }
  }

  // ref #5318
  // necessary to ensure parent re-render when deep bindings like :style and
  // :class are used on slot nodes
  function registerDeepBindings(data) {
    if (isObject(data.style)) {
      traverse(data.style);
    }
    if (isObject(data.class)) {
      traverse(data.class);
    }
  }

  /*  */

  function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, false);
    };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, true);
    };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;

    /* istanbul ignore else */
    {
      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }

  var currentRenderingInstance = null;

  function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this);
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      if (_parentVnode) {
        vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
      }

      // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        // There's no need to maintain a stack becaues all render fns are called
        // separately from one another. Nested component's render fns are called
        // when parent component is patched.
        currentRenderingInstance = vm;
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } finally {
        currentRenderingInstance = null;
      }
      // if the returned array contains only a single node, allow it
      if (Array.isArray(vnode) && vnode.length === 1) {
        vnode = vnode[0];
      }
      // return empty vnode in case the render function errored out
      if (!(vnode instanceof VNode)) {
        if (Array.isArray(vnode)) {
          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
        }
        vnode = createEmptyVNode();
      }
      // set parent
      vnode.parent = _parentVnode;
      return vnode;
    };
  }

  /*  */

  function ensureCtor(comp, base) {
    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
      comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
  }

  function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node;
  }

  function resolveAsyncComponent(factory, baseCtor) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp;
    }

    if (isDef(factory.resolved)) {
      return factory.resolved;
    }

    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
      // already pending
      factory.owners.push(owner);
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp;
    }

    if (owner && !isDef(factory.owners)) {
      var owners = factory.owners = [owner];
      var sync = true;owner.$on('hook:destroyed', function () {
        return remove(owners, owner);
      });

      var forceRender = function forceRender(renderCompleted) {
        for (var i = 0, l = owners.length; i < l; i++) {
          owners[i].$forceUpdate();
        }

        if (renderCompleted) {
          owners.length = 0;
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor);
        // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)
        if (!sync) {
          forceRender(true);
        } else {
          owners.length = 0;
        }
      });

      var reject = once(function (reason) {
        warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender(true);
        }
      });

      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (isPromise(res)) {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isPromise(res.component)) {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              setTimeout(function () {
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender(false);
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            setTimeout(function () {
              if (isUndef(factory.resolved)) {
                reject("timeout (" + res.timeout + "ms)");
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // return in case resolved synchronously
      return factory.loading ? factory.loadingComp : factory.resolved;
    }
  }

  /*  */

  function isAsyncPlaceholder(node) {
    return node.isComment && node.asyncFactory;
  }

  /*  */

  function getFirstComponentChild(children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c;
        }
      }
    }
  }

  /*  */

  /*  */

  function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add(event, fn) {
    target.$on(event, fn);
  }

  function remove$1(event, fn) {
    target.$off(event, fn);
  }

  function createOnceHandler(event, fn) {
    var _target = target;
    return function onceHandler() {
      var res = fn.apply(null, arguments);
      if (res !== null) {
        _target.$off(event, onceHandler);
      }
    };
  }

  function updateComponentListeners(vm, listeners, oldListeners) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
    target = undefined;
  }

  function eventsMixin(Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          vm.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm;
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;
      function on() {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm;
    };

    Vue.prototype.$off = function (event, fn) {
      var vm = this;
      // all
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm;
      }
      // array of events
      if (Array.isArray(event)) {
        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
          vm.$off(event[i$1], fn);
        }
        return vm;
      }
      // specific event
      var cbs = vm._events[event];
      if (!cbs) {
        return vm;
      }
      if (!fn) {
        vm._events[event] = null;
        return vm;
      }
      // specific handler
      var cb;
      var i = cbs.length;
      while (i--) {
        cb = cbs[i];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i, 1);
          break;
        }
      }
      return vm;
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
        }
      }
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        var info = "event handler for \"" + event + "\"";
        for (var i = 0, l = cbs.length; i < l; i++) {
          invokeWithErrorHandling(cbs[i], vm, args, vm, info);
        }
      }
      return vm;
    };
  }

  /*  */

  var activeInstance = null;
  var isUpdatingChildComponent = false;

  function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
      activeInstance = prevActiveInstance;
    };
  }

  function initLifecycle(vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var restoreActiveInstance = setActiveInstance(vm);
      vm._vnode = vnode;
      // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.
      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      restoreActiveInstance();
      // update __vue__ reference
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // if parent is an HOC, update its $el as well
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return;
      }
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      // remove self from parent
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      // teardown watchers
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // remove reference from data ob
      // frozen object may not have observer.
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      // invoke destroy hooks on current rendered tree
      vm.__patch__(vm._vnode, null);
      // fire destroyed hook
      callHook(vm, 'destroyed');
      // turn off all instance listeners.
      vm.$off();
      // remove __vue__ reference
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      // release circular reference (#6759)
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }

  function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        /* istanbul ignore if */
        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
        } else {
          warn('Failed to mount component: template or render function not defined.', vm);
        }
      }
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    if (config.performance && mark) {
      updateComponent = function updateComponent() {
        var name = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;

        mark(startTag);
        var vnode = vm._render();
        mark(endTag);
        measure("vue " + name + " render", startTag, endTag);

        mark(startTag);
        vm._update(vnode, hydrating);
        mark(endTag);
        measure("vue " + name + " patch", startTag, endTag);
      };
    } else {
      updateComponent = function updateComponent() {
        vm._update(vm._render(), hydrating);
      };
    }

    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, {
      before: function before() {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'beforeUpdate');
        }
      }
    }, true /* isRenderWatcher */);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm;
  }

  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    {
      isUpdatingChildComponent = true;
    }

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.

    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key);

    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    var needsForceUpdate = !!(renderChildren || // has new static slots
    vm.$options._renderChildren || // has old static slots
    hasDynamicScopedSlot);

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) {
      // update child tree's parent
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // update props
    if (propsData && vm.$options.props) {
      toggleObserving(false);
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props; // wtf flow?
        props[key] = validateProp(key, propOptions, propsData, vm);
      }
      toggleObserving(true);
      // keep a copy of raw propsData
      vm.$options.propsData = propsData;
    }

    // update listeners
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);

    // resolve slots + force update if has children
    if (needsForceUpdate) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }

    {
      isUpdatingChildComponent = false;
    }
  }

  function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) {
        return true;
      }
    }
    return false;
  }

  function activateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return;
      }
    } else if (vm._directInactive) {
      return;
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return;
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'deactivated');
    }
  }

  function callHook(vm, hook) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        invokeWithErrorHandling(handlers[i], vm, null, vm, info);
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
    popTarget();
  }

  /*  */

  var MAX_UPDATE_COUNT = 100;

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * Reset the scheduler's state.
   */
  function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  }

  // Async edge case #6566 requires saving the timestamp when event listeners are
  // attached. However, calling performance.now() has a perf overhead especially
  // if the page has thousands of event listeners. Instead, we take a timestamp
  // every time the scheduler flushes and use that for all event listeners
  // attached during that flush.
  var currentFlushTimestamp = 0;

  // Async edge case fix requires storing an event listener's attach timestamp.
  var getNow = Date.now;

  // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.
  if (inBrowser && window.performance && typeof performance.now === 'function' && document.createEvent('Event').timeStamp <= performance.now()) {
    // if the event timestamp is bigger than the hi-res timestamp
    // (which is evaluated AFTER) it means the event is using a lo-res timestamp,
    // and we need to use the lo-res version for event listeners as well.
    getNow = function getNow() {
      return performance.now();
    };
  }

  /**
   * Flush both queues and run the watchers.
   */
  function flushSchedulerQueue() {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) {
      return a.id - b.id;
    });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      if (watcher.before) {
        watcher.before();
      }
      id = watcher.id;
      has[id] = null;
      watcher.run();
      // in dev build, check and stop circular updates.
      if (has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
          break;
        }
      }
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks(queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */
  function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;

        if (!config.async) {
          flushSchedulerQueue();
          return;
        }
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */

  var uid$2 = 0;

  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */
  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
    this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
        warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
      }
    }
    this.value = this.lazy ? undefined : this.get();
  };

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  Watcher.prototype.get = function get() {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
      } else {
        throw e;
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value;
  };

  /**
   * Add a dependency to this directive.
   */
  Watcher.prototype.addDep = function addDep(dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps() {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  Watcher.prototype.update = function update() {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  Watcher.prototype.run = function run() {
    if (this.active) {
      var value = this.get();
      if (value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) || this.deep) {
        // set new value
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate() {
    this.value = this.get();
    this.dirty = false;
  };

  /**
   * Depend on all deps collected by this watcher.
   */
  Watcher.prototype.depend = function depend() {
    var i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  };

  /**
   * Remove self from all dependencies' subscriber list.
   */
  Watcher.prototype.teardown = function teardown() {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this.deps[i].removeSub(this);
      }
      this.active = false;
    }
  };

  /*  */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };

  function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
      return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState(vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) {
      initProps(vm, opts.props);
    }
    if (opts.methods) {
      initMethods(vm, opts.methods);
    }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) {
      initComputed(vm, opts.computed);
    }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function initProps(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
      toggleObserving(false);
    }
    var loop = function loop(key) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        var hyphenatedKey = hyphenate(key);
        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
          warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
        }
        defineReactive$$1(props, key, value, function () {
          if (!isRoot && !isUpdatingChildComponent) {
            warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
          }
        });
      }
      // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) {
      loop(key);
    }toggleObserving(true);
  }

  function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
      data = {};
      warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn("Method \"" + key + "\" has already been defined as a data property.", vm);
        }
      }
      if (props && hasOwn(props, key)) {
        warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }

  function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
      return data.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "data()");
      return {};
    } finally {
      popTarget();
    }
  }

  var computedWatcherOptions = { lazy: true };

  function initComputed(vm, computed) {
    // $flow-disable-line
    var watchers = vm._computedWatchers = Object.create(null);
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      if (getter == null) {
        warn("Getter is missing for computed property \"" + key + "\".", vm);
      }

      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
      }

      // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        if (key in vm.$data) {
          warn("The computed property \"" + key + "\" is already defined in data.", vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
        }
      }
    }
  }

  function defineComputed(target, key, userDef) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop;
      sharedPropertyDefinition.set = userDef.set || noop;
    }
    if (sharedPropertyDefinition.set === noop) {
      sharedPropertyDefinition.set = function () {
        warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
      };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter(key) {
    return function computedGetter() {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value;
      }
    };
  }

  function createGetterInvoker(fn) {
    return function computedGetter() {
      return fn.call(this, this);
    };
  }

  function initMethods(vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      {
        if (typeof methods[key] !== 'function') {
          warn("Method \"" + key + "\" has type \"" + _typeof(methods[key]) + "\" in the component definition. " + "Did you reference the function correctly?", vm);
        }
        if (props && hasOwn(props, key)) {
          warn("Method \"" + key + "\" has already been defined as a prop.", vm);
        }
        if (key in vm && isReserved(key)) {
          warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
        }
      }
      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
  }

  function initWatch(vm, watch) {
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
  }

  function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () {
      return this._data;
    };
    var propsDef = {};
    propsDef.get = function () {
      return this._props;
    };
    {
      dataDef.set = function () {
        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
      };
      propsDef.set = function () {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (expOrFn, cb, options) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options);
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        try {
          cb.call(vm, watcher.value);
        } catch (error) {
          handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
        }
      }
      return function unwatchFn() {
        watcher.teardown();
      };
    };
  }

  /*  */

  var uid$3 = 0;

  function initMixin(Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$3++;

      var startTag, endTag;
      /* istanbul ignore if */
      if (config.performance && mark) {
        startTag = "vue-perf-start:" + vm._uid;
        endTag = "vue-perf-end:" + vm._uid;
        mark(startTag);
      }

      // a flag to avoid this being observed
      vm._isVue = true;
      // merge options
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
      }
      /* istanbul ignore else */
      {
        initProxy(vm);
      }
      // expose real self
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props
      initState(vm);
      initProvide(vm); // resolve provide after data/props
      callHook(vm, 'created');

      /* istanbul ignore if */
      if (config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure("vue " + vm._name + " init", startTag, endTag);
      }

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent(vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;

    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions;
        // check if there are any late-modified/attached options (#4976)
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options;
  }

  function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) {
          modified = {};
        }
        modified[key] = latest[key];
      }
    }
    return modified;
  }

  function Vue(options) {
    if (!(this instanceof Vue)) {
      warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
  }

  initMixin(Vue);
  stateMixin(Vue);
  eventsMixin(Vue);
  lifecycleMixin(Vue);
  renderMixin(Vue);

  /*  */

  function initUse(Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
      if (installedPlugins.indexOf(plugin) > -1) {
        return this;
      }

      // additional parameters
      var args = toArray(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this;
    };
  }

  /*  */

  function initMixin$1(Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this;
    };
  }

  /*  */

  function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId];
      }

      var name = extendOptions.name || Super.options.name;
      if (name) {
        validateComponentName(name);
      }

      var Sub = function VueComponent(options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(Super.options, extendOptions);
      Sub['super'] = Super;

      // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

      // allow further extension/mixin/plugin usage
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

      // create asset registers, so extended classes
      // can have their private assets too.
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // enable recursive self-lookup
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

      // cache constructor
      cachedCtors[SuperId] = Sub;
      return Sub;
    };
  }

  function initProps$1(Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /*  */

  function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (id, definition) {
        if (!definition) {
          return this.options[type + 's'][id];
        } else {
          /* istanbul ignore if */
          if (type === 'component') {
            validateComponentName(id);
          }
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
          this.options[type + 's'][id] = definition;
          return definition;
        }
      };
    });
  }

  /*  */

  function getComponentName(opts) {
    return opts && (opts.Ctor.options.name || opts.tag);
  }

  function matches(pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1;
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1;
    } else if (isRegExp(pattern)) {
      return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
  }

  function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var cachedNode = cache[key];
      if (cachedNode) {
        var name = getComponentName(cachedNode.componentOptions);
        if (name && !filter(name)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry(cache, key, keys, current) {
    var cached$$1 = cache[key];
    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
      cached$$1.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];

  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    created: function created() {
      this.cache = Object.create(null);
      this.keys = [];
    },

    destroyed: function destroyed() {
      for (var key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys);
      }
    },

    mounted: function mounted() {
      var this$1 = this;

      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) {
          return matches(val, name);
        });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) {
          return !matches(val, name);
        });
      });
    },

    render: function render() {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        if (
        // not included
        include && (!name || !matches(include, name)) ||
        // excluded
        exclude && name && matches(exclude, name)) {
          return vnode;
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
          cache[key] = vnode;
          keys.push(key);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }

        vnode.data.keepAlive = true;
      }
      return vnode || slot && slot[0];
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive
  };

  /*  */

  function initGlobalAPI(Vue) {
    // config
    var configDef = {};
    configDef.get = function () {
      return config;
    };
    {
      configDef.set = function () {
        warn('Do not replace the Vue.config object, set individual fields instead.');
      };
    }
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive$$1
    };

    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    // 2.6 explicit observable API
    Vue.observable = function (obj) {
      observe(obj);
      return obj;
    };

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue);

  Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function get() {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext;
    }
  });

  // expose FunctionalRenderContext for ssr runtime helper installation
  Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
  });

  Vue.version = '2.6.9';

  /*  */

  // these are reserved for web because they are directly compiled away
  // during template compilation
  var isReservedAttr = makeMap('style,class');

  // attributes that should be using props for binding
  var acceptValue = makeMap('input,textarea,option,select,progress');
  var mustUseProp = function mustUseProp(tag, type, attr) {
    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

  var convertEnumeratedValue = function convertEnumeratedValue(key, value) {
    return isFalsyAttrValue(value) || value === 'false' ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
  };

  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function isXlink(name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
  };

  var getXlinkProp = function getXlinkProp(name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
  };

  var isFalsyAttrValue = function isFalsyAttrValue(val) {
    return val == null || val === false;
  };

  /*  */

  function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode && parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    return renderClass(data.staticClass, data.class);
  }

  function mergeClassData(child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
  }

  function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
  }

  function concat(a, b) {
    return a ? b ? a + ' ' + b : a : b || '';
  }

  function stringifyClass(value) {
    if (Array.isArray(value)) {
      return stringifyArray(value);
    }
    if (isObject(value)) {
      return stringifyObject(value);
    }
    if (typeof value === 'string') {
      return value;
    }
    /* istanbul ignore next */
    return '';
  }

  function stringifyArray(value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) {
          res += ' ';
        }
        res += stringified;
      }
    }
    return res;
  }

  function stringifyObject(value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) {
          res += ' ';
        }
        res += key;
      }
    }
    return res;
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };

  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

  // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.
  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

  var isPreTag = function isPreTag(tag) {
    return tag === 'pre';
  };

  var isReservedTag = function isReservedTag(tag) {
    return isHTMLTag(tag) || isSVG(tag);
  };

  function getTagNamespace(tag) {
    if (isSVG(tag)) {
      return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
      return 'math';
    }
  }

  var unknownElementCache = Object.create(null);
  function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true;
    }
    if (isReservedTag(tag)) {
      return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
    } else {
      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /*  */

  /**
   * Query an element selector if it's not an element already.
   */
  function query(el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        warn('Cannot find element: ' + el);
        return document.createElement('div');
      }
      return selected;
    } else {
      return el;
    }
  }

  /*  */

  function createElement$1(tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm;
  }

  function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
  }

  function createTextNode(text) {
    return document.createTextNode(text);
  }

  function createComment(text) {
    return document.createComment(text);
  }

  function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild(node, child) {
    node.removeChild(child);
  }

  function appendChild(node, child) {
    node.appendChild(child);
  }

  function parentNode(node) {
    return node.parentNode;
  }

  function nextSibling(node) {
    return node.nextSibling;
  }

  function tagName(node) {
    return node.tagName;
  }

  function setTextContent(node, text) {
    node.textContent = text;
  }

  function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
  }

  var nodeOps = /*#__PURE__*/Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });

  /*  */

  var ref = {
    create: function create(_, vnode) {
      registerRef(vnode);
    },
    update: function update(oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy(vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef(vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!isDef(key)) {
      return;
    }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode(a, b) {
    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
  }

  function sameInputType(a, b) {
    if (a.tag !== 'input') {
      return true;
    }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
  }

  function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) {
        map[key] = i;
      }
    }
    return map;
  }

  function createPatchFunction(backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt(elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }

    function createRmCb(childElm, listeners) {
      function remove$$1() {
        if (--remove$$1.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove$$1.listeners = listeners;
      return remove$$1;
    }

    function removeNode(el) {
      var parent = nodeOps.parentNode(el);
      // element may have already been removed due to v-html / v-text
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    function isUnknownElement$$1(vnode, inVPre) {
      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
      })) && config.isUnknownElement(vnode.tag);
    }

    var creatingElmInVPre = 0;

    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // This vnode was used in a previous render!
        // now it's used as a new node, overwriting its elm would cause
        // potential patch errors down the road when it's used as an insertion
        // reference node. Instead, we clone the node on-demand before creating
        // associated DOM element for it.
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return;
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }
          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
          }
        }

        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }

        if (data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */);
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true;
        }
      }
    }

    function initComponent(vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode);
        // make sure to invoke the insert hook
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break;
        }
      }
      // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself
      insert(parentElm, vnode.elm, refElm);
    }

    function insert(parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (nodeOps.parentNode(ref$$1) === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren(vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        {
          checkDuplicateKeys(children);
        }
        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
      }
    }

    function isPatchable(vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag);
    }

    function invokeCreateHooks(vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (isDef(i.create)) {
          i.create(emptyNode, vnode);
        }
        if (isDef(i.insert)) {
          insertedVnodeQueue.push(vnode);
        }
      }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
      var i;
      if (isDef(i = vnode.fnScopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      } else {
        var ancestor = vnode;
        while (ancestor) {
          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
            nodeOps.setStyleScope(vnode.elm, i);
          }
          ancestor = ancestor.parent;
        }
      }
      // for slot content they should also get the scopeId from the host instance.
      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      }
    }

    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
      }
    }

    function invokeDestroyHook(vnode) {
      var i, j;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) {
          i(vnode);
        }
        for (i = 0; i < cbs.destroy.length; ++i) {
          cbs.destroy[i](vnode);
        }
      }
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else {
            // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook(vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        }
        // recursively invoke hooks on child component root node
        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }
        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }
        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

      // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions
      var canMove = !removeOnly;

      {
        checkDuplicateKeys(newCh);
      }

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }
          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
          if (isUndef(idxInOld)) {
            // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          } else {
            vnodeToMove = oldCh[idxInOld];
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            }
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function checkDuplicateKeys(children) {
      var seenKeys = {};
      for (var i = 0; i < children.length; i++) {
        var vnode = children[i];
        var key = vnode.key;
        if (isDef(key)) {
          if (seenKeys[key]) {
            warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
          } else {
            seenKeys[key] = true;
          }
        }
      }
    }

    function findIdxInOld(node, oldCh, start, end) {
      for (var i = start; i < end; i++) {
        var c = oldCh[i];
        if (isDef(c) && sameVnode(node, c)) {
          return i;
        }
      }
    }

    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
      if (oldVnode === vnode) {
        return;
      }

      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // clone reused vnode
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return;
      }

      // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.
      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
        vnode.componentInstance = oldVnode.componentInstance;
        return;
      }

      var i;
      var data = vnode.data;
      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) {
          cbs.update[i](oldVnode, vnode);
        }
        if (isDef(i = data.hook) && isDef(i = i.update)) {
          i(oldVnode, vnode);
        }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) {
            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          }
        } else if (isDef(ch)) {
          {
            checkDuplicateKeys(ch);
          }
          if (isDef(oldVnode.text)) {
            nodeOps.setTextContent(elm, '');
          }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(elm, oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
          i(oldVnode, vnode);
        }
      }
    }

    function invokeInsertHook(vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }

    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
      var i;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || data && data.pre;
      vnode.elm = elm;

      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true;
      }
      // assert node match
      {
        if (!assertNodeMatch(elm, vnode, inVPre)) {
          return false;
        }
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) {
          i(vnode, true /* hydrating */);
        }
        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true;
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            // v-html and domProps: innerHTML
            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
              if (i !== elm.innerHTML) {
                /* istanbul ignore if */
                if (typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('server innerHTML: ', i);
                  console.warn('client innerHTML: ', elm.innerHTML);
                }
                return false;
              }
            } else {
              // iterate and compare children lists
              var childrenMatch = true;
              var childNode = elm.firstChild;
              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break;
                }
                childNode = childNode.nextSibling;
              }
              // if childNode is not null, it means the actual childNodes list is
              // longer than the virtual children list.
              if (!childrenMatch || childNode) {
                /* istanbul ignore if */
                if (typeof console !== 'undefined' && !hydrationBailed) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                }
                return false;
              }
            }
          }
        }
        if (isDef(data)) {
          var fullInvoke = false;
          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break;
            }
          }
          if (!fullInvoke && data['class']) {
            // ensure collecting deps for deep class bindings for future updates
            traverse(data['class']);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true;
    }

    function assertNodeMatch(node, vnode, inVPre) {
      if (isDef(vnode.tag)) {
        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
      } else {
        return node.nodeType === (vnode.isComment ? 8 : 3);
      }
    }

    return function patch(oldVnode, vnode, hydrating, removeOnly) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) {
          invokeDestroyHook(oldVnode);
        }
        return;
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode;
              } else {
                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
              }
            }
            // either not server-rendered, or hydration failed.
            // create an empty node and replace it
            oldVnode = emptyNodeAt(oldVnode);
          }

          // replacing existing element
          var oldElm = oldVnode.elm;
          var parentElm = nodeOps.parentNode(oldElm);

          // create new node
          createElm(vnode, insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));

          // update parent placeholder node element, recursively
          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);
            while (ancestor) {
              for (var i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](ancestor);
              }
              ancestor.elm = vnode.elm;
              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                }
                // #6513
                // invoke insert hooks that may have been merged by create hooks.
                // e.g. for directives that uses the "inserted" hook.
                var insert = ancestor.data.hook.insert;
                if (insert.merged) {
                  // start at index 1 to avoid re-invoking component mounted hook
                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                    insert.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }
              ancestor = ancestor.parent;
            }
          }

          // destroy old node
          if (isDef(parentElm)) {
            removeVnodes(parentElm, [oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm;
    };
  }

  /*  */

  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        dir.oldArg = oldDir.arg;
        callHook$1(dir, 'update', vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function callInsert() {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
      // $flow-disable-line
      return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        // $flow-disable-line
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res;
  }

  function getRawDirName(dir) {
    return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
  }

  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
      }
    }
  }

  var baseModules = [ref, directives];

  /*  */

  function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr(el, key, value) {
    if (el.tagName.indexOf('-') > -1) {
      baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // technically allowfullscreen is a boolean attribute for <iframe>,
        // but Flash expects a value of "true" when used on <embed> tag
        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, convertEnumeratedValue(key, value));
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      baseSetAttr(el, key, value);
    }
  }

  function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
        var blocker = function blocker(e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs
  };

  /*  */

  function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
      return;
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass
  };

  /*  */

  var validDivisionCharRE = /[\w).+\-_$\]]/;

  function parseFilters(exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 0x27 && prev !== 0x5C) {
          inSingle = false;
        }
      } else if (inDouble) {
        if (c === 0x22 && prev !== 0x5C) {
          inDouble = false;
        }
      } else if (inTemplateString) {
        if (c === 0x60 && prev !== 0x5C) {
          inTemplateString = false;
        }
      } else if (inRegex) {
        if (c === 0x2f && prev !== 0x5C) {
          inRegex = false;
        }
      } else if (c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
        if (expression === undefined) {
          // first filter, end of expression
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 0x22:
            inDouble = true;break; // "
          case 0x27:
            inSingle = true;break; // '
          case 0x60:
            inTemplateString = true;break; // `
          case 0x28:
            paren++;break; // (
          case 0x29:
            paren--;break; // )
          case 0x5B:
            square++;break; // [
          case 0x5D:
            square--;break; // ]
          case 0x7B:
            curly++;break; // {
          case 0x7D:
            curly--;break; // }
        }
        if (c === 0x2f) {
          // /
          var j = i - 1;
          var p = void 0;
          // find first non-whitespace prev char
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== ' ') {
              break;
            }
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }

    if (expression === undefined) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }

    function pushFilter() {
      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }

    if (filters) {
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i]);
      }
    }

    return expression;
  }

  function wrapFilter(exp, filter) {
    var i = filter.indexOf('(');
    if (i < 0) {
      // _f: resolveFilter
      return "_f(\"" + filter + "\")(" + exp + ")";
    } else {
      var name = filter.slice(0, i);
      var args = filter.slice(i + 1);
      return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
    }
  }

  /*  */

  /* eslint-disable no-unused-vars */
  function baseWarn(msg, range) {
    console.error("[Vue compiler]: " + msg);
  }
  /* eslint-enable no-unused-vars */

  function pluckModuleFunction(modules, key) {
    return modules ? modules.map(function (m) {
      return m[key];
    }).filter(function (_) {
      return _;
    }) : [];
  }

  function addProp(el, name, value, range, dynamic) {
    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
    el.plain = false;
  }

  function addAttr(el, name, value, range, dynamic) {
    var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
    el.plain = false;
  }

  // add a raw attr (use this in preTransforms)
  function addRawAttr(el, name, value, range) {
    el.attrsMap[name] = value;
    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
  }

  function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
    (el.directives || (el.directives = [])).push(rangeSetItem({
      name: name,
      rawName: rawName,
      value: value,
      arg: arg,
      isDynamicArg: isDynamicArg,
      modifiers: modifiers
    }, range));
    el.plain = false;
  }

  function prependModifierMarker(symbol, name, dynamic) {
    return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
  }

  function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
    modifiers = modifiers || emptyObject;
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if (warn && modifiers.prevent && modifiers.passive) {
      warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
    }

    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (modifiers.right) {
      if (dynamic) {
        name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
      } else if (name === 'click') {
        name = 'contextmenu';
        delete modifiers.right;
      }
    } else if (modifiers.middle) {
      if (dynamic) {
        name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
      } else if (name === 'click') {
        name = 'mouseup';
      }
    }

    // check capture modifier
    if (modifiers.capture) {
      delete modifiers.capture;
      name = prependModifierMarker('!', name, dynamic);
    }
    if (modifiers.once) {
      delete modifiers.once;
      name = prependModifierMarker('~', name, dynamic);
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
      delete modifiers.passive;
      name = prependModifierMarker('&', name, dynamic);
    }

    var events;
    if (modifiers.native) {
      delete modifiers.native;
      events = el.nativeEvents || (el.nativeEvents = {});
    } else {
      events = el.events || (el.events = {});
    }

    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
    if (modifiers !== emptyObject) {
      newHandler.modifiers = modifiers;
    }

    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
      important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }

    el.plain = false;
  }

  function getRawBindingAttr(el, name) {
    return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
  }

  function getBindingAttr(el, name, getStatic) {
    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
      return parseFilters(dynamicValue);
    } else if (getStatic !== false) {
      var staticValue = getAndRemoveAttr(el, name);
      if (staticValue != null) {
        return JSON.stringify(staticValue);
      }
    }
  }

  // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.
  function getAndRemoveAttr(el, name, removeFromMap) {
    var val;
    if ((val = el.attrsMap[name]) != null) {
      var list = el.attrsList;
      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].name === name) {
          list.splice(i, 1);
          break;
        }
      }
    }
    if (removeFromMap) {
      delete el.attrsMap[name];
    }
    return val;
  }

  function getAndRemoveAttrByRegex(el, name) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      var attr = list[i];
      if (name.test(attr.name)) {
        list.splice(i, 1);
        return attr;
      }
    }
  }

  function rangeSetItem(item, range) {
    if (range) {
      if (range.start != null) {
        item.start = range.start;
      }
      if (range.end != null) {
        item.end = range.end;
      }
    }
    return item;
  }

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */
  function genComponentModel(el, value, modifiers) {
    var ref = modifiers || {};
    var number = ref.number;
    var trim = ref.trim;

    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;
    if (trim) {
      valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }
    var assignment = genAssignmentCode(value, valueExpression);

    el.model = {
      value: "(" + value + ")",
      expression: JSON.stringify(value),
      callback: "function (" + baseValueExpression + ") {" + assignment + "}"
    };
  }

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */
  function genAssignmentCode(value, assignment) {
    var res = parseModel(value);
    if (res.key === null) {
      return value + "=" + assignment;
    } else {
      return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
    }
  }

  /**
   * Parse a v-model expression into a base path and a final key segment.
   * Handles both dot-path and possible square brackets.
   *
   * Possible cases:
   *
   * - test
   * - test[key]
   * - test[test1[key]]
   * - test["a"][key]
   * - xxx.test[a[a].test1[key]]
   * - test.xxx.a["asa"][test1[key]]
   *
   */

  var len, str, chr, index$1, expressionPos, expressionEndPos;

  function parseModel(val) {
    // Fix https://github.com/vuejs/vue/pull/7730
    // allow v-model="obj.val " (trailing whitespace)
    val = val.trim();
    len = val.length;

    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
      index$1 = val.lastIndexOf('.');
      if (index$1 > -1) {
        return {
          exp: val.slice(0, index$1),
          key: '"' + val.slice(index$1 + 1) + '"'
        };
      } else {
        return {
          exp: val,
          key: null
        };
      }
    }

    str = val;
    index$1 = expressionPos = expressionEndPos = 0;

    while (!eof()) {
      chr = next();
      /* istanbul ignore if */
      if (isStringStart(chr)) {
        parseString(chr);
      } else if (chr === 0x5B) {
        parseBracket(chr);
      }
    }

    return {
      exp: val.slice(0, expressionPos),
      key: val.slice(expressionPos + 1, expressionEndPos)
    };
  }

  function next() {
    return str.charCodeAt(++index$1);
  }

  function eof() {
    return index$1 >= len;
  }

  function isStringStart(chr) {
    return chr === 0x22 || chr === 0x27;
  }

  function parseBracket(chr) {
    var inBracket = 1;
    expressionPos = index$1;
    while (!eof()) {
      chr = next();
      if (isStringStart(chr)) {
        parseString(chr);
        continue;
      }
      if (chr === 0x5B) {
        inBracket++;
      }
      if (chr === 0x5D) {
        inBracket--;
      }
      if (inBracket === 0) {
        expressionEndPos = index$1;
        break;
      }
    }
  }

  function parseString(chr) {
    var stringQuote = chr;
    while (!eof()) {
      chr = next();
      if (chr === stringQuote) {
        break;
      }
    }
  }

  /*  */

  var warn$1;

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  function model(el, dir, _warn) {
    warn$1 = _warn;
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;

    {
      // inputs with type="file" are read only and setting the input's
      // value will throw an error.
      if (tag === 'input' && type === 'file') {
        warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
      }
    }

    if (el.component) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else if (tag === 'select') {
      genSelect(el, value, modifiers);
    } else if (tag === 'input' && type === 'checkbox') {
      genCheckboxModel(el, value, modifiers);
    } else if (tag === 'input' && type === 'radio') {
      genRadioModel(el, value, modifiers);
    } else if (tag === 'input' || tag === 'textarea') {
      genDefaultModel(el, value, modifiers);
    } else if (!config.isReservedTag(tag)) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else {
      warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
    }

    // ensure runtime directive metadata
    return true;
  }

  function genCheckboxModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
    addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
  }

  function genRadioModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
    addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
  }

  function genSelect(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = " + selectedVal + ";";
    code = code + " " + genAssignmentCode(value, assignment);
    addHandler(el, 'change', code, null, true);
  }

  function genDefaultModel(el, value, modifiers) {
    var type = el.attrsMap.type;

    // warn if v-bind:value conflicts with v-model
    // except for inputs with v-bind:type
    {
      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
      if (value$1 && !typeBinding) {
        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
        warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
      }
    }

    var ref = modifiers || {};
    var lazy = ref.lazy;
    var number = ref.number;
    var trim = ref.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

    var valueExpression = '$event.target.value';
    if (trim) {
      valueExpression = "$event.target.value.trim()";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
      code = "if($event.target.composing)return;" + code;
    }

    addProp(el, 'value', "(" + value + ")");
    addHandler(el, event, code, null, true);
    if (trim || number) {
      addHandler(el, 'blur', '$forceUpdate()');
    }
  }

  /*  */

  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.
  function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      var event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function createOnceHandler$1(event, handler, capture) {
    var _target = target$1; // save current target element in closure
    return function onceHandler() {
      var res = handler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    };
  }

  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
  // implementation and does not fire microtasks in between event propagation, so
  // safe to exclude.
  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

  function add$1(name, handler, capture, passive) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
      var attachedTimestamp = currentFlushTimestamp;
      var original = handler;
      handler = original._wrapper = function (e) {
        if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document) {
          return original.apply(this, arguments);
        }
      };
    }
    target$1.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
  }

  function remove$2(name, handler, capture, _target) {
    (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
  }

  function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
    target$1 = undefined;
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners
  };

  /*  */

  var svgContainer;

  function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (isUndef(props[key])) {
        elm[key] = '';
      }
    }
    for (key in props) {
      cur = props[key];
      // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)
      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) {
          vnode.children.length = 0;
        }
        if (cur === oldProps[key]) {
          continue;
        }
        // #6601 work around Chrome version <= 55 bug where single textNode
        // replaced by innerHTML/textContent retains its parentNode property
        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      }

      if (key === 'value' && elm.tagName !== 'PROGRESS') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur;
        // avoid resetting cursor position when value is the same
        var strCur = isUndef(cur) ? '' : String(cur);
        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
        // IE doesn't support innerHTML for SVG elements
        svgContainer = svgContainer || document.createElement('div');
        svgContainer.innerHTML = "<svg>" + cur + "</svg>";
        var svg = svgContainer.firstChild;
        while (elm.firstChild) {
          elm.removeChild(elm.firstChild);
        }
        while (svg.firstChild) {
          elm.appendChild(svg.firstChild);
        }
      } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecesarry `checked` update.
      cur !== oldProps[key]) {
        // some property updates can throw
        // e.g. `value` on <progress> w/ non-finite value
        try {
          elm[key] = cur;
        } catch (e) {}
      }
    }
  }

  // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue(elm, checkVal) {
    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
  }

  function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
      notInFocus = document.activeElement !== elm;
    } catch (e) {}
    return notInFocus && elm.value !== checkVal;
  }

  function isDirtyWithModifiers(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
      if (modifiers.number) {
        return toNumber(value) !== toNumber(newVal);
      }
      if (modifiers.trim) {
        return value.trim() !== newVal.trim();
      }
    }
    return value !== newVal;
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
  };

  /*  */

  var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res;
  });

  // merge static and dynamic style data on the same vnode
  function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
  }

  // normalize possible array / string values into Object
  function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle);
    }
    return bindingStyle;
  }

  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */
  function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
          extend(res, styleData);
        }
      }
    }

    if (styleData = normalizeStyleData(vnode.data)) {
      extend(res, styleData);
    }

    var parentNode = vnode;
    while (parentNode = parentNode.parent) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }
    return res;
  }

  /*  */

  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function setProp(el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);
      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];

  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
      return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  });

  function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
      return;
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }
    for (name in newStyle) {
      cur = newStyle[name];
      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
  }

  var style = {
    create: updateStyle,
    update: updateStyle
  };

  /*  */

  var whitespaceRE = /\s+/;

  /**
   * Add class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) {
          return el.classList.add(c);
        });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }

  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) {
          return el.classList.remove(c);
        });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }

  /*  */

  function resolveTransition(def$$1) {
    if (!def$$1) {
      return;
    }
    /* istanbul ignore else */
    if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
      var res = {};
      if (def$$1.css !== false) {
        extend(res, autoCssTransition(def$$1.name || 'v'));
      }
      extend(res, def$$1);
      return res;
    } else if (typeof def$$1 === 'string') {
      return autoCssTransition(def$$1);
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: name + "-enter",
      enterToClass: name + "-enter-to",
      enterActiveClass: name + "-enter-active",
      leaveClass: name + "-leave",
      leaveToClass: name + "-leave-to",
      leaveActiveClass: name + "-leave-active"
    };
  });

  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation';

  // Transition property/event sniffing
  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';
  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  }

  // binding to window is necessary to make hot reload work in IE in strict mode
  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
    return fn();
  };

  function nextFrame(fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }

  function whenTransitionEnds(el, expectedType, cb) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) {
      return cb();
    }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function end() {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function onEnd(e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    };
  }

  function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i]);
    }));
  }

  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
  // in a locale-dependent way, using a comma instead of a dot.
  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting
  // as a floor function) causing unexpected behaviors
  function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
  }

  /*  */

  function enter(vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return;
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      context = transitionNode.context;
      transitionNode = transitionNode.parent;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return;
    }

    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

    if (explicitEnterDuration != null) {
      checkDuration(explicitEnterDuration, 'enter', vnode);
    }

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode, 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        removeTransitionClass(el, startClass);
        if (!cb.cancelled) {
          addTransitionClass(el, toClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitEnterDuration)) {
              setTimeout(cb, explicitEnterDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave(vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
      return rm();
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

    if (isDef(explicitLeaveDuration)) {
      checkDuration(explicitLeaveDuration, 'leave', vnode);
    }

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave() {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return;
      }
      // record leaving element
      if (!vnode.data.show && el.parentNode) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled) {
            addTransitionClass(el, leaveToClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitLeaveDuration)) {
                setTimeout(cb, explicitLeaveDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }
      leave && leave(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }

  // only used in dev mode
  function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
      warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
    } else if (isNaN(val)) {
      warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
    }
  }

  function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
  }

  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */
  function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
      return false;
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    } else {
      return (fn._length || fn.length) > 1;
    }
  }

  function _enter(_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1(vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};

  var platformModules = [attrs, klass, events, domProps, style, transition];

  /*  */

  // the directive module should be applied last, after all
  // built-in modules have been applied.
  var modules = platformModules.concat(baseModules);

  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  /* istanbul ignore if */
  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var directive = {
    inserted: function inserted(el, binding, vnode, oldVnode) {
      if (vnode.tag === 'select') {
        // #6903
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, 'postpatch', function () {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          el.addEventListener('change', onCompositionEnd);
          /* istanbul ignore if */
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },

    componentUpdated: function componentUpdated(el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context);
        // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function (o, i) {
          return !looseEqual(o, prevOptions[i]);
        })) {
          // trigger change event if
          // no matching option found for at least one value
          var needReset = el.multiple ? binding.value.some(function (v) {
            return hasNoMatchingOption(v, curOptions);
          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
          if (needReset) {
            trigger(el, 'change');
          }
        }
      }
    }
  };

  function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
      setTimeout(function () {
        actuallySetSelected(el, binding, vm);
      }, 0);
    }
  }

  function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
      return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return;
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function hasNoMatchingOption(value, options) {
    return options.every(function (o) {
      return !looseEqual(o, value);
    });
  }

  function getValue(option) {
    return '_value' in option ? option._value : option.value;
  }

  function onCompositionStart(e) {
    e.target.composing = true;
  }

  function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) {
      return;
    }
    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }

  /*  */

  // recursively search for possible transition defined inside the component root
  function locateNode(vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
  }

  var show = {
    bind: function bind(el, ref, vnode) {
      var value = ref.value;

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },

    update: function update(el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      /* istanbul ignore if */
      if (!value === !oldValue) {
        return;
      }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },

    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };

  var platformDirectives = {
    model: directive,
    show: show
  };

  /*  */

  var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered
  function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children));
    } else {
      return vnode;
    }
  }

  function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data;
  }

  function placeholder(h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      });
    }
  }

  function hasParentTransition(vnode) {
    while (vnode = vnode.parent) {
      if (vnode.data.transition) {
        return true;
      }
    }
  }

  function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
  }

  var isNotTextNode = function isNotTextNode(c) {
    return c.tag || isAsyncPlaceholder(c);
  };

  var isVShowDirective = function isVShowDirective(d) {
    return d.name === 'show';
  };

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render(h) {
      var this$1 = this;

      var children = this.$slots.default;
      if (!children) {
        return;
      }

      // filter out text nodes (possible whitespaces)
      children = children.filter(isNotTextNode);
      /* istanbul ignore if */
      if (!children.length) {
        return;
      }

      // warn multiple elements
      if (children.length > 1) {
        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
      }

      var mode = this.mode;

      // warn invalid mode
      if (mode && mode !== 'in-out' && mode !== 'out-in') {
        warn('invalid <transition> mode: ' + mode, this.$parent);
      }

      var rawChild = children[0];

      // if this is a component root node and the component's
      // parent container node also has transition, skip.
      if (hasParentTransition(this.$vnode)) {
        return rawChild;
      }

      // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive
      var child = getRealChild(rawChild);
      /* istanbul ignore if */
      if (!child) {
        return rawChild;
      }

      if (this._leaving) {
        return placeholder(h, rawChild);
      }

      // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.
      var id = "__transition-" + this._uid + "-";
      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);

      // mark v-show
      // so that the transition module can hand over the control to the directive
      if (child.data.directives && child.data.directives.some(isVShowDirective)) {
        child.data.show = true;
      }

      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild.data.transition = extend({}, data);
        // handle transition mode
        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild);
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild;
          }
          var delayedLeave;
          var performLeave = function performLeave() {
            delayedLeave();
          };
          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) {
            delayedLeave = leave;
          });
        }
      }

      return rawChild;
    }
  };

  /*  */

  var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);

  delete props.mode;

  var TransitionGroup = {
    props: props,

    beforeMount: function beforeMount() {
      var this$1 = this;

      var update = this._update;
      this._update = function (vnode, hydrating) {
        var restoreActiveInstance = setActiveInstance(this$1);
        // force removing pass
        this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
        );
        this$1._vnode = this$1.kept;
        restoreActiveInstance();
        update.call(this$1, vnode, hydrating);
      };
    },

    render: function render(h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
          } else {
            var opts = c.componentOptions;
            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
            warn("<transition-group> children must be keyed: <" + name + ">");
          }
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children);
    },

    updated: function updated() {
      var children = this.prevChildren;
      var moveClass = this.moveClass || (this.name || 'v') + '-move';
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return;
      }

      // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);

      // force reflow to put everything in position
      // assign to this to avoid being removed in tree-shaking
      // $flow-disable-line
      this._reflow = document.body.offsetHeight;

      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
            if (e && e.target !== el) {
              return;
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },

    methods: {
      hasMove: function hasMove(el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false;
        }
        /* istanbul ignore if */
        if (this._hasMove) {
          return this._hasMove;
        }
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) {
            removeClass(clone, cls);
          });
        }
        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return this._hasMove = info.hasTransform;
      }
    }
  };

  function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
  };

  /*  */

  // install platform specific utils
  Vue.config.mustUseProp = mustUseProp;
  Vue.config.isReservedTag = isReservedTag;
  Vue.config.isReservedAttr = isReservedAttr;
  Vue.config.getTagNamespace = getTagNamespace;
  Vue.config.isUnknownElement = isUnknownElement;

  // install platform runtime directives & components
  extend(Vue.options.directives, platformDirectives);
  extend(Vue.options.components, platformComponents);

  // install platform patch function
  Vue.prototype.__patch__ = inBrowser ? patch : noop;

  // public mount method
  Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
  };

  // devtools global hook
  /* istanbul ignore next */
  if (inBrowser) {
    setTimeout(function () {
      if (config.devtools) {
        if (devtools) {
          devtools.emit('init', Vue);
        } else {
          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
        }
      }
      if (config.productionTip !== false && typeof console !== 'undefined') {
        console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
      }
    }, 0);
  }

  /*  */

  var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

  var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
  });

  function parseText(text, delimiters) {
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
      return;
    }
    var tokens = [];
    var rawTokens = [];
    var lastIndex = tagRE.lastIndex = 0;
    var match, index, tokenValue;
    while (match = tagRE.exec(text)) {
      index = match.index;
      // push text token
      if (index > lastIndex) {
        rawTokens.push(tokenValue = text.slice(lastIndex, index));
        tokens.push(JSON.stringify(tokenValue));
      }
      // tag token
      var exp = parseFilters(match[1].trim());
      tokens.push("_s(" + exp + ")");
      rawTokens.push({ '@binding': exp });
      lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
      rawTokens.push(tokenValue = text.slice(lastIndex));
      tokens.push(JSON.stringify(tokenValue));
    }
    return {
      expression: tokens.join('+'),
      tokens: rawTokens
    };
  }

  /*  */

  function transformNode(el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');
    if (staticClass) {
      var res = parseText(staticClass, options.delimiters);
      if (res) {
        warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
      }
    }
    if (staticClass) {
      el.staticClass = JSON.stringify(staticClass);
    }
    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
      el.classBinding = classBinding;
    }
  }

  function genData(el) {
    var data = '';
    if (el.staticClass) {
      data += "staticClass:" + el.staticClass + ",";
    }
    if (el.classBinding) {
      data += "class:" + el.classBinding + ",";
    }
    return data;
  }

  var klass$1 = {
    staticKeys: ['staticClass'],
    transformNode: transformNode,
    genData: genData
  };

  /*  */

  function transformNode$1(el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
      /* istanbul ignore if */
      {
        var res = parseText(staticStyle, options.delimiters);
        if (res) {
          warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
        }
      }
      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }

    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
      el.styleBinding = styleBinding;
    }
  }

  function genData$1(el) {
    var data = '';
    if (el.staticStyle) {
      data += "staticStyle:" + el.staticStyle + ",";
    }
    if (el.styleBinding) {
      data += "style:(" + el.styleBinding + "),";
    }
    return data;
  }

  var style$1 = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode$1,
    genData: genData$1
  };

  /*  */

  var decoder;

  var he = {
    decode: function decode(html) {
      decoder = decoder || document.createElement('div');
      decoder.innerHTML = html;
      return decoder.textContent;
    }
  };

  /*  */

  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

  // Elements that you can, intentionally, leave open
  // (and which close themselves)
  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

  /**
   * Not type-checking this file because it's mostly vendor code.
   */

  // Regular Expressions for parsing tags and attributes
  var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeRegExp.source + "]*";
  var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
  var startTagOpen = new RegExp("^<" + qnameCapture);
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
  var doctype = /^<!DOCTYPE [^>]+>/i;
  // #7298: escape - to avoid being pased as HTML comment when inlined in page
  var comment = /^<!\--/;
  var conditionalComment = /^<!\[/;

  // Special Elements (can contain anything)
  var isPlainTextElement = makeMap('script,style,textarea', true);
  var reCache = {};

  var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t',
    '&#39;': "'"
  };
  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

  // #5992
  var isIgnoreNewlineTag = makeMap('pre,textarea', true);
  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
    return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
  };

  function decodeAttr(value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) {
      return decodingMap[match];
    });
  }

  function parseHTML(html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    while (html) {
      last = html;
      // Make sure we're not in a plaintext content element like script/style
      if (!lastTag || !isPlainTextElement(lastTag)) {
        var textEnd = html.indexOf('<');
        if (textEnd === 0) {
          // Comment:
          if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
              if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
              }
              advance(commentEnd + 3);
              continue;
            }
          }

          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
              advance(conditionalEnd + 2);
              continue;
            }
          }

          // Doctype:
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue;
          }

          // End tag:
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            parseEndTag(endTagMatch[1], curIndex, index);
            continue;
          }

          // Start tag:
          var startTagMatch = parseStartTag();
          if (startTagMatch) {
            handleStartTag(startTagMatch);
            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
              advance(1);
            }
            continue;
          }
        }

        var text = void 0,
            rest = void 0,
            next = void 0;
        if (textEnd >= 0) {
          rest = html.slice(textEnd);
          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);
            if (next < 0) {
              break;
            }
            textEnd += next;
            rest = html.slice(textEnd);
          }
          text = html.substring(0, textEnd);
        }

        if (textEnd < 0) {
          text = html;
        }

        if (text) {
          advance(text.length);
        }

        if (options.chars && text) {
          options.chars(text, index - text.length, index);
        }
      } else {
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
          endTagLength = endTag.length;
          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
          }
          if (options.chars) {
            options.chars(text);
          }
          return '';
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
      }

      if (html === last) {
        options.chars && options.chars(html);
        if (!stack.length && options.warn) {
          options.warn("Mal-formatted tag at end of template: \"" + html + "\"", { start: index + html.length });
        }
        break;
      }
    }

    // Clean up any remaining tags
    parseEndTag();

    function advance(n) {
      index += n;
      html = html.substring(n);
    }

    function parseStartTag() {
      var start = html.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: [],
          start: index
        };
        advance(start[0].length);
        var end, attr;
        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
          attr.start = index;
          advance(attr[0].length);
          attr.end = index;
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          advance(end[0].length);
          match.end = index;
          return match;
        }
      }
    }

    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;

      if (expectHTML) {
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
          parseEndTag(lastTag);
        }
        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
          parseEndTag(tagName);
        }
      }

      var unary = isUnaryTag$$1(tagName) || !!unarySlash;

      var l = match.attrs.length;
      var attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        var value = args[3] || args[4] || args[5] || '';
        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
        attrs[i] = {
          name: args[1],
          value: decodeAttr(value, shouldDecodeNewlines)
        };
        if (options.outputSourceRange) {
          attrs[i].start = args.start + args[0].match(/^\s*/).length;
          attrs[i].end = args.end;
        }
      }

      if (!unary) {
        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
        lastTag = tagName;
      }

      if (options.start) {
        options.start(tagName, attrs, unary, match.start, match.end);
      }
    }

    function parseEndTag(tagName, start, end) {
      var pos, lowerCasedTagName;
      if (start == null) {
        start = index;
      }
      if (end == null) {
        end = index;
      }

      // Find the closest opened tag of the same type
      if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break;
          }
        }
      } else {
        // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if (i > pos || !tagName && options.warn) {
            options.warn("tag <" + stack[i].tag + "> has no matching end tag.", { start: stack[i].start, end: stack[i].end });
          }
          if (options.end) {
            options.end(stack[i].tag, start, end);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (lowerCasedTagName === 'br') {
        if (options.start) {
          options.start(tagName, [], true, start, end);
        }
      } else if (lowerCasedTagName === 'p') {
        if (options.start) {
          options.start(tagName, [], false, start, end);
        }
        if (options.end) {
          options.end(tagName, start, end);
        }
      }
    }
  }

  /*  */

  var onRE = /^@|^v-on:/;
  var dirRE = /^v-|^@|^:/;
  var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;
  var dynamicArgRE = /^\[.*\]$/;

  var argRE = /:(.*)$/;
  var bindRE = /^:|^\.|^v-bind:/;
  var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

  var slotRE = /^v-slot(:|$)|^#/;

  var lineBreakRE = /[\r\n]/;
  var whitespaceRE$1 = /\s+/g;

  var invalidAttributeRE = /[\s"'<>\/=]/;

  var decodeHTMLCached = cached(he.decode);

  var emptySlotScopeToken = "_empty_";

  // configurable state
  var warn$2;
  var delimiters;
  var transforms;
  var preTransforms;
  var postTransforms;
  var platformIsPreTag;
  var platformMustUseProp;
  var platformGetTagNamespace;
  var maybeComponent;

  function createASTElement(tag, attrs, parent) {
    return {
      type: 1,
      tag: tag,
      attrsList: attrs,
      attrsMap: makeAttrsMap(attrs),
      rawAttrsMap: {},
      parent: parent,
      children: []
    };
  }

  /**
   * Convert HTML string to AST.
   */
  function parse(template, options) {
    warn$2 = options.warn || baseWarn;

    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;
    var isReservedTag = options.isReservedTag || no;
    maybeComponent = function maybeComponent(el) {
      return !!el.component || !isReservedTag(el.tag);
    };

    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

    delimiters = options.delimiters;

    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var whitespaceOption = options.whitespace;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;
    var warned = false;

    function warnOnce(msg, range) {
      if (!warned) {
        warned = true;
        warn$2(msg, range);
      }
    }

    function closeElement(element) {
      trimEndingWhitespace(element);
      if (!inVPre && !element.processed) {
        element = processElement(element, options);
      }
      // tree management
      if (!stack.length && element !== root) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          {
            checkRootConstraints(element);
          }
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", { start: element.start });
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else {
          if (element.slotScope) {
            // scoped slot
            // keep it in the children list so that v-else(-if) conditions can
            // find it as the prev node.
            var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
          }
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }

      // final children cleanup
      // filter out scoped slots
      element.children = element.children.filter(function (c) {
        return !c.slotScope;
      });
      // remove trailing whitespace node again
      trimEndingWhitespace(element);

      // check pre state
      if (element.pre) {
        inVPre = false;
      }
      if (platformIsPreTag(element.tag)) {
        inPre = false;
      }
      // apply post-transforms
      for (var i = 0; i < postTransforms.length; i++) {
        postTransforms[i](element, options);
      }
    }

    function trimEndingWhitespace(el) {
      // remove trailing whitespace node
      if (!inPre) {
        var lastNode;
        while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
          el.children.pop();
        }
      }
    }

    function checkRootConstraints(el) {
      if (el.tag === 'slot' || el.tag === 'template') {
        warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', { start: el.start });
      }
      if (el.attrsMap.hasOwnProperty('v-for')) {
        warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
      }
    }

    parseHTML(template, {
      warn: warn$2,
      expectHTML: options.expectHTML,
      isUnaryTag: options.isUnaryTag,
      canBeLeftOpenTag: options.canBeLeftOpenTag,
      shouldDecodeNewlines: options.shouldDecodeNewlines,
      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
      shouldKeepComment: options.comments,
      outputSourceRange: options.outputSourceRange,
      start: function start(tag, attrs, unary, start$1, end) {
        // check namespace.
        // inherit parent ns if there is one
        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

        // handle IE svg bug
        /* istanbul ignore if */
        if (isIE && ns === 'svg') {
          attrs = guardIESVGBug(attrs);
        }

        var element = createASTElement(tag, attrs, currentParent);
        if (ns) {
          element.ns = ns;
        }

        {
          if (options.outputSourceRange) {
            element.start = start$1;
            element.end = end;
            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
              cumulated[attr.name] = attr;
              return cumulated;
            }, {});
          }
          attrs.forEach(function (attr) {
            if (invalidAttributeRE.test(attr.name)) {
              warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
                start: attr.start + attr.name.indexOf("["),
                end: attr.start + attr.name.length
              });
            }
          });
        }

        if (isForbiddenTag(element) && !isServerRendering()) {
          element.forbidden = true;
          warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', { start: element.start });
        }

        // apply pre-transforms
        for (var i = 0; i < preTransforms.length; i++) {
          element = preTransforms[i](element, options) || element;
        }

        if (!inVPre) {
          processPre(element);
          if (element.pre) {
            inVPre = true;
          }
        }
        if (platformIsPreTag(element.tag)) {
          inPre = true;
        }
        if (inVPre) {
          processRawAttrs(element);
        } else if (!element.processed) {
          // structural directives
          processFor(element);
          processIf(element);
          processOnce(element);
        }

        if (!root) {
          root = element;
          {
            checkRootConstraints(root);
          }
        }

        if (!unary) {
          currentParent = element;
          stack.push(element);
        } else {
          closeElement(element);
        }
      },

      end: function end(tag, start, end$1) {
        var element = stack[stack.length - 1];
        // pop stack
        stack.length -= 1;
        currentParent = stack[stack.length - 1];
        if (options.outputSourceRange) {
          element.end = end$1;
        }
        closeElement(element);
      },

      chars: function chars(text, start, end) {
        if (!currentParent) {
          {
            if (text === template) {
              warnOnce('Component template requires a root element, rather than just text.', { start: start });
            } else if (text = text.trim()) {
              warnOnce("text \"" + text + "\" outside root element will be ignored.", { start: start });
            }
          }
          return;
        }
        // IE textarea placeholder bug
        /* istanbul ignore if */
        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
          return;
        }
        var children = currentParent.children;
        if (inPre || text.trim()) {
          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
        } else if (!children.length) {
          // remove the whitespace-only node right after an opening tag
          text = '';
        } else if (whitespaceOption) {
          if (whitespaceOption === 'condense') {
            // in condense mode, remove the whitespace node if it contains
            // line break, otherwise condense to a single space
            text = lineBreakRE.test(text) ? '' : ' ';
          } else {
            text = ' ';
          }
        } else {
          text = preserveWhitespace ? ' ' : '';
        }
        if (text) {
          if (!inPre && whitespaceOption === 'condense') {
            // condense consecutive whitespaces into single space
            text = text.replace(whitespaceRE$1, ' ');
          }
          var res;
          var child;
          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
            child = {
              type: 2,
              expression: res.expression,
              tokens: res.tokens,
              text: text
            };
          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            child = {
              type: 3,
              text: text
            };
          }
          if (child) {
            if (options.outputSourceRange) {
              child.start = start;
              child.end = end;
            }
            children.push(child);
          }
        }
      },
      comment: function comment(text, start, end) {
        // adding anyting as a sibling to the root node is forbidden
        // comments should still be allowed, but ignored
        if (currentParent) {
          var child = {
            type: 3,
            text: text,
            isComment: true
          };
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          currentParent.children.push(child);
        }
      }
    });
    return root;
  }

  function processPre(el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
      el.pre = true;
    }
  }

  function processRawAttrs(el) {
    var list = el.attrsList;
    var len = list.length;
    if (len) {
      var attrs = el.attrs = new Array(len);
      for (var i = 0; i < len; i++) {
        attrs[i] = {
          name: list[i].name,
          value: JSON.stringify(list[i].value)
        };
        if (list[i].start != null) {
          attrs[i].start = list[i].start;
          attrs[i].end = list[i].end;
        }
      }
    } else if (!el.pre) {
      // non root node in pre blocks with no attributes
      el.plain = true;
    }
  }

  function processElement(element, options) {
    processKey(element);

    // determine whether this is a plain element after
    // removing structural attributes
    element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;

    processRef(element);
    processSlotContent(element);
    processSlotOutlet(element);
    processComponent(element);
    for (var i = 0; i < transforms.length; i++) {
      element = transforms[i](element, options) || element;
    }
    processAttrs(element);
    return element;
  }

  function processKey(el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
      {
        if (el.tag === 'template') {
          warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
        }
        if (el.for) {
          var iterator = el.iterator2 || el.iterator1;
          var parent = el.parent;
          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
            warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true /* tip */
            );
          }
        }
      }
      el.key = exp;
    }
  }

  function processRef(el) {
    var ref = getBindingAttr(el, 'ref');
    if (ref) {
      el.ref = ref;
      el.refInFor = checkInFor(el);
    }
  }

  function processFor(el) {
    var exp;
    if (exp = getAndRemoveAttr(el, 'v-for')) {
      var res = parseFor(exp);
      if (res) {
        extend(el, res);
      } else {
        warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
      }
    }
  }

  function parseFor(exp) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      return;
    }
    var res = {};
    res.for = inMatch[2].trim();
    var alias = inMatch[1].trim().replace(stripParensRE, '');
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      res.alias = alias.replace(forIteratorRE, '').trim();
      res.iterator1 = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.iterator2 = iteratorMatch[2].trim();
      }
    } else {
      res.alias = alias;
    }
    return res;
  }

  function processIf(el) {
    var exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
      el.if = exp;
      addIfCondition(el, {
        exp: exp,
        block: el
      });
    } else {
      if (getAndRemoveAttr(el, 'v-else') != null) {
        el.else = true;
      }
      var elseif = getAndRemoveAttr(el, 'v-else-if');
      if (elseif) {
        el.elseif = elseif;
      }
    }
  }

  function processIfConditions(el, parent) {
    var prev = findPrevElement(parent.children);
    if (prev && prev.if) {
      addIfCondition(prev, {
        exp: el.elseif,
        block: el
      });
    } else {
      warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
    }
  }

  function findPrevElement(children) {
    var i = children.length;
    while (i--) {
      if (children[i].type === 1) {
        return children[i];
      } else {
        if (children[i].text !== ' ') {
          warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
        }
        children.pop();
      }
    }
  }

  function addIfCondition(el, condition) {
    if (!el.ifConditions) {
      el.ifConditions = [];
    }
    el.ifConditions.push(condition);
  }

  function processOnce(el) {
    var once$$1 = getAndRemoveAttr(el, 'v-once');
    if (once$$1 != null) {
      el.once = true;
    }
  }

  // handle content being passed to a component as slot,
  // e.g. <template slot="xxx">, <div slot-scope="xxx">
  function processSlotContent(el) {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if (slotScope) {
        warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
      /* istanbul ignore if */
      if (el.attrsMap['v-for']) {
        warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
      }
      el.slotScope = slotScope;
    }

    // slot="xxx"
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (el.tag !== 'template' && !el.slotScope) {
        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
      }
    }

    // 2.6 v-slot syntax
    {
      if (el.tag === 'template') {
        // v-slot on <template>
        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
        if (slotBinding) {
          {
            if (el.slotTarget || el.slotScope) {
              warn$2("Unexpected mixed usage of different slot syntaxes.", el);
            }
            if (el.parent && !maybeComponent(el.parent)) {
              warn$2("<template v-slot> can only appear at the root level inside " + "the receiving the component", el);
            }
          }
          var ref = getSlotName(slotBinding);
          var name = ref.name;
          var dynamic = ref.dynamic;
          el.slotTarget = name;
          el.slotTargetDynamic = dynamic;
          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
        }
      } else {
        // v-slot on component, denotes default slot
        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
        if (slotBinding$1) {
          {
            if (!maybeComponent(el)) {
              warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
            }
            if (el.slotScope || el.slotTarget) {
              warn$2("Unexpected mixed usage of different slot syntaxes.", el);
            }
            if (el.scopedSlots) {
              warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
            }
          }
          // add the component's children to its default slot
          var slots = el.scopedSlots || (el.scopedSlots = {});
          var ref$1 = getSlotName(slotBinding$1);
          var name$1 = ref$1.name;
          var dynamic$1 = ref$1.dynamic;
          var slotContainer = slots[name$1] = createASTElement('template', [], el);
          slotContainer.slotTarget = name$1;
          slotContainer.slotTargetDynamic = dynamic$1;
          slotContainer.children = el.children.filter(function (c) {
            if (!c.slotScope) {
              c.parent = slotContainer;
              return true;
            }
          });
          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
          // remove children as they are returned from scopedSlots now
          el.children = [];
          // mark el non-plain so data gets generated
          el.plain = false;
        }
      }
    }
  }

  function getSlotName(binding) {
    var name = binding.name.replace(slotRE, '');
    if (!name) {
      if (binding.name[0] !== '#') {
        name = 'default';
      } else {
        warn$2("v-slot shorthand syntax requires a slot name.", binding);
      }
    }
    return dynamicArgRE.test(name)
    // dynamic [name]
    ? { name: name.slice(1, -1), dynamic: true
      // static name
    } : { name: "\"" + name + "\"", dynamic: false };
  }

  // handle <slot/> outlets
  function processSlotOutlet(el) {
    if (el.tag === 'slot') {
      el.slotName = getBindingAttr(el, 'name');
      if (el.key) {
        warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
      }
    }
  }

  function processComponent(el) {
    var binding;
    if (binding = getBindingAttr(el, 'is')) {
      el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
      el.inlineTemplate = true;
    }
  }

  function processAttrs(el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
    for (i = 0, l = list.length; i < l; i++) {
      name = rawName = list[i].name;
      value = list[i].value;
      if (dirRE.test(name)) {
        // mark element as dynamic
        el.hasBindings = true;
        // modifiers
        modifiers = parseModifiers(name.replace(dirRE, ''));
        // support .foo shorthand syntax for the .prop modifier
        if (modifiers) {
          name = name.replace(modifierRE, '');
        }
        if (bindRE.test(name)) {
          // v-bind
          name = name.replace(bindRE, '');
          value = parseFilters(value);
          isDynamic = dynamicArgRE.test(name);
          if (isDynamic) {
            name = name.slice(1, -1);
          }
          if (value.trim().length === 0) {
            warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
          }
          if (modifiers) {
            if (modifiers.prop && !isDynamic) {
              name = camelize(name);
              if (name === 'innerHtml') {
                name = 'innerHTML';
              }
            }
            if (modifiers.camel && !isDynamic) {
              name = camelize(name);
            }
            if (modifiers.sync) {
              syncGen = genAssignmentCode(value, "$event");
              if (!isDynamic) {
                addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);
                if (hyphenate(name) !== camelize(name)) {
                  addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
                }
              } else {
                // handler w/ dynamic event name
                addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
                );
              }
            }
          }
          if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
            addProp(el, name, value, list[i], isDynamic);
          } else {
            addAttr(el, name, value, list[i], isDynamic);
          }
        } else if (onRE.test(name)) {
          // v-on
          name = name.replace(onRE, '');
          isDynamic = dynamicArgRE.test(name);
          if (isDynamic) {
            name = name.slice(1, -1);
          }
          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
        } else {
          // normal directives
          name = name.replace(dirRE, '');
          // parse arg
          var argMatch = name.match(argRE);
          var arg = argMatch && argMatch[1];
          isDynamic = false;
          if (arg) {
            name = name.slice(0, -(arg.length + 1));
            if (dynamicArgRE.test(arg)) {
              arg = arg.slice(1, -1);
              isDynamic = true;
            }
          }
          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
          if (name === 'model') {
            checkForAliasModel(el, value);
          }
        }
      } else {
        // literal attribute
        {
          var res = parseText(value, delimiters);
          if (res) {
            warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
          }
        }
        addAttr(el, name, JSON.stringify(value), list[i]);
        // #6887 firefox doesn't update muted state if set via attribute
        // even immediately after element creation
        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, 'true', list[i]);
        }
      }
    }
  }

  function checkInFor(el) {
    var parent = el;
    while (parent) {
      if (parent.for !== undefined) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }

  function parseModifiers(name) {
    var match = name.match(modifierRE);
    if (match) {
      var ret = {};
      match.forEach(function (m) {
        ret[m.slice(1)] = true;
      });
      return ret;
    }
  }

  function makeAttrsMap(attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
      if (map[attrs[i].name] && !isIE && !isEdge) {
        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
      }
      map[attrs[i].name] = attrs[i].value;
    }
    return map;
  }

  // for script (e.g. type="x/template") or style, do not decode content
  function isTextTag(el) {
    return el.tag === 'script' || el.tag === 'style';
  }

  function isForbiddenTag(el) {
    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
  }

  var ieNSBug = /^xmlns:NS\d+/;
  var ieNSPrefix = /^NS\d+:/;

  /* istanbul ignore next */
  function guardIESVGBug(attrs) {
    var res = [];
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];
      if (!ieNSBug.test(attr.name)) {
        attr.name = attr.name.replace(ieNSPrefix, '');
        res.push(attr);
      }
    }
    return res;
  }

  function checkForAliasModel(el, value) {
    var _el = el;
    while (_el) {
      if (_el.for && _el.alias === value) {
        warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
      }
      _el = _el.parent;
    }
  }

  /*  */

  function preTransformNode(el, options) {
    if (el.tag === 'input') {
      var map = el.attrsMap;
      if (!map['v-model']) {
        return;
      }

      var typeBinding;
      if (map[':type'] || map['v-bind:type']) {
        typeBinding = getBindingAttr(el, 'type');
      }
      if (!map.type && !typeBinding && map['v-bind']) {
        typeBinding = "(" + map['v-bind'] + ").type";
      }

      if (typeBinding) {
        var ifCondition = getAndRemoveAttr(el, 'v-if', true);
        var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
        // 1. checkbox
        var branch0 = cloneASTElement(el);
        // process for on the main node
        processFor(branch0);
        addRawAttr(branch0, 'type', 'checkbox');
        processElement(branch0, options);
        branch0.processed = true; // prevent it from double-processed
        branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
        addIfCondition(branch0, {
          exp: branch0.if,
          block: branch0
        });
        // 2. add radio else-if condition
        var branch1 = cloneASTElement(el);
        getAndRemoveAttr(branch1, 'v-for', true);
        addRawAttr(branch1, 'type', 'radio');
        processElement(branch1, options);
        addIfCondition(branch0, {
          exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
          block: branch1
        });
        // 3. other
        var branch2 = cloneASTElement(el);
        getAndRemoveAttr(branch2, 'v-for', true);
        addRawAttr(branch2, ':type', typeBinding);
        processElement(branch2, options);
        addIfCondition(branch0, {
          exp: ifCondition,
          block: branch2
        });

        if (hasElse) {
          branch0.else = true;
        } else if (elseIfCondition) {
          branch0.elseif = elseIfCondition;
        }

        return branch0;
      }
    }
  }

  function cloneASTElement(el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent);
  }

  var model$1 = {
    preTransformNode: preTransformNode
  };

  var modules$1 = [klass$1, style$1, model$1];

  /*  */

  function text(el, dir) {
    if (dir.value) {
      addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
    }
  }

  /*  */

  function html(el, dir) {
    if (dir.value) {
      addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
    }
  }

  var directives$1 = {
    model: model,
    text: text,
    html: html
  };

  /*  */

  var baseOptions = {
    expectHTML: true,
    modules: modules$1,
    directives: directives$1,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys(modules$1)
  };

  /*  */

  var isStaticKey;
  var isPlatformReservedTag;

  var genStaticKeysCached = cached(genStaticKeys$1);

  /**
   * Goal of the optimizer: walk the generated template AST tree
   * and detect sub-trees that are purely static, i.e. parts of
   * the DOM that never needs to change.
   *
   * Once we detect these sub-trees, we can:
   *
   * 1. Hoist them into constants, so that we no longer need to
   *    create fresh nodes for them on each re-render;
   * 2. Completely skip them in the patching process.
   */
  function optimize(root, options) {
    if (!root) {
      return;
    }
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic$1(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
  }

  function genStaticKeys$1(keys) {
    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
  }

  function markStatic$1(node) {
    node.static = isStatic(node);
    if (node.type === 1) {
      // do not make component slot content static. this avoids
      // 1. components not able to mutate slot nodes
      // 2. static slot content fails for hot-reloading
      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
        return;
      }
      for (var i = 0, l = node.children.length; i < l; i++) {
        var child = node.children[i];
        markStatic$1(child);
        if (!child.static) {
          node.static = false;
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          var block = node.ifConditions[i$1].block;
          markStatic$1(block);
          if (!block.static) {
            node.static = false;
          }
        }
      }
    }
  }

  function markStaticRoots(node, isInFor) {
    if (node.type === 1) {
      if (node.static || node.once) {
        node.staticInFor = isInFor;
      }
      // For a node to qualify as a static root, it should have children that
      // are not just static text. Otherwise the cost of hoisting out will
      // outweigh the benefits and it's better off to just always render it fresh.
      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
        node.staticRoot = true;
        return;
      } else {
        node.staticRoot = false;
      }
      if (node.children) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          markStaticRoots(node.children[i], isInFor || !!node.for);
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          markStaticRoots(node.ifConditions[i$1].block, isInFor);
        }
      }
    }
  }

  function isStatic(node) {
    if (node.type === 2) {
      // expression
      return false;
    }
    if (node.type === 3) {
      // text
      return true;
    }
    return !!(node.pre || !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
  }

  function isDirectChildOfTemplateFor(node) {
    while (node.parent) {
      node = node.parent;
      if (node.tag !== 'template') {
        return false;
      }
      if (node.for) {
        return true;
      }
    }
    return false;
  }

  /*  */

  var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
  var fnInvokeRE = /\([^)]*?\);*$/;
  var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

  // KeyboardEvent.keyCode aliases
  var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    'delete': [8, 46]
  };

  // KeyboardEvent.key aliases
  var keyNames = {
    // #7880: IE11 and Edge use `Esc` for Escape key name.
    esc: ['Esc', 'Escape'],
    tab: 'Tab',
    enter: 'Enter',
    // #9112: IE11 uses `Spacebar` for Space key name.
    space: [' ', 'Spacebar'],
    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
    up: ['Up', 'ArrowUp'],
    left: ['Left', 'ArrowLeft'],
    right: ['Right', 'ArrowRight'],
    down: ['Down', 'ArrowDown'],
    // #9112: IE11 uses `Del` for Delete key name.
    'delete': ['Backspace', 'Delete', 'Del']
  };

  // #4868: modifiers that prevent the execution of the listener
  // need to explicitly return null so that we can determine whether to remove
  // the listener for .once
  var genGuard = function genGuard(condition) {
    return "if(" + condition + ")return null;";
  };

  var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
  };

  function genHandlers(events, isNative) {
    var prefix = isNative ? 'nativeOn:' : 'on:';
    var staticHandlers = "";
    var dynamicHandlers = "";
    for (var name in events) {
      var handlerCode = genHandler(events[name]);
      if (events[name] && events[name].dynamic) {
        dynamicHandlers += name + "," + handlerCode + ",";
      } else {
        staticHandlers += "\"" + name + "\":" + handlerCode + ",";
      }
    }
    staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";
    if (dynamicHandlers) {
      return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
    } else {
      return prefix + staticHandlers;
    }
  }

  function genHandler(handler) {
    if (!handler) {
      return 'function(){}';
    }

    if (Array.isArray(handler)) {
      return "[" + handler.map(function (handler) {
        return genHandler(handler);
      }).join(',') + "]";
    }

    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);
    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

    if (!handler.modifiers) {
      if (isMethodPath || isFunctionExpression) {
        return handler.value;
      }
      return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
    } else {
      var code = '';
      var genModifierCode = '';
      var keys = [];
      for (var key in handler.modifiers) {
        if (modifierCode[key]) {
          genModifierCode += modifierCode[key];
          // left/right
          if (keyCodes[key]) {
            keys.push(key);
          }
        } else if (key === 'exact') {
          var modifiers = handler.modifiers;
          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
            return !modifiers[keyModifier];
          }).map(function (keyModifier) {
            return "$event." + keyModifier + "Key";
          }).join('||'));
        } else {
          keys.push(key);
        }
      }
      if (keys.length) {
        code += genKeyFilter(keys);
      }
      // Make sure modifiers like prevent and stop get executed after key filtering
      if (genModifierCode) {
        code += genModifierCode;
      }
      var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
      return "function($event){" + code + handlerCode + "}";
    }
  }

  function genKeyFilter(keys) {
    return (
      // make sure the key filters only apply to KeyboardEvents
      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
      // key events that do not have keyCode property...
      "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
    );
  }

  function genFilterCode(key) {
    var keyVal = parseInt(key, 10);
    if (keyVal) {
      return "$event.keyCode!==" + keyVal;
    }
    var keyCode = keyCodes[key];
    var keyName = keyNames[key];
    return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
  }

  /*  */

  function on(el, dir) {
    if (dir.modifiers) {
      warn("v-on without argument does not support modifiers.");
    }
    el.wrapListeners = function (code) {
      return "_g(" + code + "," + dir.value + ")";
    };
  }

  /*  */

  function bind$1(el, dir) {
    el.wrapData = function (code) {
      return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
    };
  }

  /*  */

  var baseDirectives = {
    on: on,
    bind: bind$1,
    cloak: noop
  };

  /*  */

  var CodegenState = function CodegenState(options) {
    this.options = options;
    this.warn = options.warn || baseWarn;
    this.transforms = pluckModuleFunction(options.modules, 'transformCode');
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
    this.directives = extend(extend({}, baseDirectives), options.directives);
    var isReservedTag = options.isReservedTag || no;
    this.maybeComponent = function (el) {
      return !!el.component || !isReservedTag(el.tag);
    };
    this.onceId = 0;
    this.staticRenderFns = [];
    this.pre = false;
  };

  function generate(ast, options) {
    var state = new CodegenState(options);
    var code = ast ? genElement(ast, state) : '_c("div")';
    return {
      render: "with(this){return " + code + "}",
      staticRenderFns: state.staticRenderFns
    };
  }

  function genElement(el, state) {
    if (el.parent) {
      el.pre = el.pre || el.parent.pre;
    }

    if (el.staticRoot && !el.staticProcessed) {
      return genStatic(el, state);
    } else if (el.once && !el.onceProcessed) {
      return genOnce(el, state);
    } else if (el.for && !el.forProcessed) {
      return genFor(el, state);
    } else if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
      return genChildren(el, state) || 'void 0';
    } else if (el.tag === 'slot') {
      return genSlot(el, state);
    } else {
      // component or element
      var code;
      if (el.component) {
        code = genComponent(el.component, el, state);
      } else {
        var data;
        if (!el.plain || el.pre && state.maybeComponent(el)) {
          data = genData$2(el, state);
        }

        var children = el.inlineTemplate ? null : genChildren(el, state, true);
        code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
      }
      // module transforms
      for (var i = 0; i < state.transforms.length; i++) {
        code = state.transforms[i](el, code);
      }
      return code;
    }
  }

  // hoist static sub-trees out
  function genStatic(el, state) {
    el.staticProcessed = true;
    // Some elements (templates) need to behave differently inside of a v-pre
    // node.  All pre nodes are static roots, so we can use this as a location to
    // wrap a state change and reset it upon exiting the pre node.
    var originalPreState = state.pre;
    if (el.pre) {
      state.pre = el.pre;
    }
    state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
    state.pre = originalPreState;
    return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
  }

  // v-once
  function genOnce(el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.staticInFor) {
      var key = '';
      var parent = el.parent;
      while (parent) {
        if (parent.for) {
          key = parent.key;
          break;
        }
        parent = parent.parent;
      }
      if (!key) {
        state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
        return genElement(el, state);
      }
      return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
    } else {
      return genStatic(el, state);
    }
  }

  function genIf(el, state, altGen, altEmpty) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
  }

  function genIfConditions(conditions, state, altGen, altEmpty) {
    if (!conditions.length) {
      return altEmpty || '_e()';
    }

    var condition = conditions.shift();
    if (condition.exp) {
      return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
    } else {
      return "" + genTernaryExp(condition.block);
    }

    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp(el) {
      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
    }
  }

  function genFor(el, state, altGen, altHelper) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

    if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
      state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true /* tip */
      );
    }

    el.forProcessed = true; // avoid recursion
    return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
  }

  function genData$2(el, state) {
    var data = '{';

    // directives first.
    // directives may mutate the el's other properties before they are generated.
    var dirs = genDirectives(el, state);
    if (dirs) {
      data += dirs + ',';
    }

    // key
    if (el.key) {
      data += "key:" + el.key + ",";
    }
    // ref
    if (el.ref) {
      data += "ref:" + el.ref + ",";
    }
    if (el.refInFor) {
      data += "refInFor:true,";
    }
    // pre
    if (el.pre) {
      data += "pre:true,";
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
      data += "tag:\"" + el.tag + "\",";
    }
    // module data generation functions
    for (var i = 0; i < state.dataGenFns.length; i++) {
      data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
      data += "attrs:" + genProps(el.attrs) + ",";
    }
    // DOM props
    if (el.props) {
      data += "domProps:" + genProps(el.props) + ",";
    }
    // event handlers
    if (el.events) {
      data += genHandlers(el.events, false) + ",";
    }
    if (el.nativeEvents) {
      data += genHandlers(el.nativeEvents, true) + ",";
    }
    // slot target
    // only for non-scoped slots
    if (el.slotTarget && !el.slotScope) {
      data += "slot:" + el.slotTarget + ",";
    }
    // scoped slots
    if (el.scopedSlots) {
      data += genScopedSlots(el, el.scopedSlots, state) + ",";
    }
    // component v-model
    if (el.model) {
      data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
    }
    // inline-template
    if (el.inlineTemplate) {
      var inlineTemplate = genInlineTemplate(el, state);
      if (inlineTemplate) {
        data += inlineTemplate + ",";
      }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind dynamic argument wrap
    // v-bind with dynamic arguments must be applied using the same v-bind object
    // merge helper so that class/style/mustUseProp attrs are handled correctly.
    if (el.dynamicAttrs) {
      data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
    }
    // v-bind data wrap
    if (el.wrapData) {
      data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
      data = el.wrapListeners(data);
    }
    return data;
  }

  function genDirectives(el, state) {
    var dirs = el.directives;
    if (!dirs) {
      return;
    }
    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
      dir = dirs[i];
      needRuntime = true;
      var gen = state.directives[dir.name];
      if (gen) {
        // compile-time directive that manipulates AST.
        // returns true if it also needs a runtime counterpart.
        needRuntime = !!gen(el, dir, state.warn);
      }
      if (needRuntime) {
        hasRuntime = true;
        res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
      }
    }
    if (hasRuntime) {
      return res.slice(0, -1) + ']';
    }
  }

  function genInlineTemplate(el, state) {
    var ast = el.children[0];
    if (el.children.length !== 1 || ast.type !== 1) {
      state.warn('Inline-template components must have exactly one child element.', { start: el.start });
    }
    if (ast && ast.type === 1) {
      var inlineRenderFns = generate(ast, state.options);
      return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
        return "function(){" + code + "}";
      }).join(',') + "]}";
    }
  }

  function genScopedSlots(el, slots, state) {
    // by default scoped slots are considered "stable", this allows child
    // components with only scoped slots to skip forced updates from parent.
    // but in some cases we have to bail-out of this optimization
    // for example if the slot contains dynamic names, has v-if or v-for on them...
    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
      var slot = slots[key];
      return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
      ;
    });

    // #9534: if a component with scoped slots is inside a conditional branch,
    // it's possible for the same component to be reused but with different
    // compiled slot content. To avoid that, we generate a unique key based on
    // the generated code of all the slot contents.
    var needsKey = !!el.if;

    // OR when it is inside another scoped slot or v-for (the reactivity may be
    // disconnected due to the intermediate scope variable)
    // #9438, #9506
    // TODO: this can be further optimized by properly analyzing in-scope bindings
    // and skip force updating ones that do not actually use scope variables.
    if (!needsForceUpdate) {
      var parent = el.parent;
      while (parent) {
        if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {
          needsForceUpdate = true;
          break;
        }
        if (parent.if) {
          needsKey = true;
        }
        parent = parent.parent;
      }
    }

    var generatedSlots = Object.keys(slots).map(function (key) {
      return genScopedSlot(slots[key], state);
    }).join(',');

    return "scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? ",null,false," + hash(generatedSlots) : "") + ")";
  }

  function hash(str) {
    var hash = 5381;
    var i = str.length;
    while (i) {
      hash = hash * 33 ^ str.charCodeAt(--i);
    }
    return hash >>> 0;
  }

  function containsSlotChild(el) {
    if (el.type === 1) {
      if (el.tag === 'slot') {
        return true;
      }
      return el.children.some(containsSlotChild);
    }
    return false;
  }

  function genScopedSlot(el, state) {
    var isLegacySyntax = el.attrsMap['slot-scope'];
    if (el.if && !el.ifProcessed && !isLegacySyntax) {
      return genIf(el, state, genScopedSlot, "null");
    }
    if (el.for && !el.forProcessed) {
      return genFor(el, state, genScopedSlot);
    }
    var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
    var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}";
    // reverse proxy v-slot without scope on this.$slots
    var reverseProxy = slotScope ? "" : ",proxy:true";
    return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
  }

  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
    var children = el.children;
    if (children.length) {
      var el$1 = children[0];
      // optimize single v-for
      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
        var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
        return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
      }
      var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
      var gen = altGenNode || genNode;
      return "[" + children.map(function (c) {
        return gen(c, state);
      }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
    }
  }

  // determine the normalization needed for the children array.
  // 0: no normalization needed
  // 1: simple normalization needed (possible 1-level deep nested array)
  // 2: full normalization needed
  function getNormalizationType(children, maybeComponent) {
    var res = 0;
    for (var i = 0; i < children.length; i++) {
      var el = children[i];
      if (el.type !== 1) {
        continue;
      }
      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return needsNormalization(c.block);
      })) {
        res = 2;
        break;
      }
      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return maybeComponent(c.block);
      })) {
        res = 1;
      }
    }
    return res;
  }

  function needsNormalization(el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
  }

  function genNode(node, state) {
    if (node.type === 1) {
      return genElement(node, state);
    } else if (node.type === 3 && node.isComment) {
      return genComment(node);
    } else {
      return genText(node);
    }
  }

  function genText(text) {
    return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
  }

  function genComment(comment) {
    return "_e(" + JSON.stringify(comment.text) + ")";
  }

  function genSlot(el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(" + slotName + (children ? "," + children : '');
    var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
      return {
        // slot props are camelized
        name: camelize(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      };
    })) : null;
    var bind$$1 = el.attrsMap['v-bind'];
    if ((attrs || bind$$1) && !children) {
      res += ",null";
    }
    if (attrs) {
      res += "," + attrs;
    }
    if (bind$$1) {
      res += (attrs ? '' : ',null') + "," + bind$$1;
    }
    return res + ')';
  }

  // componentName is el.component, take it as argument to shun flow's pessimistic refinement
  function genComponent(componentName, el, state) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
  }

  function genProps(props) {
    var staticProps = "";
    var dynamicProps = "";
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var value = transformSpecialNewlines(prop.value);
      if (prop.dynamic) {
        dynamicProps += prop.name + "," + value + ",";
      } else {
        staticProps += "\"" + prop.name + "\":" + value + ",";
      }
    }
    staticProps = "{" + staticProps.slice(0, -1) + "}";
    if (dynamicProps) {
      return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
    } else {
      return staticProps;
    }
  }

  // #3895, #4268
  function transformSpecialNewlines(text) {
    return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
  }

  /*  */

  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

  // these unary operators should not be used as property/method names
  var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

  // strip strings in expressions
  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

  // detect problematic expressions in a template
  function detectErrors(ast, warn) {
    if (ast) {
      checkNode(ast, warn);
    }
  }

  function checkNode(node, warn) {
    if (node.type === 1) {
      for (var name in node.attrsMap) {
        if (dirRE.test(name)) {
          var value = node.attrsMap[name];
          if (value) {
            var range = node.rawAttrsMap[name];
            if (name === 'v-for') {
              checkFor(node, "v-for=\"" + value + "\"", warn, range);
            } else if (onRE.test(name)) {
              checkEvent(value, name + "=\"" + value + "\"", warn, range);
            } else {
              checkExpression(value, name + "=\"" + value + "\"", warn, range);
            }
          }
        }
      }
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          checkNode(node.children[i], warn);
        }
      }
    } else if (node.type === 2) {
      checkExpression(node.expression, node.text, warn, node);
    }
  }

  function checkEvent(exp, text, warn, range) {
    var stipped = exp.replace(stripStringRE, '');
    var keywordMatch = stipped.match(unaryOperatorsRE);
    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
      warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
    }
    checkExpression(exp, text, warn, range);
  }

  function checkFor(node, text, warn, range) {
    checkExpression(node.for || '', text, warn, range);
    checkIdentifier(node.alias, 'v-for alias', text, warn, range);
    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
  }

  function checkIdentifier(ident, type, text, warn, range) {
    if (typeof ident === 'string') {
      try {
        new Function("var " + ident + "=_");
      } catch (e) {
        warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
      }
    }
  }

  function checkExpression(exp, text, warn, range) {
    try {
      new Function("return " + exp);
    } catch (e) {
      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
      if (keywordMatch) {
        warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
      } else {
        warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
      }
    }
  }

  /*  */

  var range = 2;

  function generateCodeFrame(source, start, end) {
    if (start === void 0) start = 0;
    if (end === void 0) end = source.length;

    var lines = source.split(/\r?\n/);
    var count = 0;
    var res = [];
    for (var i = 0; i < lines.length; i++) {
      count += lines[i].length + 1;
      if (count >= start) {
        for (var j = i - range; j <= i + range || end > count; j++) {
          if (j < 0 || j >= lines.length) {
            continue;
          }
          res.push("" + (j + 1) + repeat$1(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
          var lineLength = lines[j].length;
          if (j === i) {
            // push underline
            var pad = start - (count - lineLength) + 1;
            var length = end > count ? lineLength - pad : end - start;
            res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
          } else if (j > i) {
            if (end > count) {
              var length$1 = Math.min(end - count, lineLength);
              res.push("   |  " + repeat$1("^", length$1));
            }
            count += lineLength + 1;
          }
        }
        break;
      }
    }
    return res.join('\n');
  }

  function repeat$1(str, n) {
    var result = '';
    if (n > 0) {
      while (true) {
        // eslint-disable-line
        if (n & 1) {
          result += str;
        }
        n >>>= 1;
        if (n <= 0) {
          break;
        }
        str += str;
      }
    }
    return result;
  }

  /*  */

  function createFunction(code, errors) {
    try {
      return new Function(code);
    } catch (err) {
      errors.push({ err: err, code: code });
      return noop;
    }
  }

  function createCompileToFunctionFn(compile) {
    var cache = Object.create(null);

    return function compileToFunctions(template, options, vm) {
      options = extend({}, options);
      var warn$$1 = options.warn || warn;
      delete options.warn;

      /* istanbul ignore if */
      {
        // detect possible CSP restriction
        try {
          new Function('return 1');
        } catch (e) {
          if (e.toString().match(/unsafe-eval|CSP/)) {
            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
          }
        }
      }

      // check cache
      var key = options.delimiters ? String(options.delimiters) + template : template;
      if (cache[key]) {
        return cache[key];
      }

      // compile
      var compiled = compile(template, options);

      // check compilation errors/tips
      {
        if (compiled.errors && compiled.errors.length) {
          if (options.outputSourceRange) {
            compiled.errors.forEach(function (e) {
              warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
            });
          } else {
            warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
              return "- " + e;
            }).join('\n') + '\n', vm);
          }
        }
        if (compiled.tips && compiled.tips.length) {
          if (options.outputSourceRange) {
            compiled.tips.forEach(function (e) {
              return tip(e.msg, vm);
            });
          } else {
            compiled.tips.forEach(function (msg) {
              return tip(msg, vm);
            });
          }
        }
      }

      // turn code into functions
      var res = {};
      var fnGenErrors = [];
      res.render = createFunction(compiled.render, fnGenErrors);
      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors);
      });

      // check function generation errors.
      // this should only happen if there is a bug in the compiler itself.
      // mostly for codegen development use
      /* istanbul ignore if */
      {
        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
          warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return err.toString() + " in\n\n" + code + "\n";
          }).join('\n'), vm);
        }
      }

      return cache[key] = res;
    };
  }

  /*  */

  function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
      function compile(template, options) {
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];

        var warn = function warn(msg, range, tip) {
          (tip ? tips : errors).push(msg);
        };

        if (options) {
          if (options.outputSourceRange) {
            // $flow-disable-line
            var leadingSpaceLength = template.match(/^\s*/)[0].length;

            warn = function warn(msg, range, tip) {
              var data = { msg: msg };
              if (range) {
                if (range.start != null) {
                  data.start = range.start + leadingSpaceLength;
                }
                if (range.end != null) {
                  data.end = range.end + leadingSpaceLength;
                }
              }
              (tip ? tips : errors).push(data);
            };
          }
          // merge custom modules
          if (options.modules) {
            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
          }
          // merge custom directives
          if (options.directives) {
            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
          }
          // copy other options
          for (var key in options) {
            if (key !== 'modules' && key !== 'directives') {
              finalOptions[key] = options[key];
            }
          }
        }

        finalOptions.warn = warn;

        var compiled = baseCompile(template.trim(), finalOptions);
        {
          detectErrors(compiled.ast, warn);
        }
        compiled.errors = errors;
        compiled.tips = tips;
        return compiled;
      }

      return {
        compile: compile,
        compileToFunctions: createCompileToFunctionFn(compile)
      };
    };
  }

  /*  */

  // `createCompilerCreator` allows creating compilers that use alternative
  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
  // Here we just export a default compiler using the default parts.
  var createCompiler = createCompilerCreator(function baseCompile(template, options) {
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
      optimize(ast, options);
    }
    var code = generate(ast, options);
    return {
      ast: ast,
      render: code.render,
      staticRenderFns: code.staticRenderFns
    };
  });

  /*  */

  var ref$1 = createCompiler(baseOptions);
  var compile = ref$1.compile;
  var compileToFunctions = ref$1.compileToFunctions;

  /*  */

  // check whether current browser encodes a char inside attribute values
  var div;
  function getShouldDecode(href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
    return div.innerHTML.indexOf('&#10;') > 0;
  }

  // #3663: IE encodes newlines inside attribute values while other browsers don't
  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
  // #6828: chrome encodes content in a[href]
  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

  /*  */

  var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML;
  });

  var mount = Vue.prototype.$mount;
  Vue.prototype.$mount = function (el, hydrating) {
    el = el && query(el);

    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
      warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
      return this;
    }

    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
      var template = options.template;
      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */
            if (!template) {
              warn("Template element not found or is empty: " + options.template, this);
            }
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          {
            warn('invalid template option:' + template, this);
          }
          return this;
        }
      } else if (el) {
        template = getOuterHTML(el);
      }
      if (template) {
        /* istanbul ignore if */
        if (config.performance && mark) {
          mark('compile');
        }

        var ref = compileToFunctions(template, {
          outputSourceRange: "development" !== 'production',
          shouldDecodeNewlines: shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;

        /* istanbul ignore if */
        if (config.performance && mark) {
          mark('compile end');
          measure("vue " + this._name + " compile", 'compile', 'compile end');
        }
      }
    }
    return mount.call(this, el, hydrating);
  };

  /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   */
  function getOuterHTML(el) {
    if (el.outerHTML) {
      return el.outerHTML;
    } else {
      var container = document.createElement('div');
      container.appendChild(el.cloneNode(true));
      return container.innerHTML;
    }
  }

  Vue.compile = compileToFunctions;

  return Vue;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmNcXHNjcmlwdHNcXG1haW4tdnVlLmpzIiwic3JjXFxzY3JpcHRzXFxtYWluLmpzIiwic3JjXFxzY3JpcHRzXFxzY3JvbGwtcmV2ZWFsLmpzIiwic3JjXFxzY3JpcHRzXFx2ZW5kb3JcXHBvbHlmaWxscy5qcyIsInNyY1xcc2NyaXB0c1xcdmVuZG9yXFxzY3JvbGxyZXZlYWwuanMiLCJzcmNcXHNjcmlwdHNcXHZlbmRvclxcc210cC5qcyIsInNyY1xcc2NyaXB0c1xcdmVuZG9yXFxzcmNcXHNjcmlwdHNcXHZlbmRvclxcdnVlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O2tCQ0dlLFlBQVc7QUFDekIsbUJBQVE7QUFDUCxNQUFJLE1BREc7QUFFUCxjQUFZLENBQUMsSUFBRCxFQUFPLEdBQVAsQ0FGTDtBQUdQLFFBQU07QUFDTCxxQkFBa0IsQ0FEYjtBQUVMLG9CQUFpQixDQUZaO0FBR0wsaUJBQWMsSUFIVDtBQUlMLHVCQUFvQixVQUpmO0FBS0wsZ0JBQWEsRUFMUjtBQU1MLGlCQUFjLEVBTlQ7QUFPTCxtQkFBZ0IsRUFQWDtBQVFMLG1CQUFnQixFQVJYO0FBU0wsd0JBQXFCLEVBVGhCO0FBVUwsaUJBQWMsRUFWVDtBQVdMLGdCQUFhLEtBWFI7QUFZTCxtQkFBZ0IsTUFaWDtBQWFMLGlCQUFjLEVBYlQ7QUFjTCxzQkFBbUIsQ0FkZDtBQWVMLGtCQUFlLEtBZlY7QUFnQkwsd0JBQXFCLENBaEJoQjtBQWlCTCx3QkFBcUIsQ0FqQmhCO0FBa0JMLFNBQU07QUFsQkQsR0FIQztBQXVCUCxXQUFTLG1CQUFXO0FBQ25CLFFBQUssSUFBTCxHQUFZLElBQUksSUFBSixHQUFXLFdBQVgsRUFBWjtBQUNBLFFBQUssZUFBTCxHQUF1QixTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsRUFBZ0MsaUJBQWhDLEdBQW9ELENBQTNFO0FBQ0EsUUFBSyxjQUFMOztBQUVBLE9BQUksTUFB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QUksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQSxnQkFBVSxXQUFWLENBQXNCLEdBQUcsU0FBSCxDQUFhLElBQWIsQ0FBdEI7QUFDQSxhQUFPLFVBQVUsU0FBakI7QUFDRDtBQUNGOztBQUVELE1BQUksT0FBSixHQUFjLGtCQUFkOztBQUVBLFNBQU8sR0FBUDtBQUVELENBaHBYQSxDQUFEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCBWdWUgZnJvbSAnLi92ZW5kb3IvdnVlJztcbmltcG9ydCB7ZW1haWxTZW5kLCBlbWFpbEFqYXhQb3N0LCBlbWFpbEFqYXgsIGVtYWlsQ3JlYXRlQ09SU1JlcXVlc3R9IGZyb20gJy4vdmVuZG9yL3NtdHAnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblx0bmV3IFZ1ZSh7XG5cdFx0ZWw6ICcjYXBwJyxcblx0XHRkZWxpbWl0ZXJzOiBbJyR7JywgJ30nXSxcblx0XHRkYXRhOiB7XG5cdFx0XHRoZXJvQ3VycmVudFNsaWRlOiAxLFxuXHRcdFx0aGVyb1RvdGFsU2xpZGVzOiAwLFxuXHRcdFx0aGVyb0ludGVydmFsOiBudWxsLFxuXHRcdFx0aGVyb1NsaWRlRGlyZWN0aW9uOiAnc2xpZGUtdXAnLFxuXHRcdFx0Y29udGFjdE5hbWU6ICcnLFxuXHRcdFx0Y29udGFjdEVtYWlsOiAnJyxcblx0XHRcdGNvbnRhY3RTdWJqZWN0OiAnJyxcblx0XHRcdGNvbnRhY3RNZXNzYWdlOiAnJyxcblx0XHRcdGNvbnRhY3RDb25maXJtYXRpb246ICcnLFxuXHRcdFx0Y29udGFjdEVycm9yOiAnJyxcblx0XHRcdHNjcm9sbFRvVG9wOiBmYWxzZSxcblx0XHRcdGN1cnJlbnRTZWN0aW9uOiAnaGVybycsXG5cdFx0XHR0YXR0b29BbGJ1bXM6IFtdLFxuXHRcdFx0YWN0aXZlVGF0dG9vQWxidW06IDAsXG5cdFx0XHR0YXR0b29PdmVybGF5OiBmYWxzZSxcblx0XHRcdGFjdGl2ZVRhdHRvb1BpY3R1cmU6IDAsXG5cdFx0XHRzdGFnZ2VyVGF0dG9vQWxidW1zOiAwLFxuXHRcdFx0eWVhcjogMjAyMFxuXHRcdH0sXG5cdFx0bW91bnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHR0aGlzLmhlcm9Ub3RhbFNsaWRlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5oZXJvJykuY2hpbGRFbGVtZW50Q291bnQgLSAyO1xuXHRcdFx0dGhpcy5pbml0SGVyb1NsaWRlcigpO1xuXG5cdFx0XHRsZXQgYXBwID0gdGhpcztcblxuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhcHAuZ2V0Q3VycmVudE1lbnVMaW5rKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gRmFjZWJvb2sgQVBJXG5cblx0XHRcdHdpbmRvdy5mYkFzeW5jSW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRGQi5pbml0KHtcblx0XHRcdFx0XHRhcHBJZDogJzE3MDA4MDYzMTM1NDA5NTcnLFxuXHRcdFx0XHRcdHhmYm1sOiB0cnVlLFxuXHRcdFx0XHRcdHZlcnNpb246ICd2My4yJ1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRGQi5hcGkoXG5cdFx0XHRcdFx0Jy9pbmtkZXBlbmRlbnR0YXR0b29zP2ZpZWxkcz1hbGJ1bXMubGltaXQoNTApe25hbWUsY291bnQsY292ZXJfcGhvdG97c291cmNlfSwgcGhvdG9ze3NvdXJjZX19JmFjY2Vzc190b2tlbj0xNzAwODA2MzEzNTQwOTU3fHpGWmNQQ3o5ZXN5QzFzdTU3TW51RHNMdFJ3ZycsXG5cdFx0XHRcdFx0ZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdGxldCBhbGJ1bXMgPSByZXNwb25zZS5hbGJ1bXMuZGF0YTtcblx0XHRcdFx0XHRcdGFsYnVtcy5mb3JFYWNoKGZ1bmN0aW9uKGFsYnVtKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhbGJ1bS5pZCA9PT0gJzEwMTYxMjg0NzU3MTc1NTgyJykge1xuXHRcdFx0XHRcdFx0XHRcdC8vIE1hcmNpbiAyMDE5XG5cdFx0XHRcdFx0XHRcdFx0YWxidW0ubmFtZSA9ICdNYXJjaW4nO1xuXHRcdFx0XHRcdFx0XHRcdGFsYnVtLm9yZGVyID0gMDtcblx0XHRcdFx0XHRcdFx0XHRhcHAudGF0dG9vQWxidW1zLnB1c2goYWxidW0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGFsYnVtLmlkID09PSAnMTAxNjAwMzMzNjE1MDU1ODInKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gTWFyZWsgMjAxOFxuXHRcdFx0XHRcdFx0XHRcdGFsYnVtLm5hbWUgPSAnTWFyZWsnO1xuXHRcdFx0XHRcdFx0XHRcdGFsYnVtLm9yZGVyID0gMTtcblx0XHRcdFx0XHRcdFx0XHRhcHAudGF0dG9vQWxidW1zLnB1c2goYWxidW0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGFsYnVtLmlkID09PSAnMTAxNTM1NTYwNzE2MjU1ODInKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGFuaWVsXG5cblx0XHRcdFx0XHRcdFx0XHRhbGJ1bS5vcmRlciA9IDI7XG5cdFx0XHRcdFx0XHRcdFx0YXBwLnRhdHRvb0FsYnVtcy5wdXNoKGFsYnVtKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChhbGJ1bS5pZCA9PT0gJzEwMTU2NTM5ODgwMzI1NTgyJykge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFdvanRla1xuXG5cdFx0XHRcdFx0XHRcdFx0YWxidW0ub3JkZXIgPSAzO1xuXHRcdFx0XHRcdFx0XHRcdGFwcC50YXR0b29BbGJ1bXMucHVzaChhbGJ1bSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoYWxidW0uaWQgPT09ICcxMDE1OTE0NjI2NTI1NTU4MicpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBHenlcblxuXHRcdFx0XHRcdFx0XHRcdGFsYnVtLm5hbWUgPSAnR3p5IEV4IFNpbGVzaWEnO1xuXHRcdFx0XHRcdFx0XHRcdGFsYnVtLm9yZGVyID0gNDtcblx0XHRcdFx0XHRcdFx0XHRhcHAudGF0dG9vQWxidW1zLnB1c2goYWxidW0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGFsYnVtLmlkID09PSAnMTAxNjA4NDMwMDA3NjA1ODInKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gS2Fyb2xcblxuXHRcdFx0XHRcdFx0XHRcdGFsYnVtLm5hbWUgPSAnS2Fyb2wnO1xuXHRcdFx0XHRcdFx0XHRcdGFsYnVtLm9yZGVyID0gNTtcblx0XHRcdFx0XHRcdFx0XHRhcHAudGF0dG9vQWxidW1zLnB1c2goYWxidW0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGFsYnVtLmlkID09PSAnMTAxNjA1NDM2MTU0OTA1ODInKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gU29maWFcblxuXHRcdFx0XHRcdFx0XHRcdGFsYnVtLm5hbWUgPSAnU29maWEnO1xuXHRcdFx0XHRcdFx0XHRcdGFsYnVtLm9yZGVyID0gNjtcblx0XHRcdFx0XHRcdFx0XHRhcHAudGF0dG9vQWxidW1zLnB1c2goYWxidW0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKGFsYnVtLmlkID09PSAnMTAxNTg0NjgyNTY4NjU1ODInKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQXNoXG5cblx0XHRcdFx0XHRcdFx0XHRhbGJ1bS5uYW1lID0gJ0FzaCc7XG5cdFx0XHRcdFx0XHRcdFx0YWxidW0ub3JkZXIgPSA3O1xuXHRcdFx0XHRcdFx0XHRcdGFwcC50YXR0b29BbGJ1bXMucHVzaChhbGJ1bSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0YXBwLnRhdHRvb0FsYnVtcy5zb3J0KChhLCBiKSA9PiAoYS5vcmRlciA+IGIub3JkZXIpID8gMSA6IC0xKTtcblxuXHRcdFx0XHRcdFx0c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhcHAuc3RhZ2dlclRhdHRvb0FsYnVtcyA8IGFwcC50YXR0b29BbGJ1bXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0YXBwLnN0YWdnZXJUYXR0b29BbGJ1bXMrKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgNTAwKTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH07XG5cdFx0fSxcblx0XHRtZXRob2RzOiB7XG5cdFx0XHRpbml0SGVyb1NsaWRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxldCBhcHAgPSB0aGlzO1xuXHRcdFx0XHRjbGVhckludGVydmFsKGFwcC5oZXJvSW50ZXJ2YWwpO1xuXHRcdFx0XHRhcHAuaGVyb0ludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0YXBwLmhlcm9TbGlkZURpcmVjdGlvbiA9ICdzbGlkZS1yaWdodCc7XG5cdFx0XHRcdFx0aWYgKGFwcC5oZXJvQ3VycmVudFNsaWRlID09PSBhcHAuaGVyb1RvdGFsU2xpZGVzKSB7XG5cdFx0XHRcdFx0XHRhcHAuaGVyb0N1cnJlbnRTbGlkZSA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFwcC5oZXJvQ3VycmVudFNsaWRlKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCA4MDAwKTtcblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2VTbGlkZTogZnVuY3Rpb24oc2xpZGUpIHtcblx0XHRcdFx0aWYgKHNsaWRlIDwgdGhpcy5oZXJvQ3VycmVudFNsaWRlKSB7XG5cdFx0XHRcdFx0dGhpcy5oZXJvU2xpZGVEaXJlY3Rpb24gPSAnc2xpZGUtbGVmdCc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5oZXJvU2xpZGVEaXJlY3Rpb24gPSAnc2xpZGUtcmlnaHQnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHNsaWRlID4gdGhpcy5oZXJvVG90YWxTbGlkZXMpIHtcblx0XHRcdFx0XHRzbGlkZSA9IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoc2xpZGUgPT09IDApIHtcblx0XHRcdFx0XHRzbGlkZSA9IHRoaXMuaGVyb1RvdGFsU2xpZGVzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5oZXJvQ3VycmVudFNsaWRlID0gc2xpZGU7XG5cdFx0XHRcdHRoaXMuaW5pdEhlcm9TbGlkZXIoKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRDdXJyZW50TWVudUxpbms6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAod2luZG93LnBhZ2VZT2Zmc2V0ID4gMCkge1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsVG9Ub3AgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2Nyb2xsVG9Ub3AgPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBhcHAgPSB0aGlzO1xuXG5cdFx0XHRcdGNvbnN0IHNlY3Rpb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2VjdGlvbicpO1xuXHRcdFx0XHRsZXQgY3VycmVudFNjcm9sbCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcblxuXHRcdFx0XHRzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlY3Rpb24pIHtcblx0XHRcdFx0XHRsZXQgc2VjdGlvblBvc2l0aW9uID0gc2VjdGlvbi5vZmZzZXRUb3A7XG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRTY3JvbGwgKyAxMDAgPiBzZWN0aW9uUG9zaXRpb24pIHtcblx0XHRcdFx0XHRcdGFwcC5jdXJyZW50U2VjdGlvbiA9IHNlY3Rpb24uZ2V0QXR0cmlidXRlKCdpZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0b3BlblRhdHRvb0FsYnVtOiBmdW5jdGlvbihhbGJ1bSkge1xuXHRcdFx0XHR0aGlzLmFjdGl2ZVRhdHRvb0FsYnVtID0gYWxidW07XG5cdFx0XHRcdHRoaXMudGF0dG9vT3ZlcmxheSA9IHRydWU7XG5cdFx0XHRcdHRoaXMuYWN0aXZlVGF0dG9vUGljdHVyZSA9IDA7XG5cdFx0XHR9LFxuXHRcdFx0Y2xvc2VUYXR0b29BbGJ1bTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudGF0dG9vT3ZlcmxheSA9IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdGNoYW5nZVRhdHRvb1BpY3R1cmU6IGZ1bmN0aW9uKHBpY3R1cmUpIHtcblx0XHRcdFx0dGhpcy50YXR0b29PdmVybGF5ID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5hY3RpdmVUYXR0b29QaWN0dXJlID0gcGljdHVyZTtcblx0XHRcdH0sXG5cdFx0XHRzZW5kRW1haWw6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0aWYgKHRoaXMuY29udGFjdEVtYWlsICE9PSAnJyAmJiB0aGlzLmNvbnRhY3RTdWJqZWN0ICE9PSAnJyAmJiB0aGlzLmNvbnRhY3RNZXNzYWdlICE9PSAnJyAmJiB0aGlzLmNvbnRhY3ROYW1lICE9ICcnKSB7XG5cdFx0XHRcdFx0ZW1haWxTZW5kKHtcblx0XHRcdFx0XHRcdEhvc3QgOiAnc210cC5lbGFzdGljZW1haWwuY29tJyxcblx0XHRcdFx0XHRcdFVzZXJuYW1lIDogJ2tmYWxlbmNpa0BnbWFpbC5jb20nLFxuXHRcdFx0XHRcdFx0UGFzc3dvcmQgOiAnZTZiNmI1MGItNDE1Yi00Y2RmLThkZDYtNzJmNzc0ZWVmOTUyJyxcblx0XHRcdFx0XHRcdFRvIDogJ2tmYWxlbmNpa0BnbWFpbC5jb20nLFxuXHRcdFx0XHRcdFx0RnJvbSA6ICdrZmFsZW5jaWtAZ21haWwuY29tJyxcblx0XHRcdFx0XHRcdFN1YmplY3QgOiB0aGlzLmNvbnRhY3RTdWJqZWN0LFxuXHRcdFx0XHRcdFx0Qm9keSA6IGBNZXNzYWdlIGZyb206ICR7dGhpcy5jb250YWN0TmFtZX0sICR7dGhpcy5jb250YWN0RW1haWx9IC0gJHt0aGlzLmNvbnRhY3RNZXNzYWdlfWBcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHRoaXMuY29udGFjdE1lc3NhZ2UgPSAnJztcblx0XHRcdFx0XHR0aGlzLmNvbnRhY3ROYW1lID0gJyc7XG5cdFx0XHRcdFx0dGhpcy5jb250YWN0RW1haWwgPSAnJztcblx0XHRcdFx0XHR0aGlzLmNvbnRhY3RTdWJqZWN0ID0gJyc7XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRhY3RFcnJvciA9ICcnO1xuXHRcdFx0XHRcdHRoaXMuY29udGFjdENvbmZpcm1hdGlvbiA9ICdUaGFuayB5b3UgZm9yIHlvdXIgbWVzc2FnZSEgV2Ugd2lsbCBiZSBpbiB0b3VjaCBhcyBzb29uIGFzIHBvc3NpYmxlLic7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5jb250YWN0RXJyb3IgPSAnUGxlYXNlIGZpbGwgaW4gYWxsIGZpZWxkcyBhbmQgdHJ5IGFnYWluLic7XG5cdFx0XHRcdFx0dGhpcy5jb250YWN0Q29uZmlybWF0aW9uID0gJyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG4iLCIvKiBUaGlzIGlzIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgY29kZSwgZXZlcnl0aGluZyBnZXRzIGtpY2tlZCBvZmYgaGVyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCAnLi92ZW5kb3IvcG9seWZpbGxzJztcbmltcG9ydCBtYWluVnVlIGZyb20gJy4vbWFpbi12dWUnO1xuaW1wb3J0IHNjcm9sbFJldmVhbCBmcm9tICcuL3Njcm9sbC1yZXZlYWwnO1xuXG5tYWluVnVlKCk7XG5zY3JvbGxSZXZlYWwoKTtcblxubWFwYm94Z2wuYWNjZXNzVG9rZW4gPSAncGsuZXlKMUlqb2lhMlpoYkdWdVkybHJJaXdpWVNJNkltNUtUbEZMWmpRaWZRLl8zdjFwYTkwRGRTaXV0aXdDaUljY2cnO1xuXG5sZXQgbWFwID0gbmV3IG1hcGJveGdsLk1hcCh7XG5cdGNvbnRhaW5lcjogJ21hcCcsXG5cdHN0eWxlOiAnbWFwYm94Oi8vc3R5bGVzL2tmYWxlbmNpay9janVtZ21vdWswNWRnMWZteDl4dzFjNmhwJyxcblx0Y2VudGVyOiBbLTMuMjE3OSwgNTUuOTQ0Nl0sXG5cdHpvb206IDE2Ljdcbn0pO1xuXG5tYXAub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdG1hcC5sb2FkSW1hZ2UoJy4vaW1hZ2VzL21hcmtlci5wbmcnLCBmdW5jdGlvbihlcnJvciwgaW1hZ2UpIHtcblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdG1hcC5hZGRJbWFnZSgnY3VzdG9tLW1hcmtlcicsIGltYWdlKTtcblx0XHRtYXAuYWRkTGF5ZXIoe1xuXHRcdFx0aWQ6ICdtYXJrZXJzJyxcblx0XHRcdHR5cGU6ICdzeW1ib2wnLFxuXHRcdFx0LyogU291cmNlOiBBIGRhdGEgc291cmNlIHNwZWNpZmllcyB0aGUgZ2VvZ3JhcGhpYyBjb29yZGluYXRlIHdoZXJlIHRoZSBpbWFnZSBtYXJrZXIgZ2V0cyBwbGFjZWQuICovXG5cdFx0XHRzb3VyY2U6IHtcblx0XHRcdFx0dHlwZTogJ2dlb2pzb24nLFxuXHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0dHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcblx0XHRcdFx0XHRmZWF0dXJlczogW3tcblx0XHRcdFx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcblx0XHRcdFx0XHRcdHByb3BlcnRpZXM6IHt9LFxuXHRcdFx0XHRcdFx0Z2VvbWV0cnk6IHtcblx0XHRcdFx0XHRcdFx0dHlwZTogJ1BvaW50Jyxcblx0XHRcdFx0XHRcdFx0Y29vcmRpbmF0ZXM6IFstMy4yMTc2MjU3LCA1NS45NDQ2XVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRsYXlvdXQ6IHtcblx0XHRcdFx0J2ljb24taW1hZ2UnOiAnY3VzdG9tLW1hcmtlcicsXG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufSk7XG5cbm1hcC5zY3JvbGxab29tLmRpc2FibGUoKTtcblxuIiwiaW1wb3J0IHNjcm9sbFJldmVhbCBmcm9tICcuL3ZlbmRvci9zY3JvbGxyZXZlYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcblx0c2Nyb2xsUmV2ZWFsKCkucmV2ZWFsKCcuYWJvdXQgcCcsIHsgY2xlYW51cDogdHJ1ZSwgZGVsYXk6IDEwMDAsIGR1cmF0aW9uOiAxMDAwLCBkaXN0YW5jZTogJzI1MHB4Jywgb3JpZ2luOiAnYm90dG9tJywgaW50ZXJ2YWw6IDMwMCB9KTtcblx0c2Nyb2xsUmV2ZWFsKCkucmV2ZWFsKCcuYXJ0aXN0cyAuYXJ0aXN0c19faXRlbTpudGgtY2hpbGQoMm4gKyAxKScsIHsgY2xlYW51cDogdHJ1ZSwgZGVsYXk6IDEwMDAsIGR1cmF0aW9uOiAxMDAwLCBkaXN0YW5jZTogJzUwcHgnLCBvcmlnaW46ICdib3R0b20nLCBpbnRlcnZhbDogMzAwIH0pO1xuXHRzY3JvbGxSZXZlYWwoKS5yZXZlYWwoJy5hcnRpc3RzIC5hcnRpc3RzX19pdGVtOm50aC1jaGlsZCgybiArIDIpJywgeyBjbGVhbnVwOiB0cnVlLCBkZWxheTogMTAwMCwgZHVyYXRpb246IDEwMDAsIGRpc3RhbmNlOiAnNTBweCcsIG9yaWdpbjogJ3RvcCcsIGludGVydmFsOiAzMDAgfSk7XG5cdHNjcm9sbFJldmVhbCgpLnJldmVhbCgnLmNvbnRhY3QgLmgyLCAuc29jaWFsIC5oMiwgLmFydGlzdHMgLmgyLCAuYWJvdXQgLmgyJywgeyBjbGVhbnVwOiB0cnVlLCBkZWxheTogNTAwLCBkdXJhdGlvbjogMTAwMCwgZGlzdGFuY2U6ICcyNTBweCcsIG9yaWdpbjogJ3RvcCcsIGludGVydmFsOiAzMDAgfSk7XG5cdHNjcm9sbFJldmVhbCgpLnJldmVhbCgnLmNvbnRhY3QgcCcsIHsgY2xlYW51cDogdHJ1ZSwgZGVsYXk6IDUwMCwgZHVyYXRpb246IDEwMDAsIGRpc3RhbmNlOiAnMjUwcHgnLCBvcmlnaW46ICdsZWZ0JywgaW50ZXJ2YWw6IDMwMCB9KTtcblx0c2Nyb2xsUmV2ZWFsKCkucmV2ZWFsKCcuY29udGFjdCBpbnB1dCwgLmNvbnRhY3QgdGV4dGFyZWEsIC5jb250YWN0IGJ1dHRvbicsIHsgY2xlYW51cDogdHJ1ZSwgZGVsYXk6IDEwMDAsIGR1cmF0aW9uOiAxMDAwLCBkaXN0YW5jZTogJzI1MHB4Jywgb3JpZ2luOiAndG9wJywgaW50ZXJ2YWw6IDMwMCB9KTtcblx0c2Nyb2xsUmV2ZWFsKCkucmV2ZWFsKCcuY29udGFjdCBwLCAuc29jaWFsIHAnLCB7IGNsZWFudXA6IHRydWUsIGRlbGF5OiA1MDAsIGR1cmF0aW9uOiAxMDAwLCBkaXN0YW5jZTogJzI1MHB4Jywgb3JpZ2luOiAnbGVmdCcsIGludGVydmFsOiAzMDAgfSk7XG5cdHNjcm9sbFJldmVhbCgpLnJldmVhbCgnLnNvY2lhbCBhJywgeyBjbGVhbnVwOiB0cnVlLCBkZWxheTogMTAwMCwgZHVyYXRpb246IDEwMDAsIGRpc3RhbmNlOiAnMjUwcHgnLCBvcmlnaW46ICdyaWdodCcsIGludGVydmFsOiAzMDAgfSk7XG5cdHNjcm9sbFJldmVhbCgpLnJldmVhbCgnLnRhdHRvbyAucm93JywgeyBjbGVhbnVwOiB0cnVlLCBkZWxheTogNTAwLCBkdXJhdGlvbjogMTAwMCwgZGlzdGFuY2U6ICc1MHB4Jywgb3JpZ2luOiAnYm90dG9tJywgaW50ZXJ2YWw6IDMwMCB9KTtcblx0c2Nyb2xsUmV2ZWFsKCkucmV2ZWFsKCcudGF0dG9vIC50YXR0b29fX2l0ZW06bnRoLWNoaWxkKDJuICsgMiknLCB7IGNsZWFudXA6IHRydWUsIGRlbGF5OiA1MDAwLCBkdXJhdGlvbjogMTAwMCwgZGlzdGFuY2U6ICc1MHB4Jywgb3JpZ2luOiAndG9wJywgaW50ZXJ2YWw6IDMwMCB9KTtcbn1cblxuXG4iLCJpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcblx0Ly8gTXVzdCBiZSB3cml0YWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnYXNzaWduJywge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7IC8vIC5sZW5ndGggb2YgZnVuY3Rpb24gaXMgMlxuXHRcdFx0J3VzZSBzdHJpY3QnO1xuXHRcdFx0aWYgKHRhcmdldCA9PT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuXG5cdFx0XHRmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdFx0XHR2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cblx0XHRcdFx0aWYgKG5leHRTb3VyY2UgIT09IG51bGwpIHsgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG5cdFx0XHRcdFx0Zm9yICh2YXIgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG5cdFx0XHRcdFx0XHQvLyBBdm9pZCBidWdzIHdoZW4gaGFzT3duUHJvcGVydHkgaXMgc2hhZG93ZWRcblx0XHRcdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcblx0XHRcdFx0XHRcdFx0dG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRvO1xuXHRcdH0sXG5cdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdH0pO1xufVxuXG5pZiAoJ05vZGVMaXN0JyBpbiB3aW5kb3cgJiYgIU5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgY29uc29sZS5pbmZvKCdwb2x5ZmlsbCBmb3IgSUUxMScpO1xuICAgIE5vZGVMaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICB0aGlzQXJnID0gdGhpc0FyZyB8fCB3aW5kb3c7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzW2ldLCBpLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xufVxuXG5OdW1iZXIuaXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnc3RhcnRzV2l0aCcsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHNlYXJjaCwgcG9zKSB7XG4gICAgICAgICAgICBwb3MgPSAhcG9zIHx8IHBvcyA8IDAgPyAwIDogK3BvcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnN0cmluZyhwb3MsIHBvcyArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmlsbCkge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCAnZmlsbCcsIHtcblx0ICB2YWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblxuXHRcdC8vIFN0ZXBzIDEtMi5cblx0XHRpZiAodGhpcyA9PT0gbnVsbCkge1xuXHRcdCAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XG5cdFx0fVxuXG5cdFx0dmFyIE8gPSBPYmplY3QodGhpcyk7XG5cblx0XHQvLyBTdGVwcyAzLTUuXG5cdFx0dmFyIGxlbiA9IE8ubGVuZ3RoID4+PiAwO1xuXG5cdFx0Ly8gU3RlcHMgNi03LlxuXHRcdHZhciBzdGFydCA9IGFyZ3VtZW50c1sxXTtcblx0XHR2YXIgcmVsYXRpdmVTdGFydCA9IHN0YXJ0ID4+IDA7XG5cblx0XHQvLyBTdGVwIDguXG5cdFx0dmFyIGsgPSByZWxhdGl2ZVN0YXJ0IDwgMCA/XG5cdFx0ICBNYXRoLm1heChsZW4gKyByZWxhdGl2ZVN0YXJ0LCAwKSA6XG5cdFx0ICBNYXRoLm1pbihyZWxhdGl2ZVN0YXJ0LCBsZW4pO1xuXG5cdFx0Ly8gU3RlcHMgOS0xMC5cblx0XHR2YXIgZW5kID0gYXJndW1lbnRzWzJdO1xuXHRcdHZhciByZWxhdGl2ZUVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID9cblx0XHQgIGxlbiA6IGVuZCA+PiAwO1xuXG5cdFx0Ly8gU3RlcCAxMS5cblx0XHR2YXIgZmluYWwgPSByZWxhdGl2ZUVuZCA8IDAgP1xuXHRcdCAgTWF0aC5tYXgobGVuICsgcmVsYXRpdmVFbmQsIDApIDpcblx0XHQgIE1hdGgubWluKHJlbGF0aXZlRW5kLCBsZW4pO1xuXG5cdFx0Ly8gU3RlcCAxMi5cblx0XHR3aGlsZSAoayA8IGZpbmFsKSB7XG5cdFx0ICBPW2tdID0gdmFsdWU7XG5cdFx0ICBrKys7XG5cdFx0fVxuXG5cdFx0Ly8gU3RlcCAxMy5cblx0XHRyZXR1cm4gTztcblx0ICB9XG5cdH0pO1xuICB9XG5cbiAgaWYgKCFTdHJpbmcucHJvdG90eXBlLnJlcGVhdCkge1xuXHRTdHJpbmcucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG5cdCAgJ3VzZSBzdHJpY3QnO1xuXHQgIGlmICh0aGlzID09PSBudWxsKVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhblxcJ3QgY29udmVydCAnICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG5cblx0ICB2YXIgc3RyID0gJycgKyB0aGlzO1xuXHQgIC8vIFRvIGNvbnZlcnQgc3RyaW5nIHRvIGludGVnZXIuXG5cdCAgY291bnQgPSArY291bnQ7XG5cdCAgLy8gQ2hlY2sgTmFOXG5cdCAgaWYgKGNvdW50ICE9IGNvdW50KVxuXHRcdGNvdW50ID0gMDtcblxuXHQgIGlmIChjb3VudCA8IDApXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlcGVhdCBjb3VudCBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuXG5cdCAgaWYgKGNvdW50ID09PSBJbmZpbml0eSlcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcigncmVwZWF0IGNvdW50IG11c3QgYmUgbGVzcyB0aGFuIGluZmluaXR5Jyk7XG5cblx0ICBjb3VudCA9IE1hdGguZmxvb3IoY291bnQpO1xuXHQgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IGNvdW50ID09PSAwKVxuXHRcdHJldHVybiAnJztcblxuXHQgIC8vIEVuc3VyaW5nIGNvdW50IGlzIGEgMzEtYml0IGludGVnZXIgYWxsb3dzIHVzIHRvIGhlYXZpbHkgb3B0aW1pemUgdGhlXG5cdCAgLy8gbWFpbiBwYXJ0LiBCdXQgYW55d2F5LCBtb3N0IGN1cnJlbnQgKEF1Z3VzdCAyMDE0KSBicm93c2VycyBjYW4ndCBoYW5kbGVcblx0ICAvLyBzdHJpbmdzIDEgPDwgMjggY2hhcnMgb3IgbG9uZ2VyLCBzbzpcblx0ICBpZiAoc3RyLmxlbmd0aCAqIGNvdW50ID49IDEgPDwgMjgpXG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlcGVhdCBjb3VudCBtdXN0IG5vdCBvdmVyZmxvdyBtYXhpbXVtIHN0cmluZyBzaXplJyk7XG5cblx0ICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG5cdCAgY291bnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKGNvdW50KSAvIE1hdGgubG9nKDIpKTtcblx0ICB3aGlsZSAoY291bnQpIHtcblx0XHQgc3RyICs9IHN0cjtcblx0XHQgY291bnQtLTtcblx0ICB9XG5cdCAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcblx0ICByZXR1cm4gc3RyO1xuXHR9XG4gIH1cbiIsIi8qISBAbGljZW5zZSBTY3JvbGxSZXZlYWwgdjQuMC41XG5cblx0Q29weXJpZ2h0IDIwMTggRmlzc3Npb24gTExDLlxuXG5cdExpY2Vuc2VkIHVuZGVyIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSAzLjAgZm9yXG5cdGNvbXBhdGlibGUgb3BlbiBzb3VyY2UgcHJvamVjdHMgYW5kIG5vbi1jb21tZXJjaWFsIHVzZS5cblxuXHRGb3IgY29tbWVyY2lhbCBzaXRlcywgdGhlbWVzLCBwcm9qZWN0cywgYW5kIGFwcGxpY2F0aW9ucyxcblx0a2VlcCB5b3VyIHNvdXJjZSBjb2RlIHByaXZhdGUvcHJvcHJpZXRhcnkgYnkgcHVyY2hhc2luZ1xuXHRhIGNvbW1lcmNpYWwgbGljZW5zZSBmcm9tIGh0dHBzOi8vc2Nyb2xscmV2ZWFsanMub3JnL1xuKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5TY3JvbGxSZXZlYWwgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0cyA9IHtcblx0ZGVsYXk6IDAsXG5cdGRpc3RhbmNlOiAnMCcsXG5cdGR1cmF0aW9uOiA2MDAsXG5cdGVhc2luZzogJ2N1YmljLWJlemllcigwLjUsIDAsIDAsIDEpJyxcblx0aW50ZXJ2YWw6IDAsXG5cdG9wYWNpdHk6IDAsXG5cdG9yaWdpbjogJ2JvdHRvbScsXG5cdHJvdGF0ZToge1xuXHRcdHg6IDAsXG5cdFx0eTogMCxcblx0XHR6OiAwXG5cdH0sXG5cdHNjYWxlOiAxLFxuXHRjbGVhbnVwOiBmYWxzZSxcblx0Y29udGFpbmVyOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG5cdGRlc2t0b3A6IHRydWUsXG5cdG1vYmlsZTogdHJ1ZSxcblx0cmVzZXQ6IGZhbHNlLFxuXHR1c2VEZWxheTogJ2Fsd2F5cycsXG5cdHZpZXdGYWN0b3I6IDAuMCxcblx0dmlld09mZnNldDoge1xuXHRcdHRvcDogMCxcblx0XHRyaWdodDogMCxcblx0XHRib3R0b206IDAsXG5cdFx0bGVmdDogMFxuXHR9LFxuXHRhZnRlclJlc2V0OiBmdW5jdGlvbiBhZnRlclJlc2V0KCkge30sXG5cdGFmdGVyUmV2ZWFsOiBmdW5jdGlvbiBhZnRlclJldmVhbCgpIHt9LFxuXHRiZWZvcmVSZXNldDogZnVuY3Rpb24gYmVmb3JlUmVzZXQoKSB7fSxcblx0YmVmb3JlUmV2ZWFsOiBmdW5jdGlvbiBiZWZvcmVSZXZlYWwoKSB7fVxufVxuXG5mdW5jdGlvbiBmYWlsdXJlKCkge1xuXHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc3InKTtcblxuXHRyZXR1cm4ge1xuXHRcdGNsZWFuOiBmdW5jdGlvbiBjbGVhbigpIHt9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7fSxcblx0XHRyZXZlYWw6IGZ1bmN0aW9uIHJldmVhbCgpIHt9LFxuXHRcdHN5bmM6IGZ1bmN0aW9uIHN5bmMoKSB7fSxcblx0XHRnZXQgbm9vcCgpIHtcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHN1Y2Nlc3MoKSB7XG5cdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzcicpO1xuXG5cdGlmIChkb2N1bWVudC5ib2R5KSB7XG5cdFx0ZG9jdW1lbnQuYm9keS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdH0gZWxzZSB7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGRvY3VtZW50LmJvZHkuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXHRcdH0pO1xuXHR9XG59XG5cbnZhciBtb3VudCA9IHsgc3VjY2Vzczogc3VjY2VzcywgZmFpbHVyZTogZmFpbHVyZSB9XG5cbi8qISBAbGljZW5zZSBpcy1kb20tbm9kZSB2MS4wLjRcblxuXHRDb3B5cmlnaHQgMjAxOCBGaXNzc2lvbiBMTEMuXG5cblx0UGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuXHRvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5cdGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcblx0dG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuXHRjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcblx0ZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuXHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcblx0Y29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5cdElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuXHRGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcblx0QVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuXHRMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuXHRPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuXHRTT0ZUV0FSRS5cblxuKi9cbmZ1bmN0aW9uIGlzRG9tTm9kZSh4KSB7XG5cdHJldHVybiB0eXBlb2Ygd2luZG93Lk5vZGUgPT09ICdvYmplY3QnXG5cdFx0PyB4IGluc3RhbmNlb2Ygd2luZG93Lk5vZGVcblx0XHQ6IHggIT09IG51bGwgJiZcblx0XHRcdFx0dHlwZW9mIHggPT09ICdvYmplY3QnICYmXG5cdFx0XHRcdHR5cGVvZiB4Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0XHR0eXBlb2YgeC5ub2RlTmFtZSA9PT0gJ3N0cmluZydcbn1cblxuLyohIEBsaWNlbnNlIGlzLWRvbS1ub2RlLWxpc3QgdjEuMi4xXG5cblx0Q29weXJpZ2h0IDIwMTggRmlzc3Npb24gTExDLlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcblx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG5cdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcblx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5cdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5cdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0RklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcblx0T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblx0U09GVFdBUkUuXG5cbiovXG5mdW5jdGlvbiBpc0RvbU5vZGVMaXN0KHgpIHtcblx0dmFyIHByb3RvdHlwZVRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpO1xuXHR2YXIgcmVnZXggPSAvXlxcW29iamVjdCAoSFRNTENvbGxlY3Rpb258Tm9kZUxpc3R8T2JqZWN0KVxcXSQvO1xuXG5cdHJldHVybiB0eXBlb2Ygd2luZG93Lk5vZGVMaXN0ID09PSAnb2JqZWN0J1xuXHRcdD8geCBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlTGlzdFxuXHRcdDogeCAhPT0gbnVsbCAmJlxuXHRcdFx0XHR0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdFx0dHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdFx0XHRyZWdleC50ZXN0KHByb3RvdHlwZVRvU3RyaW5nKSAmJlxuXHRcdFx0XHQoeC5sZW5ndGggPT09IDAgfHwgaXNEb21Ob2RlKHhbMF0pKVxufVxuXG4vKiEgQGxpY2Vuc2UgVGVhbGlnaHQgdjAuMy42XG5cblx0Q29weXJpZ2h0IDIwMTggRmlzc3Npb24gTExDLlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcblx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG5cdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcblx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5cdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5cdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0RklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcblx0T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblx0U09GVFdBUkUuXG5cbiovXG5mdW5jdGlvbiB0ZWFsaWdodCh0YXJnZXQsIGNvbnRleHQpIHtcbiAgaWYgKCBjb250ZXh0ID09PSB2b2lkIDAgKSB7IGNvbnRleHQgPSBkb2N1bWVudDsgfVxuXG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSkgeyByZXR1cm4gdGFyZ2V0LmZpbHRlcihpc0RvbU5vZGUpOyB9XG4gIGlmIChpc0RvbU5vZGUodGFyZ2V0KSkgeyByZXR1cm4gW3RhcmdldF07IH1cbiAgaWYgKGlzRG9tTm9kZUxpc3QodGFyZ2V0KSkgeyByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGFyZ2V0KTsgfVxuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcXVlcnkgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0KTtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChxdWVyeSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuXHRyZXR1cm4gKFxuXHRcdHggIT09IG51bGwgJiZcblx0XHR4IGluc3RhbmNlb2YgT2JqZWN0ICYmXG5cdFx0KHguY29uc3RydWN0b3IgPT09IE9iamVjdCB8fFxuXHRcdFx0T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJylcblx0KVxufVxuXG5mdW5jdGlvbiBlYWNoKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG5cdGlmIChpc09iamVjdChjb2xsZWN0aW9uKSkge1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29sbGVjdGlvbik7XG5cdFx0cmV0dXJuIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjYWxsYmFjayhjb2xsZWN0aW9uW2tleV0sIGtleSwgY29sbGVjdGlvbik7IH0pXG5cdH1cblx0aWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHsgcmV0dXJuIGNhbGxiYWNrKGl0ZW0sIGksIGNvbGxlY3Rpb24pOyB9KVxuXHR9XG5cdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGVpdGhlciBhbiBhcnJheSBvciBvYmplY3QgbGl0ZXJhbC4nKVxufVxuXG5mdW5jdGlvbiBsb2dnZXIobWVzc2FnZSkge1xuXHR2YXIgZGV0YWlscyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblx0d2hpbGUgKCBsZW4tLSA+IDAgKSBkZXRhaWxzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG5cdGlmICh0aGlzLmNvbnN0cnVjdG9yLmRlYnVnICYmIGNvbnNvbGUpIHtcblx0XHR2YXIgcmVwb3J0ID0gXCIlY1Njcm9sbFJldmVhbDogXCIgKyBtZXNzYWdlO1xuXHRcdGRldGFpbHMuZm9yRWFjaChmdW5jdGlvbiAoZGV0YWlsKSB7IHJldHVybiAocmVwb3J0ICs9IFwiXFxuIOKAlCBcIiArIGRldGFpbCk7IH0pO1xuXHRcdGNvbnNvbGUubG9nKHJlcG9ydCwgJ2NvbG9yOiAjZWE2NTRiOycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0fVxufVxuXG5mdW5jdGlvbiByaW5zZSgpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0dmFyIHN0cnVjdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG5cdFx0YWN0aXZlOiBbXSxcblx0XHRzdGFsZTogW11cblx0fSk7IH07XG5cblx0dmFyIGVsZW1lbnRJZHMgPSBzdHJ1Y3QoKTtcblx0dmFyIHNlcXVlbmNlSWRzID0gc3RydWN0KCk7XG5cdHZhciBjb250YWluZXJJZHMgPSBzdHJ1Y3QoKTtcblxuXHQvKipcblx0ICogVGFrZSBzdG9jayBvZiBhY3RpdmUgZWxlbWVudCBJRHMuXG5cdCAqL1xuXHR0cnkge1xuXHRcdGVhY2godGVhbGlnaHQoJ1tkYXRhLXNyLWlkXScpLCBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIGlkID0gcGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3ItaWQnKSk7XG5cdFx0XHRlbGVtZW50SWRzLmFjdGl2ZS5wdXNoKGlkKTtcblx0XHR9KTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHRocm93IGVcblx0fVxuXHQvKipcblx0ICogRGVzdHJveSBzdGFsZSBlbGVtZW50cy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudElkcy5hY3RpdmUuaW5kZXhPZihlbGVtZW50LmlkKSA9PT0gLTEpIHtcblx0XHRcdGVsZW1lbnRJZHMuc3RhbGUucHVzaChlbGVtZW50LmlkKTtcblx0XHR9XG5cdH0pO1xuXG5cdGVhY2goZWxlbWVudElkcy5zdGFsZSwgZnVuY3Rpb24gKHN0YWxlSWQpIHsgcmV0dXJuIGRlbGV0ZSB0aGlzJDEuc3RvcmUuZWxlbWVudHNbc3RhbGVJZF07IH0pO1xuXG5cdC8qKlxuXHQgKiBUYWtlIHN0b2NrIG9mIGFjdGl2ZSBjb250YWluZXIgYW5kIHNlcXVlbmNlIElEcy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5lbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRpZiAoY29udGFpbmVySWRzLmFjdGl2ZS5pbmRleE9mKGVsZW1lbnQuY29udGFpbmVySWQpID09PSAtMSkge1xuXHRcdFx0Y29udGFpbmVySWRzLmFjdGl2ZS5wdXNoKGVsZW1lbnQuY29udGFpbmVySWQpO1xuXHRcdH1cblx0XHRpZiAoZWxlbWVudC5oYXNPd25Qcm9wZXJ0eSgnc2VxdWVuY2UnKSkge1xuXHRcdFx0aWYgKHNlcXVlbmNlSWRzLmFjdGl2ZS5pbmRleE9mKGVsZW1lbnQuc2VxdWVuY2UuaWQpID09PSAtMSkge1xuXHRcdFx0XHRzZXF1ZW5jZUlkcy5hY3RpdmUucHVzaChlbGVtZW50LnNlcXVlbmNlLmlkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHN0YWxlIGNvbnRhaW5lcnMuXG5cdCAqL1xuXHRlYWNoKHRoaXMuc3RvcmUuY29udGFpbmVycywgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdGlmIChjb250YWluZXJJZHMuYWN0aXZlLmluZGV4T2YoY29udGFpbmVyLmlkKSA9PT0gLTEpIHtcblx0XHRcdGNvbnRhaW5lcklkcy5zdGFsZS5wdXNoKGNvbnRhaW5lci5pZCk7XG5cdFx0fVxuXHR9KTtcblxuXHRlYWNoKGNvbnRhaW5lcklkcy5zdGFsZSwgZnVuY3Rpb24gKHN0YWxlSWQpIHtcblx0XHR2YXIgc3RhbGUgPSB0aGlzJDEuc3RvcmUuY29udGFpbmVyc1tzdGFsZUlkXS5ub2RlO1xuXHRcdHN0YWxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMkMS5kZWxlZ2F0ZSk7XG5cdFx0c3RhbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcyQxLmRlbGVnYXRlKTtcblx0XHRkZWxldGUgdGhpcyQxLnN0b3JlLmNvbnRhaW5lcnNbc3RhbGVJZF07XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBEZXN0cm95IHN0YWxlIHNlcXVlbmNlcy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5zZXF1ZW5jZXMsIGZ1bmN0aW9uIChzZXF1ZW5jZSkge1xuXHRcdGlmIChzZXF1ZW5jZUlkcy5hY3RpdmUuaW5kZXhPZihzZXF1ZW5jZS5pZCkgPT09IC0xKSB7XG5cdFx0XHRzZXF1ZW5jZUlkcy5zdGFsZS5wdXNoKHNlcXVlbmNlLmlkKTtcblx0XHR9XG5cdH0pO1xuXG5cdGVhY2goc2VxdWVuY2VJZHMuc3RhbGUsIGZ1bmN0aW9uIChzdGFsZUlkKSB7IHJldHVybiBkZWxldGUgdGhpcyQxLnN0b3JlLnNlcXVlbmNlc1tzdGFsZUlkXTsgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFuKHRhcmdldCkge1xuXHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHR2YXIgZGlydHk7XG5cdHRyeSB7XG5cdFx0ZWFjaCh0ZWFsaWdodCh0YXJnZXQpLCBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIGlkID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3ItaWQnKTtcblx0XHRcdGlmIChpZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRkaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gdGhpcyQxLnN0b3JlLmVsZW1lbnRzW2lkXTtcblx0XHRcdFx0aWYgKGVsZW1lbnQuY2FsbGJhY2tUaW1lcikge1xuXHRcdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoZWxlbWVudC5jYWxsYmFja1RpbWVyLmNsb2NrKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBlbGVtZW50LnN0eWxlcy5pbmxpbmUuZ2VuZXJhdGVkKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc3ItaWQnKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMkMS5zdG9yZS5lbGVtZW50c1tpZF07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gbG9nZ2VyLmNhbGwodGhpcywgJ0NsZWFuIGZhaWxlZC4nLCBlLm1lc3NhZ2UpXG5cdH1cblxuXHRpZiAoZGlydHkpIHtcblx0XHR0cnkge1xuXHRcdFx0cmluc2UuY2FsbCh0aGlzKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gbG9nZ2VyLmNhbGwodGhpcywgJ0NsZWFuIGZhaWxlZC4nLCBlLm1lc3NhZ2UpXG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIGdlbmVyYXRlZCBzdHlsZXMgYW5kIGVsZW1lbnQgaWRzXG5cdCAqL1xuXHRlYWNoKHRoaXMuc3RvcmUuZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0ZWxlbWVudC5ub2RlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBlbGVtZW50LnN0eWxlcy5pbmxpbmUuZ2VuZXJhdGVkKTtcblx0XHRlbGVtZW50Lm5vZGUucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNyLWlkJyk7XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIGV2ZW50IGxpc3RlbmVycy5cblx0ICovXG5cdGVhY2godGhpcy5zdG9yZS5jb250YWluZXJzLCBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0dmFyIHRhcmdldCA9XG5cdFx0XHRjb250YWluZXIubm9kZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gd2luZG93IDogY29udGFpbmVyLm5vZGU7XG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMkMS5kZWxlZ2F0ZSk7XG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMkMS5kZWxlZ2F0ZSk7XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBDbGVhciBhbGwgZGF0YSBmcm9tIHRoZSBzdG9yZVxuXHQgKi9cblx0dGhpcy5zdG9yZSA9IHtcblx0XHRjb250YWluZXJzOiB7fSxcblx0XHRlbGVtZW50czoge30sXG5cdFx0aGlzdG9yeTogW10sXG5cdFx0c2VxdWVuY2VzOiB7fVxuXHR9O1xufVxuXG4vKiEgQGxpY2Vuc2UgUmVtYXRyaXggdjAuMy4wXG5cblx0Q29weXJpZ2h0IDIwMTggSnVsaWFuIExsb3lkLlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcblx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG5cdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcblx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5cdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cblx0YWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0RklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcblx0T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuXHRUSEUgU09GVFdBUkUuXG4qL1xuLyoqXG4gKiBAbW9kdWxlIFJlbWF0cml4XG4gKi9cblxuLyoqXG4gKiBUcmFuc2Zvcm1hdGlvbiBtYXRyaWNlcyBpbiB0aGUgYnJvd3NlciBjb21lIGluIHR3byBmbGF2b3JzOlxuICpcbiAqICAtIGBtYXRyaXhgIHVzaW5nIDYgdmFsdWVzIChzaG9ydClcbiAqICAtIGBtYXRyaXgzZGAgdXNpbmcgMTYgdmFsdWVzIChsb25nKVxuICpcbiAqIFRoaXMgdXRpbGl0eSBmb2xsb3dzIHRoaXMgW2NvbnZlcnNpb24gZ3VpZGVdKGh0dHBzOi8vZ29vLmdsL0VKbFVRMSlcbiAqIHRvIGV4cGFuZCBzaG9ydCBmb3JtIG1hdHJpY2VzIHRvIHRoZWlyIGVxdWl2YWxlbnQgbG9uZyBmb3JtLlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSBzb3VyY2UgLSBBY2NlcHRzIGJvdGggc2hvcnQgYW5kIGxvbmcgZm9ybSBtYXRyaWNlcy5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBmb3JtYXQoc291cmNlKSB7XG5cdGlmIChzb3VyY2UuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYXJyYXkuJylcblx0fVxuXHRpZiAoc291cmNlLmxlbmd0aCA9PT0gMTYpIHtcblx0XHRyZXR1cm4gc291cmNlXG5cdH1cblx0aWYgKHNvdXJjZS5sZW5ndGggPT09IDYpIHtcblx0XHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblx0XHRtYXRyaXhbMF0gPSBzb3VyY2VbMF07XG5cdFx0bWF0cml4WzFdID0gc291cmNlWzFdO1xuXHRcdG1hdHJpeFs0XSA9IHNvdXJjZVsyXTtcblx0XHRtYXRyaXhbNV0gPSBzb3VyY2VbM107XG5cdFx0bWF0cml4WzEyXSA9IHNvdXJjZVs0XTtcblx0XHRtYXRyaXhbMTNdID0gc291cmNlWzVdO1xuXHRcdHJldHVybiBtYXRyaXhcblx0fVxuXHR0aHJvdyBuZXcgUmFuZ2VFcnJvcignRXhwZWN0ZWQgYXJyYXkgd2l0aCBlaXRoZXIgNiBvciAxNiB2YWx1ZXMuJylcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbWF0cml4IHJlcHJlc2VudGluZyBubyB0cmFuc2Zvcm1hdGlvbi4gVGhlIHByb2R1Y3Qgb2YgYW55IG1hdHJpeFxuICogbXVsdGlwbGllZCBieSB0aGUgaWRlbnRpdHkgbWF0cml4IHdpbGwgYmUgdGhlIG9yaWdpbmFsIG1hdHJpeC5cbiAqXG4gKiA+ICoqVGlwOioqIFNpbWlsYXIgdG8gaG93IGA1ICogMSA9PT0gNWAsIHdoZXJlIGAxYCBpcyB0aGUgaWRlbnRpdHkuXG4gKlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KCkge1xuXHR2YXIgbWF0cml4ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHRcdGkgJSA1ID09IDAgPyBtYXRyaXgucHVzaCgxKSA6IG1hdHJpeC5wdXNoKDApO1xuXHR9XG5cdHJldHVybiBtYXRyaXhcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBjb21iaW5lZCB0cmFuc2Zvcm1hdGlvbnNcbiAqIG9mIGJvdGggYXJndW1lbnRzLlxuICpcbiAqID4gKipOb3RlOioqIE9yZGVyIGlzIHZlcnkgaW1wb3J0YW50LiBGb3IgZXhhbXBsZSwgcm90YXRpbmcgNDXCsFxuICogYWxvbmcgdGhlIFotYXhpcywgZm9sbG93ZWQgYnkgdHJhbnNsYXRpbmcgNTAwIHBpeGVscyBhbG9uZyB0aGVcbiAqIFktYXhpcy4uLiBpcyBub3QgdGhlIHNhbWUgYXMgdHJhbnNsYXRpbmcgNTAwIHBpeGVscyBhbG9uZyB0aGVcbiAqIFktYXhpcywgZm9sbG93ZWQgYnkgcm90YXRpbmcgNDXCsCBhbG9uZyBvbiB0aGUgWi1heGlzLlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSBtIC0gQWNjZXB0cyBib3RoIHNob3J0IGFuZCBsb25nIGZvcm0gbWF0cmljZXMuXG4gKiBAcGFyYW0gIHthcnJheX0geCAtIEFjY2VwdHMgYm90aCBzaG9ydCBhbmQgbG9uZyBmb3JtIG1hdHJpY2VzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG0sIHgpIHtcblx0dmFyIGZtID0gZm9ybWF0KG0pO1xuXHR2YXIgZnggPSBmb3JtYXQoeCk7XG5cdHZhciBwcm9kdWN0ID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHR2YXIgcm93ID0gW2ZtW2ldLCBmbVtpICsgNF0sIGZtW2kgKyA4XSwgZm1baSArIDEyXV07XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspIHtcblx0XHRcdHZhciBrID0gaiAqIDQ7XG5cdFx0XHR2YXIgY29sID0gW2Z4W2tdLCBmeFtrICsgMV0sIGZ4W2sgKyAyXSwgZnhbayArIDNdXTtcblx0XHRcdHZhciByZXN1bHQgPVxuXHRcdFx0XHRyb3dbMF0gKiBjb2xbMF0gKyByb3dbMV0gKiBjb2xbMV0gKyByb3dbMl0gKiBjb2xbMl0gKyByb3dbM10gKiBjb2xbM107XG5cblx0XHRcdHByb2R1Y3RbaSArIGtdID0gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwcm9kdWN0XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmV0dXJuIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIHRoZSBDU1MgdHJhbnNmb3JtXG4gKiBtYXRyaXggcGFzc2VkIGluLCBidXQgd2lsbCByZXR1cm4gdGhlIGlkZW50aXR5IG1hdHJpeCBhcyBhXG4gKiBmYWxsYmFjay5cbiAqXG4gKiA+ICoqVGlwOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY29udmVydCBhIENTUyBtYXRyaXggKHJldHJpZXZlZCBhcyBhXG4gKiBgc3RyaW5nYCBmcm9tIGNvbXB1dGVkIHN0eWxlcykgdG8gaXRzIGVxdWl2YWxlbnQgYXJyYXkgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc291cmNlIC0gYG1hdHJpeGAgb3IgYG1hdHJpeDNkYCBDU1MgVHJhbnNmb3JtIHZhbHVlLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNvdXJjZSkge1xuXHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcblx0XHR2YXIgbWF0Y2ggPSBzb3VyY2UubWF0Y2goL21hdHJpeCgzZCk/XFwoKFteKV0rKVxcKS8pO1xuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0dmFyIHJhdyA9IG1hdGNoWzJdLnNwbGl0KCcsICcpLm1hcChwYXJzZUZsb2F0KTtcblx0XHRcdHJldHVybiBmb3JtYXQocmF3KVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gaWRlbnRpdHkoKVxufVxuXG4vKipcbiAqIFJldHVybnMgYSA0eDQgbWF0cml4IGRlc2NyaWJpbmcgWC1heGlzIHJvdGF0aW9uLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gYW5nbGUgLSBNZWFzdXJlZCBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVgoYW5nbGUpIHtcblx0dmFyIHRoZXRhID0gTWF0aC5QSSAvIDE4MCAqIGFuZ2xlO1xuXHR2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcblxuXHRtYXRyaXhbNV0gPSBtYXRyaXhbMTBdID0gTWF0aC5jb3ModGhldGEpO1xuXHRtYXRyaXhbNl0gPSBtYXRyaXhbOV0gPSBNYXRoLnNpbih0aGV0YSk7XG5cdG1hdHJpeFs5XSAqPSAtMTtcblxuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBZLWF4aXMgcm90YXRpb24uXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBhbmdsZSAtIE1lYXN1cmVkIGluIGRlZ3JlZXMuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gcm90YXRlWShhbmdsZSkge1xuXHR2YXIgdGhldGEgPSBNYXRoLlBJIC8gMTgwICogYW5nbGU7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXG5cdG1hdHJpeFswXSA9IG1hdHJpeFsxMF0gPSBNYXRoLmNvcyh0aGV0YSk7XG5cdG1hdHJpeFsyXSA9IG1hdHJpeFs4XSA9IE1hdGguc2luKHRoZXRhKTtcblx0bWF0cml4WzJdICo9IC0xO1xuXG5cdHJldHVybiBtYXRyaXhcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIFotYXhpcyByb3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGFuZ2xlIC0gTWVhc3VyZWQgaW4gZGVncmVlcy5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiByb3RhdGVaKGFuZ2xlKSB7XG5cdHZhciB0aGV0YSA9IE1hdGguUEkgLyAxODAgKiBhbmdsZTtcblx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cblx0bWF0cml4WzBdID0gbWF0cml4WzVdID0gTWF0aC5jb3ModGhldGEpO1xuXHRtYXRyaXhbMV0gPSBtYXRyaXhbNF0gPSBNYXRoLnNpbih0aGV0YSk7XG5cdG1hdHJpeFs0XSAqPSAtMTtcblxuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyAyRCBzY2FsaW5nLiBUaGUgZmlyc3QgYXJndW1lbnRcbiAqIGlzIHVzZWQgZm9yIGJvdGggWCBhbmQgWS1heGlzIHNjYWxpbmcsIHVubGVzcyBhbiBvcHRpb25hbFxuICogc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkIHRvIGV4cGxpY2l0bHkgZGVmaW5lIFktYXhpcyBzY2FsaW5nLlxuICpcbiAqIEBwYXJhbSAge251bWJlcn0gc2NhbGFyICAgIC0gRGVjaW1hbCBtdWx0aXBsaWVyLlxuICogQHBhcmFtICB7bnVtYmVyfSBbc2NhbGFyWV0gLSBEZWNpbWFsIG11bHRpcGxpZXIuXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gc2NhbGUoc2NhbGFyLCBzY2FsYXJZKSB7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXG5cdG1hdHJpeFswXSA9IHNjYWxhcjtcblx0bWF0cml4WzVdID0gdHlwZW9mIHNjYWxhclkgPT09ICdudW1iZXInID8gc2NhbGFyWSA6IHNjYWxhcjtcblxuXHRyZXR1cm4gbWF0cml4XG59XG5cbi8qKlxuICogUmV0dXJucyBhIDR4NCBtYXRyaXggZGVzY3JpYmluZyBYLWF4aXMgdHJhbnNsYXRpb24uXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBkaXN0YW5jZSAtIE1lYXN1cmVkIGluIHBpeGVscy5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGVYKGRpc3RhbmNlKSB7XG5cdHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuXHRtYXRyaXhbMTJdID0gZGlzdGFuY2U7XG5cdHJldHVybiBtYXRyaXhcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgNHg0IG1hdHJpeCBkZXNjcmliaW5nIFktYXhpcyB0cmFuc2xhdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRpc3RhbmNlIC0gTWVhc3VyZWQgaW4gcGl4ZWxzLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZVkoZGlzdGFuY2UpIHtcblx0dmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG5cdG1hdHJpeFsxM10gPSBkaXN0YW5jZTtcblx0cmV0dXJuIG1hdHJpeFxufVxuXG52YXIgZ2V0UHJlZml4ZWRDc3NQcm9wID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHByb3BlcnRpZXMgPSB7fTtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXG5cdGZ1bmN0aW9uIGdldFByZWZpeGVkQ3NzUHJvcGVydHkobmFtZSwgc291cmNlKSB7XG5cdFx0aWYgKCBzb3VyY2UgPT09IHZvaWQgMCApIHNvdXJjZSA9IHN0eWxlO1xuXG5cdFx0aWYgKG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpZiAocHJvcGVydGllc1tuYW1lXSkge1xuXHRcdFx0XHRyZXR1cm4gcHJvcGVydGllc1tuYW1lXVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBzb3VyY2VbbmFtZV0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldHVybiAocHJvcGVydGllc1tuYW1lXSA9IG5hbWUpXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIHNvdXJjZVsoXCItd2Via2l0LVwiICsgbmFtZSldID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRyZXR1cm4gKHByb3BlcnRpZXNbbmFtZV0gPSBcIi13ZWJraXQtXCIgKyBuYW1lKVxuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoKFwiVW5hYmxlIHRvIGZpbmQgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBzdHlsZSBwcm9wZXJ0eS5cIikpXG5cdFx0fVxuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nLicpXG5cdH1cblxuXHRnZXRQcmVmaXhlZENzc1Byb3BlcnR5LmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAocHJvcGVydGllcyA9IHt9KTsgfTtcblxuXHRyZXR1cm4gZ2V0UHJlZml4ZWRDc3NQcm9wZXJ0eVxufSkoKTtcblxuZnVuY3Rpb24gc3R5bGUoZWxlbWVudCkge1xuXHR2YXIgY29tcHV0ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50Lm5vZGUpO1xuXHR2YXIgcG9zaXRpb24gPSBjb21wdXRlZC5wb3NpdGlvbjtcblx0dmFyIGNvbmZpZyA9IGVsZW1lbnQuY29uZmlnO1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBpbmxpbmUgc3R5bGVzXG5cdCAqL1xuXHR2YXIgaW5saW5lID0ge307XG5cdHZhciBpbmxpbmVTdHlsZSA9IGVsZW1lbnQubm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJyc7XG5cdHZhciBpbmxpbmVNYXRjaCA9IGlubGluZVN0eWxlLm1hdGNoKC9bXFx3LV0rXFxzKjpcXHMqW147XStcXHMqL2dpKSB8fCBbXTtcblxuXHRpbmxpbmUuY29tcHV0ZWQgPSBpbmxpbmVNYXRjaCA/IGlubGluZU1hdGNoLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50cmltKCk7IH0pLmpvaW4oJzsgJykgKyAnOycgOiAnJztcblxuXHRpbmxpbmUuZ2VuZXJhdGVkID0gaW5saW5lTWF0Y2guc29tZShmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5tYXRjaCgvdmlzaWJpbGl0eVxccz86XFxzP3Zpc2libGUvaSk7IH0pXG5cdFx0PyBpbmxpbmUuY29tcHV0ZWRcblx0XHQ6IGlubGluZU1hdGNoLmNvbmNhdCggWyd2aXNpYmlsaXR5OiB2aXNpYmxlJ10pLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS50cmltKCk7IH0pLmpvaW4oJzsgJykgKyAnOyc7XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIG9wYWNpdHkgc3R5bGVzXG5cdCAqL1xuXHR2YXIgY29tcHV0ZWRPcGFjaXR5ID0gcGFyc2VGbG9hdChjb21wdXRlZC5vcGFjaXR5KTtcblx0dmFyIGNvbmZpZ09wYWNpdHkgPSAhaXNOYU4ocGFyc2VGbG9hdChjb25maWcub3BhY2l0eSkpXG5cdFx0PyBwYXJzZUZsb2F0KGNvbmZpZy5vcGFjaXR5KVxuXHRcdDogcGFyc2VGbG9hdChjb21wdXRlZC5vcGFjaXR5KTtcblxuXHR2YXIgb3BhY2l0eSA9IHtcblx0XHRjb21wdXRlZDogY29tcHV0ZWRPcGFjaXR5ICE9PSBjb25maWdPcGFjaXR5ID8gKFwib3BhY2l0eTogXCIgKyBjb21wdXRlZE9wYWNpdHkgKyBcIjtcIikgOiAnJyxcblx0XHRnZW5lcmF0ZWQ6IGNvbXB1dGVkT3BhY2l0eSAhPT0gY29uZmlnT3BhY2l0eSA/IChcIm9wYWNpdHk6IFwiICsgY29uZmlnT3BhY2l0eSArIFwiO1wiKSA6ICcnXG5cdH07XG5cblx0LyoqXG5cdCAqIEdlbmVyYXRlIHRyYW5zZm9ybWF0aW9uIHN0eWxlc1xuXHQgKi9cblx0dmFyIHRyYW5zZm9ybWF0aW9ucyA9IFtdO1xuXG5cdGlmIChwYXJzZUZsb2F0KGNvbmZpZy5kaXN0YW5jZSkpIHtcblx0XHR2YXIgYXhpcyA9IGNvbmZpZy5vcmlnaW4gPT09ICd0b3AnIHx8IGNvbmZpZy5vcmlnaW4gPT09ICdib3R0b20nID8gJ1knIDogJ1gnO1xuXG5cdFx0LyoqXG5cdFx0ICogTGV04oCZcyBtYWtlIHN1cmUgb3VyIG91ciBwaXhlbCBkaXN0YW5jZXMgYXJlIG5lZ2F0aXZlIGZvciB0b3AgYW5kIGxlZnQuXG5cdFx0ICogZS5nLiB7IG9yaWdpbjogJ3RvcCcsIGRpc3RhbmNlOiAnMjVweCcgfSBzdGFydHMgYXQgYHRvcDogLTI1cHhgIGluIENTUy5cblx0XHQgKi9cblx0XHR2YXIgZGlzdGFuY2UgPSBjb25maWcuZGlzdGFuY2U7XG5cdFx0aWYgKGNvbmZpZy5vcmlnaW4gPT09ICd0b3AnIHx8IGNvbmZpZy5vcmlnaW4gPT09ICdsZWZ0Jykge1xuXHRcdFx0ZGlzdGFuY2UgPSAvXi0vLnRlc3QoZGlzdGFuY2UpID8gZGlzdGFuY2Uuc3Vic3RyKDEpIDogKFwiLVwiICsgZGlzdGFuY2UpO1xuXHRcdH1cblxuXHRcdHZhciByZWYgPSBkaXN0YW5jZS5tYXRjaCgvKF4tP1xcZCtcXC4/XFxkPyl8KGVtJHxweCR8JSQpL2cpO1xuXHRcdHZhciB2YWx1ZSA9IHJlZlswXTtcblx0XHR2YXIgdW5pdCA9IHJlZlsxXTtcblxuXHRcdHN3aXRjaCAodW5pdCkge1xuXHRcdFx0Y2FzZSAnZW0nOlxuXHRcdFx0XHRkaXN0YW5jZSA9IHBhcnNlSW50KGNvbXB1dGVkLmZvbnRTaXplKSAqIHZhbHVlO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAncHgnOlxuXHRcdFx0XHRkaXN0YW5jZSA9IHZhbHVlO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnJSc6XG5cdFx0XHRcdC8qKlxuXHRcdFx0XHQgKiBIZXJlIHdlIHVzZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBpbnN0ZWFkIG9mXG5cdFx0XHRcdCAqIHRoZSBleGlzdGluZyBkYXRhIGF0dGFjaGVkIHRvIGBlbGVtZW50Lmdlb21ldHJ5YFxuXHRcdFx0XHQgKiBiZWNhdXNlIG9ubHkgdGhlIGZvcm1lciBpbmNsdWRlcyBhbnkgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRcdCAqIGN1cnJlbnQgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cblx0XHRcdFx0ICpcblx0XHRcdFx0ICogSWYgdGhhdCBiZWhhdmlvciBlbmRzIHVwIGJlaW5nIHVuaW50dWl0aXZlLCB0aGlzXG5cdFx0XHRcdCAqIGxvZ2ljIGNvdWxkIGluc3RlYWQgdXRpbGl6ZSBgZWxlbWVudC5nZW9tZXRyeS5oZWlnaHRgXG5cdFx0XHRcdCAqIGFuZCBgZWxlbWVudC5nZW9lbWV0cnkud2lkdGhgIGZvciB0aGUgZGlzdGFpbmNlIGNhbGN1bGF0aW9uXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRkaXN0YW5jZSA9XG5cdFx0XHRcdFx0YXhpcyA9PT0gJ1knXG5cdFx0XHRcdFx0XHQ/IGVsZW1lbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKiB2YWx1ZSAvIDEwMFxuXHRcdFx0XHRcdFx0OiBlbGVtZW50Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKiB2YWx1ZSAvIDEwMDtcblx0XHRcdFx0YnJlYWtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdVbnJlY29nbml6ZWQgb3IgbWlzc2luZyBkaXN0YW5jZSB1bml0LicpXG5cdFx0fVxuXG5cdFx0aWYgKGF4aXMgPT09ICdZJykge1xuXHRcdFx0dHJhbnNmb3JtYXRpb25zLnB1c2godHJhbnNsYXRlWShkaXN0YW5jZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0cmFuc2Zvcm1hdGlvbnMucHVzaCh0cmFuc2xhdGVYKGRpc3RhbmNlKSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNvbmZpZy5yb3RhdGUueCkgeyB0cmFuc2Zvcm1hdGlvbnMucHVzaChyb3RhdGVYKGNvbmZpZy5yb3RhdGUueCkpOyB9XG5cdGlmIChjb25maWcucm90YXRlLnkpIHsgdHJhbnNmb3JtYXRpb25zLnB1c2gocm90YXRlWShjb25maWcucm90YXRlLnkpKTsgfVxuXHRpZiAoY29uZmlnLnJvdGF0ZS56KSB7IHRyYW5zZm9ybWF0aW9ucy5wdXNoKHJvdGF0ZVooY29uZmlnLnJvdGF0ZS56KSk7IH1cblx0aWYgKGNvbmZpZy5zY2FsZSAhPT0gMSkge1xuXHRcdGlmIChjb25maWcuc2NhbGUgPT09IDApIHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIENTUyBUcmFuc2Zvcm1zIG1hdHJpeCBpbnRlcnBvbGF0aW9uIHNwZWNpZmljYXRpb25cblx0XHRcdCAqIGJhc2ljYWxseSBkaXNhbGxvd3MgdHJhbnNpdGlvbnMgb2Ygbm9uLWludmVydGlibGVcblx0XHRcdCAqIG1hdHJpeGVzLCB3aGljaCBtZWFucyBicm93c2VycyB3b24ndCB0cmFuc2l0aW9uXG5cdFx0XHQgKiBlbGVtZW50cyB3aXRoIHplcm8gc2NhbGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhhdOKAmXMgaW5jb252ZW5pZW50IGZvciB0aGUgQVBJIGFuZCBkZXZlbG9wZXJcblx0XHRcdCAqIGV4cGVyaWVuY2UsIHNvIHdlIHNpbXBseSBudWRnZSB0aGVpciB2YWx1ZVxuXHRcdFx0ICogc2xpZ2h0bHkgYWJvdmUgemVybzsgdGhpcyBhbGxvd3MgYnJvd3NlcnNcblx0XHRcdCAqIHRvIHRyYW5zaXRpb24gb3VyIGVsZW1lbnQgYXMgZXhwZWN0ZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogYDAuMDAwMmAgd2FzIHRoZSBzbWFsbGVzdCBudW1iZXJcblx0XHRcdCAqIHRoYXQgcGVyZm9ybWVkIGFjcm9zcyBicm93c2Vycy5cblx0XHRcdCAqL1xuXHRcdFx0dHJhbnNmb3JtYXRpb25zLnB1c2goc2NhbGUoMC4wMDAyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRyYW5zZm9ybWF0aW9ucy5wdXNoKHNjYWxlKGNvbmZpZy5zY2FsZSkpO1xuXHRcdH1cblx0fVxuXG5cdHZhciB0cmFuc2Zvcm0gPSB7fTtcblx0aWYgKHRyYW5zZm9ybWF0aW9ucy5sZW5ndGgpIHtcblx0XHR0cmFuc2Zvcm0ucHJvcGVydHkgPSBnZXRQcmVmaXhlZENzc1Byb3AoJ3RyYW5zZm9ybScpO1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBkZWZhdWx0IGNvbXB1dGVkIHRyYW5zZm9ybSB2YWx1ZSBzaG91bGQgYmUgb25lIG9mOlxuXHRcdCAqIHVuZGVmaW5lZCB8fCAnbm9uZScgfHwgJ21hdHJpeCgpJyB8fCAnbWF0cml4M2QoKSdcblx0XHQgKi9cblx0XHR0cmFuc2Zvcm0uY29tcHV0ZWQgPSB7XG5cdFx0XHRyYXc6IGNvbXB1dGVkW3RyYW5zZm9ybS5wcm9wZXJ0eV0sXG5cdFx0XHRtYXRyaXg6IHBhcnNlKGNvbXB1dGVkW3RyYW5zZm9ybS5wcm9wZXJ0eV0pXG5cdFx0fTtcblxuXHRcdHRyYW5zZm9ybWF0aW9ucy51bnNoaWZ0KHRyYW5zZm9ybS5jb21wdXRlZC5tYXRyaXgpO1xuXHRcdHZhciBwcm9kdWN0ID0gdHJhbnNmb3JtYXRpb25zLnJlZHVjZShtdWx0aXBseSk7XG5cblx0XHR0cmFuc2Zvcm0uZ2VuZXJhdGVkID0ge1xuXHRcdFx0aW5pdGlhbDogKCh0cmFuc2Zvcm0ucHJvcGVydHkpICsgXCI6IG1hdHJpeDNkKFwiICsgKHByb2R1Y3Quam9pbignLCAnKSkgKyBcIik7XCIpLFxuXHRcdFx0ZmluYWw6ICgodHJhbnNmb3JtLnByb3BlcnR5KSArIFwiOiBtYXRyaXgzZChcIiArICh0cmFuc2Zvcm0uY29tcHV0ZWQubWF0cml4LmpvaW4oXG5cdFx0XHRcdCcsICdcblx0XHRcdCkpICsgXCIpO1wiKVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0dHJhbnNmb3JtLmdlbmVyYXRlZCA9IHtcblx0XHRcdGluaXRpYWw6ICcnLFxuXHRcdFx0ZmluYWw6ICcnXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0cmFuc2l0aW9uIHN0eWxlc1xuXHQgKi9cblx0dmFyIHRyYW5zaXRpb24gPSB7fTtcblx0aWYgKG9wYWNpdHkuZ2VuZXJhdGVkIHx8IHRyYW5zZm9ybS5nZW5lcmF0ZWQuaW5pdGlhbCkge1xuXHRcdHRyYW5zaXRpb24ucHJvcGVydHkgPSBnZXRQcmVmaXhlZENzc1Byb3AoJ3RyYW5zaXRpb24nKTtcblx0XHR0cmFuc2l0aW9uLmNvbXB1dGVkID0gY29tcHV0ZWRbdHJhbnNpdGlvbi5wcm9wZXJ0eV07XG5cdFx0dHJhbnNpdGlvbi5mcmFnbWVudHMgPSBbXTtcblxuXHRcdHZhciBkZWxheSA9IGNvbmZpZy5kZWxheTtcblx0XHR2YXIgZHVyYXRpb24gPSBjb25maWcuZHVyYXRpb247XG5cdFx0dmFyIGVhc2luZyA9IGNvbmZpZy5lYXNpbmc7XG5cblx0XHRpZiAob3BhY2l0eS5nZW5lcmF0ZWQpIHtcblx0XHRcdHRyYW5zaXRpb24uZnJhZ21lbnRzLnB1c2goe1xuXHRcdFx0XHRkZWxheWVkOiAoXCJvcGFjaXR5IFwiICsgKGR1cmF0aW9uIC8gMTAwMCkgKyBcInMgXCIgKyBlYXNpbmcgKyBcIiBcIiArIChkZWxheSAvIDEwMDApICsgXCJzXCIpLFxuXHRcdFx0XHRpbnN0YW50OiAoXCJvcGFjaXR5IFwiICsgKGR1cmF0aW9uIC8gMTAwMCkgKyBcInMgXCIgKyBlYXNpbmcgKyBcIiAwc1wiKVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRyYW5zZm9ybS5nZW5lcmF0ZWQuaW5pdGlhbCkge1xuXHRcdFx0dHJhbnNpdGlvbi5mcmFnbWVudHMucHVzaCh7XG5cdFx0XHRcdGRlbGF5ZWQ6ICgodHJhbnNmb3JtLnByb3BlcnR5KSArIFwiIFwiICsgKGR1cmF0aW9uIC8gMTAwMCkgKyBcInMgXCIgKyBlYXNpbmcgKyBcIiBcIiArIChkZWxheSAvXG5cdFx0XHRcdFx0MTAwMCkgKyBcInNcIiksXG5cdFx0XHRcdGluc3RhbnQ6ICgodHJhbnNmb3JtLnByb3BlcnR5KSArIFwiIFwiICsgKGR1cmF0aW9uIC8gMTAwMCkgKyBcInMgXCIgKyBlYXNpbmcgKyBcIiAwc1wiKVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlZmF1bHQgY29tcHV0ZWQgdHJhbnNpdGlvbiBwcm9wZXJ0eSBzaG91bGQgYmUgb25lIG9mOlxuXHRcdCAqIHVuZGVmaW5lZCB8fCAnJyB8fCAnYWxsIDBzIGVhc2UgMHMnIHx8ICdhbGwgMHMgMHMgY3ViaWMtYmV6aWVyKCknXG5cdFx0ICovXG5cdFx0aWYgKHRyYW5zaXRpb24uY29tcHV0ZWQgJiYgIXRyYW5zaXRpb24uY29tcHV0ZWQubWF0Y2goL2FsbCAwcy8pKSB7XG5cdFx0XHR0cmFuc2l0aW9uLmZyYWdtZW50cy51bnNoaWZ0KHtcblx0XHRcdFx0ZGVsYXllZDogdHJhbnNpdGlvbi5jb21wdXRlZCxcblx0XHRcdFx0aW5zdGFudDogdHJhbnNpdGlvbi5jb21wdXRlZFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbXBvc2VkID0gdHJhbnNpdGlvbi5mcmFnbWVudHMucmVkdWNlKFxuXHRcdFx0ZnVuY3Rpb24gKGNvbXBvc2l0aW9uLCBmcmFnbWVudCwgaSkge1xuXHRcdFx0XHRjb21wb3NpdGlvbi5kZWxheWVkICs9XG5cdFx0XHRcdFx0aSA9PT0gMCA/IGZyYWdtZW50LmRlbGF5ZWQgOiAoXCIsIFwiICsgKGZyYWdtZW50LmRlbGF5ZWQpKTtcblx0XHRcdFx0Y29tcG9zaXRpb24uaW5zdGFudCArPVxuXHRcdFx0XHRcdGkgPT09IDAgPyBmcmFnbWVudC5pbnN0YW50IDogKFwiLCBcIiArIChmcmFnbWVudC5pbnN0YW50KSk7XG5cdFx0XHRcdHJldHVybiBjb21wb3NpdGlvblxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZGVsYXllZDogJycsXG5cdFx0XHRcdGluc3RhbnQ6ICcnXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdHRyYW5zaXRpb24uZ2VuZXJhdGVkID0ge1xuXHRcdFx0ZGVsYXllZDogKCh0cmFuc2l0aW9uLnByb3BlcnR5KSArIFwiOiBcIiArIChjb21wb3NlZC5kZWxheWVkKSArIFwiO1wiKSxcblx0XHRcdGluc3RhbnQ6ICgodHJhbnNpdGlvbi5wcm9wZXJ0eSkgKyBcIjogXCIgKyAoY29tcG9zZWQuaW5zdGFudCkgKyBcIjtcIilcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHRyYW5zaXRpb24uZ2VuZXJhdGVkID0ge1xuXHRcdFx0ZGVsYXllZDogJycsXG5cdFx0XHRpbnN0YW50OiAnJ1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGlubGluZTogaW5saW5lLFxuXHRcdG9wYWNpdHk6IG9wYWNpdHksXG5cdFx0cG9zaXRpb246IHBvc2l0aW9uLFxuXHRcdHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuXHRcdHRyYW5zaXRpb246IHRyYW5zaXRpb25cblx0fVxufVxuXG5mdW5jdGlvbiBhbmltYXRlKGVsZW1lbnQsIGZvcmNlKSB7XG5cdGlmICggZm9yY2UgPT09IHZvaWQgMCApIGZvcmNlID0ge307XG5cblx0dmFyIHByaXN0aW5lID0gZm9yY2UucHJpc3RpbmUgfHwgdGhpcy5wcmlzdGluZTtcblx0dmFyIGRlbGF5ZWQgPVxuXHRcdGVsZW1lbnQuY29uZmlnLnVzZURlbGF5ID09PSAnYWx3YXlzJyB8fFxuXHRcdChlbGVtZW50LmNvbmZpZy51c2VEZWxheSA9PT0gJ29ubG9hZCcgJiYgcHJpc3RpbmUpIHx8XG5cdFx0KGVsZW1lbnQuY29uZmlnLnVzZURlbGF5ID09PSAnb25jZScgJiYgIWVsZW1lbnQuc2Vlbik7XG5cblx0dmFyIHNob3VsZFJldmVhbCA9IGVsZW1lbnQudmlzaWJsZSAmJiAhZWxlbWVudC5yZXZlYWxlZDtcblx0dmFyIHNob3VsZFJlc2V0ID0gIWVsZW1lbnQudmlzaWJsZSAmJiBlbGVtZW50LnJldmVhbGVkICYmIGVsZW1lbnQuY29uZmlnLnJlc2V0O1xuXG5cdGlmIChmb3JjZS5yZXZlYWwgfHwgc2hvdWxkUmV2ZWFsKSB7XG5cdFx0cmV0dXJuIHRyaWdnZXJSZXZlYWwuY2FsbCh0aGlzLCBlbGVtZW50LCBkZWxheWVkKVxuXHR9XG5cblx0aWYgKGZvcmNlLnJlc2V0IHx8IHNob3VsZFJlc2V0KSB7XG5cdFx0cmV0dXJuIHRyaWdnZXJSZXNldC5jYWxsKHRoaXMsIGVsZW1lbnQpXG5cdH1cbn1cblxuZnVuY3Rpb24gdHJpZ2dlclJldmVhbChlbGVtZW50LCBkZWxheWVkKSB7XG5cdHZhciBzdHlsZXMgPSBbXG5cdFx0ZWxlbWVudC5zdHlsZXMuaW5saW5lLmdlbmVyYXRlZCxcblx0XHRlbGVtZW50LnN0eWxlcy5vcGFjaXR5LmNvbXB1dGVkLFxuXHRcdGVsZW1lbnQuc3R5bGVzLnRyYW5zZm9ybS5nZW5lcmF0ZWQuZmluYWxcblx0XTtcblx0aWYgKGRlbGF5ZWQpIHtcblx0XHRzdHlsZXMucHVzaChlbGVtZW50LnN0eWxlcy50cmFuc2l0aW9uLmdlbmVyYXRlZC5kZWxheWVkKTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZXMucHVzaChlbGVtZW50LnN0eWxlcy50cmFuc2l0aW9uLmdlbmVyYXRlZC5pbnN0YW50KTtcblx0fVxuXHRlbGVtZW50LnJldmVhbGVkID0gZWxlbWVudC5zZWVuID0gdHJ1ZTtcblx0ZWxlbWVudC5ub2RlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzICE9PSAnJzsgfSkuam9pbignICcpKTtcblx0cmVnaXN0ZXJDYWxsYmFja3MuY2FsbCh0aGlzLCBlbGVtZW50LCBkZWxheWVkKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlclJlc2V0KGVsZW1lbnQpIHtcblx0dmFyIHN0eWxlcyA9IFtcblx0XHRlbGVtZW50LnN0eWxlcy5pbmxpbmUuZ2VuZXJhdGVkLFxuXHRcdGVsZW1lbnQuc3R5bGVzLm9wYWNpdHkuZ2VuZXJhdGVkLFxuXHRcdGVsZW1lbnQuc3R5bGVzLnRyYW5zZm9ybS5nZW5lcmF0ZWQuaW5pdGlhbCxcblx0XHRlbGVtZW50LnN0eWxlcy50cmFuc2l0aW9uLmdlbmVyYXRlZC5pbnN0YW50XG5cdF07XG5cdGVsZW1lbnQucmV2ZWFsZWQgPSBmYWxzZTtcblx0ZWxlbWVudC5ub2RlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZXMuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzICE9PSAnJzsgfSkuam9pbignICcpKTtcblx0cmVnaXN0ZXJDYWxsYmFja3MuY2FsbCh0aGlzLCBlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJDYWxsYmFja3MoZWxlbWVudCwgaXNEZWxheWVkKSB7XG5cdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdHZhciBkdXJhdGlvbiA9IGlzRGVsYXllZFxuXHRcdD8gZWxlbWVudC5jb25maWcuZHVyYXRpb24gKyBlbGVtZW50LmNvbmZpZy5kZWxheVxuXHRcdDogZWxlbWVudC5jb25maWcuZHVyYXRpb247XG5cblx0dmFyIGJlZm9yZUNhbGxiYWNrID0gZWxlbWVudC5yZXZlYWxlZFxuXHRcdD8gZWxlbWVudC5jb25maWcuYmVmb3JlUmV2ZWFsXG5cdFx0OiBlbGVtZW50LmNvbmZpZy5iZWZvcmVSZXNldDtcblxuXHR2YXIgYWZ0ZXJDYWxsYmFjayA9IGVsZW1lbnQucmV2ZWFsZWRcblx0XHQ/IGVsZW1lbnQuY29uZmlnLmFmdGVyUmV2ZWFsXG5cdFx0OiBlbGVtZW50LmNvbmZpZy5hZnRlclJlc2V0O1xuXG5cdHZhciBlbGFwc2VkID0gMDtcblx0aWYgKGVsZW1lbnQuY2FsbGJhY2tUaW1lcikge1xuXHRcdGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gZWxlbWVudC5jYWxsYmFja1RpbWVyLnN0YXJ0O1xuXHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoZWxlbWVudC5jYWxsYmFja1RpbWVyLmNsb2NrKTtcblx0fVxuXG5cdGJlZm9yZUNhbGxiYWNrKGVsZW1lbnQubm9kZSk7XG5cblx0ZWxlbWVudC5jYWxsYmFja1RpbWVyID0ge1xuXHRcdHN0YXJ0OiBEYXRlLm5vdygpLFxuXHRcdGNsb2NrOiB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRhZnRlckNhbGxiYWNrKGVsZW1lbnQubm9kZSk7XG5cdFx0XHRlbGVtZW50LmNhbGxiYWNrVGltZXIgPSBudWxsO1xuXHRcdFx0aWYgKGVsZW1lbnQucmV2ZWFsZWQgJiYgIWVsZW1lbnQuY29uZmlnLnJlc2V0ICYmIGVsZW1lbnQuY29uZmlnLmNsZWFudXApIHtcblx0XHRcdFx0Y2xlYW4uY2FsbCh0aGlzJDEsIGVsZW1lbnQubm9kZSk7XG5cdFx0XHR9XG5cdFx0fSwgZHVyYXRpb24gLSBlbGFwc2VkKVxuXHR9O1xufVxuXG52YXIgbmV4dFVuaXF1ZUlkID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHVpZCA9IDA7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB1aWQrKzsgfVxufSkoKTtcblxuZnVuY3Rpb24gc2VxdWVuY2UoZWxlbWVudCwgcHJpc3RpbmUpIHtcblx0aWYgKCBwcmlzdGluZSA9PT0gdm9pZCAwICkgcHJpc3RpbmUgPSB0aGlzLnByaXN0aW5lO1xuXG5cdC8qKlxuXHQgKiBXZSBmaXJzdCBjaGVjayBpZiB0aGUgZWxlbWVudCBzaG91bGQgcmVzZXQuXG5cdCAqL1xuXHRpZiAoIWVsZW1lbnQudmlzaWJsZSAmJiBlbGVtZW50LnJldmVhbGVkICYmIGVsZW1lbnQuY29uZmlnLnJlc2V0KSB7XG5cdFx0cmV0dXJuIGFuaW1hdGUuY2FsbCh0aGlzLCBlbGVtZW50LCB7IHJlc2V0OiB0cnVlIH0pXG5cdH1cblxuXHR2YXIgc2VxID0gdGhpcy5zdG9yZS5zZXF1ZW5jZXNbZWxlbWVudC5zZXF1ZW5jZS5pZF07XG5cdHZhciBpID0gZWxlbWVudC5zZXF1ZW5jZS5pbmRleDtcblxuXHRpZiAoc2VxKSB7XG5cdFx0dmFyIHZpc2libGUgPSBuZXcgU2VxdWVuY2VNb2RlbChzZXEsICd2aXNpYmxlJywgdGhpcy5zdG9yZSk7XG5cdFx0dmFyIHJldmVhbGVkID0gbmV3IFNlcXVlbmNlTW9kZWwoc2VxLCAncmV2ZWFsZWQnLCB0aGlzLnN0b3JlKTtcblxuXHRcdHNlcS5tb2RlbHMgPSB7IHZpc2libGU6IHZpc2libGUsIHJldmVhbGVkOiByZXZlYWxlZCB9O1xuXG5cdFx0LyoqXG5cdFx0ICogSWYgdGhlIHNlcXVlbmNlIGhhcyBubyByZXZlYWxlZCBtZW1iZXJzLFxuXHRcdCAqIHRoZW4gd2UgcmV2ZWFsIHRoZSBmaXJzdCB2aXNpYmxlIGVsZW1lbnRcblx0XHQgKiB3aXRoaW4gdGhhdCBzZXF1ZW5jZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBzZXF1ZW5jZSB0aGVuIGN1ZXMgYSByZWN1cnNpdmUgY2FsbFxuXHRcdCAqIGluIGJvdGggZGlyZWN0aW9ucy5cblx0XHQgKi9cblx0XHRpZiAoIXJldmVhbGVkLmJvZHkubGVuZ3RoKSB7XG5cdFx0XHR2YXIgbmV4dElkID0gc2VxLm1lbWJlcnNbdmlzaWJsZS5ib2R5WzBdXTtcblx0XHRcdHZhciBuZXh0RWxlbWVudCA9IHRoaXMuc3RvcmUuZWxlbWVudHNbbmV4dElkXTtcblxuXHRcdFx0aWYgKG5leHRFbGVtZW50KSB7XG5cdFx0XHRcdGN1ZS5jYWxsKHRoaXMsIHNlcSwgdmlzaWJsZS5ib2R5WzBdLCAtMSwgcHJpc3RpbmUpO1xuXHRcdFx0XHRjdWUuY2FsbCh0aGlzLCBzZXEsIHZpc2libGUuYm9keVswXSwgKzEsIHByaXN0aW5lKTtcblx0XHRcdFx0cmV0dXJuIGFuaW1hdGUuY2FsbCh0aGlzLCBuZXh0RWxlbWVudCwgeyByZXZlYWw6IHRydWUsIHByaXN0aW5lOiBwcmlzdGluZSB9KVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIElmIG91ciBlbGVtZW50IGlzbuKAmXQgcmVzZXR0aW5nLCB3ZSBjaGVjayB0aGVcblx0XHQgKiBlbGVtZW50IHNlcXVlbmNlIGluZGV4IGFnYWluc3QgdGhlIGhlYWQsIGFuZFxuXHRcdCAqIHRoZW4gdGhlIGZvb3Qgb2YgdGhlIHNlcXVlbmNlLlxuXHRcdCAqL1xuXHRcdGlmIChcblx0XHRcdCFzZXEuYmxvY2tlZC5oZWFkICYmXG5cdFx0XHRpID09PSBbXS5jb25jYXQoIHJldmVhbGVkLmhlYWQgKS5wb3AoKSAmJlxuXHRcdFx0aSA+PSBbXS5jb25jYXQoIHZpc2libGUuYm9keSApLnNoaWZ0KClcblx0XHQpIHtcblx0XHRcdGN1ZS5jYWxsKHRoaXMsIHNlcSwgaSwgLTEsIHByaXN0aW5lKTtcblx0XHRcdHJldHVybiBhbmltYXRlLmNhbGwodGhpcywgZWxlbWVudCwgeyByZXZlYWw6IHRydWUsIHByaXN0aW5lOiBwcmlzdGluZSB9KVxuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdCFzZXEuYmxvY2tlZC5mb290ICYmXG5cdFx0XHRpID09PSBbXS5jb25jYXQoIHJldmVhbGVkLmZvb3QgKS5zaGlmdCgpICYmXG5cdFx0XHRpIDw9IFtdLmNvbmNhdCggdmlzaWJsZS5ib2R5ICkucG9wKClcblx0XHQpIHtcblx0XHRcdGN1ZS5jYWxsKHRoaXMsIHNlcSwgaSwgKzEsIHByaXN0aW5lKTtcblx0XHRcdHJldHVybiBhbmltYXRlLmNhbGwodGhpcywgZWxlbWVudCwgeyByZXZlYWw6IHRydWUsIHByaXN0aW5lOiBwcmlzdGluZSB9KVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBTZXF1ZW5jZShpbnRlcnZhbCkge1xuXHR2YXIgaSA9IE1hdGguYWJzKGludGVydmFsKTtcblx0aWYgKCFpc05hTihpKSkge1xuXHRcdHRoaXMuaWQgPSBuZXh0VW5pcXVlSWQoKTtcblx0XHR0aGlzLmludGVydmFsID0gTWF0aC5tYXgoaSwgMTYpO1xuXHRcdHRoaXMubWVtYmVycyA9IFtdO1xuXHRcdHRoaXMubW9kZWxzID0ge307XG5cdFx0dGhpcy5ibG9ja2VkID0ge1xuXHRcdFx0aGVhZDogZmFsc2UsXG5cdFx0XHRmb290OiBmYWxzZVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc2VxdWVuY2UgaW50ZXJ2YWwuJylcblx0fVxufVxuXG5mdW5jdGlvbiBTZXF1ZW5jZU1vZGVsKHNlcSwgcHJvcCwgc3RvcmUpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0dGhpcy5oZWFkID0gW107XG5cdHRoaXMuYm9keSA9IFtdO1xuXHR0aGlzLmZvb3QgPSBbXTtcblxuXHRlYWNoKHNlcS5tZW1iZXJzLCBmdW5jdGlvbiAoaWQsIGluZGV4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSBzdG9yZS5lbGVtZW50c1tpZF07XG5cdFx0aWYgKGVsZW1lbnQgJiYgZWxlbWVudFtwcm9wXSkge1xuXHRcdFx0dGhpcyQxLmJvZHkucHVzaChpbmRleCk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAodGhpcy5ib2R5Lmxlbmd0aCkge1xuXHRcdGVhY2goc2VxLm1lbWJlcnMsIGZ1bmN0aW9uIChpZCwgaW5kZXgpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gc3RvcmUuZWxlbWVudHNbaWRdO1xuXHRcdFx0aWYgKGVsZW1lbnQgJiYgIWVsZW1lbnRbcHJvcF0pIHtcblx0XHRcdFx0aWYgKGluZGV4IDwgdGhpcyQxLmJvZHlbMF0pIHtcblx0XHRcdFx0XHR0aGlzJDEuaGVhZC5wdXNoKGluZGV4KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzJDEuZm9vdC5wdXNoKGluZGV4KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGN1ZShzZXEsIGksIGRpcmVjdGlvbiwgcHJpc3RpbmUpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0dmFyIGJsb2NrZWQgPSBbJ2hlYWQnLCBudWxsLCAnZm9vdCddWzEgKyBkaXJlY3Rpb25dO1xuXHR2YXIgbmV4dElkID0gc2VxLm1lbWJlcnNbaSArIGRpcmVjdGlvbl07XG5cdHZhciBuZXh0RWxlbWVudCA9IHRoaXMuc3RvcmUuZWxlbWVudHNbbmV4dElkXTtcblxuXHRzZXEuYmxvY2tlZFtibG9ja2VkXSA9IHRydWU7XG5cblx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0c2VxLmJsb2NrZWRbYmxvY2tlZF0gPSBmYWxzZTtcblx0XHRpZiAobmV4dEVsZW1lbnQpIHtcblx0XHRcdHNlcXVlbmNlLmNhbGwodGhpcyQxLCBuZXh0RWxlbWVudCwgcHJpc3RpbmUpO1xuXHRcdH1cblx0fSwgc2VxLmludGVydmFsKTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0cmluc2UuY2FsbCh0aGlzKTtcblxuXHRlYWNoKHRoaXMuc3RvcmUuZWxlbWVudHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0dmFyIHN0eWxlcyA9IFtlbGVtZW50LnN0eWxlcy5pbmxpbmUuZ2VuZXJhdGVkXTtcblxuXHRcdGlmIChlbGVtZW50LnZpc2libGUpIHtcblx0XHRcdHN0eWxlcy5wdXNoKGVsZW1lbnQuc3R5bGVzLm9wYWNpdHkuY29tcHV0ZWQpO1xuXHRcdFx0c3R5bGVzLnB1c2goZWxlbWVudC5zdHlsZXMudHJhbnNmb3JtLmdlbmVyYXRlZC5maW5hbCk7XG5cdFx0XHRlbGVtZW50LnJldmVhbGVkID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGVzLnB1c2goZWxlbWVudC5zdHlsZXMub3BhY2l0eS5nZW5lcmF0ZWQpO1xuXHRcdFx0c3R5bGVzLnB1c2goZWxlbWVudC5zdHlsZXMudHJhbnNmb3JtLmdlbmVyYXRlZC5pbml0aWFsKTtcblx0XHRcdGVsZW1lbnQucmV2ZWFsZWQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHRlbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdzdHlsZScsIHN0eWxlcy5maWx0ZXIoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMgIT09ICcnOyB9KS5qb2luKCcgJykpO1xuXHR9KTtcblxuXHRlYWNoKHRoaXMuc3RvcmUuY29udGFpbmVycywgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdHZhciB0YXJnZXQgPVxuXHRcdFx0Y29udGFpbmVyLm5vZGUgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/IHdpbmRvdyA6IGNvbnRhaW5lci5ub2RlO1xuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzJDEuZGVsZWdhdGUpO1xuXHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzJDEuZGVsZWdhdGUpO1xuXHR9KTtcblxuXHQvKipcblx0ICogTWFudWFsbHkgaW52b2tlIGRlbGVnYXRlIG9uY2UgdG8gY2FwdHVyZVxuXHQgKiBlbGVtZW50IGFuZCBjb250YWluZXIgZGltZW5zaW9ucywgY29udGFpbmVyXG5cdCAqIHNjcm9sbCBwb3NpdGlvbiwgYW5kIHRyaWdnZXIgYW55IHZhbGlkIHJldmVhbHNcblx0ICovXG5cdHRoaXMuZGVsZWdhdGUoKTtcblxuXHQvKipcblx0ICogV2lwZSBhbnkgZXhpc3RpbmcgYHNldFRpbWVvdXRgIG5vd1xuXHQgKiB0aGF0IGluaXRpYWxpemF0aW9uIGhhcyBjb21wbGV0ZWQuXG5cdCAqL1xuXHR0aGlzLmluaXRUaW1lb3V0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNNb2JpbGUoYWdlbnQpIHtcblx0aWYgKCBhZ2VudCA9PT0gdm9pZCAwICkgYWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG5cdHJldHVybiAvQW5kcm9pZHxpUGhvbmV8aVBhZHxpUG9kL2kudGVzdChhZ2VudClcbn1cblxuZnVuY3Rpb24gZGVlcEFzc2lnbih0YXJnZXQpIHtcblx0dmFyIHNvdXJjZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cdHdoaWxlICggbGVuLS0gPiAwICkgc291cmNlc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuXHRpZiAoaXNPYmplY3QodGFyZ2V0KSkge1xuXHRcdGVhY2goc291cmNlcywgZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0ZWFjaChzb3VyY2UsIGZ1bmN0aW9uIChkYXRhLCBrZXkpIHtcblx0XHRcdFx0aWYgKGlzT2JqZWN0KGRhdGEpKSB7XG5cdFx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XSB8fCAhaXNPYmplY3QodGFyZ2V0W2tleV0pKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWVwQXNzaWduKHRhcmdldFtrZXldLCBkYXRhKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IGRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHJldHVybiB0YXJnZXRcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUYXJnZXQgbXVzdCBiZSBhbiBvYmplY3QgbGl0ZXJhbC4nKVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJldmVhbCh0YXJnZXQsIG9wdGlvbnMsIHN5bmNpbmcpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXHRpZiAoIHN5bmNpbmcgPT09IHZvaWQgMCApIHN5bmNpbmcgPSBmYWxzZTtcblxuXHR2YXIgY29udGFpbmVyQnVmZmVyID0gW107XG5cdHZhciBzZXF1ZW5jZSQkMTtcblx0dmFyIGludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbCB8fCBkZWZhdWx0cy5pbnRlcnZhbDtcblxuXHR0cnkge1xuXHRcdGlmIChpbnRlcnZhbCkge1xuXHRcdFx0c2VxdWVuY2UkJDEgPSBuZXcgU2VxdWVuY2UoaW50ZXJ2YWwpO1xuXHRcdH1cblxuXHRcdHZhciBub2RlcyA9IHRlYWxpZ2h0KHRhcmdldCk7XG5cdFx0aWYgKCFub2Rlcy5sZW5ndGgpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXZlYWwgdGFyZ2V0LicpXG5cdFx0fVxuXG5cdFx0dmFyIGVsZW1lbnRzID0gbm9kZXMucmVkdWNlKGZ1bmN0aW9uIChlbGVtZW50QnVmZmVyLCBlbGVtZW50Tm9kZSkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB7fTtcblx0XHRcdHZhciBleGlzdGluZ0lkID0gZWxlbWVudE5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXNyLWlkJyk7XG5cblx0XHRcdGlmIChleGlzdGluZ0lkKSB7XG5cdFx0XHRcdGRlZXBBc3NpZ24oZWxlbWVudCwgdGhpcyQxLnN0b3JlLmVsZW1lbnRzW2V4aXN0aW5nSWRdKTtcblxuXHRcdFx0XHQvKipcblx0XHRcdFx0ICogSW4gb3JkZXIgdG8gcHJldmVudCBwcmV2aW91c2x5IGdlbmVyYXRlZCBzdHlsZXNcblx0XHRcdFx0ICogZnJvbSB0aHJvd2luZyBvZmYgdGhlIG5ldyBzdHlsZXMsIHRoZSBzdHlsZSB0YWdcblx0XHRcdFx0ICogaGFzIHRvIGJlIHJldmVydGVkIHRvIGl0cyBwcmUtcmV2ZWFsIHN0YXRlLlxuXHRcdFx0XHQgKi9cblx0XHRcdFx0ZWxlbWVudC5ub2RlLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBlbGVtZW50LnN0eWxlcy5pbmxpbmUuY29tcHV0ZWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudC5pZCA9IG5leHRVbmlxdWVJZCgpO1xuXHRcdFx0XHRlbGVtZW50Lm5vZGUgPSBlbGVtZW50Tm9kZTtcblx0XHRcdFx0ZWxlbWVudC5zZWVuID0gZmFsc2U7XG5cdFx0XHRcdGVsZW1lbnQucmV2ZWFsZWQgPSBmYWxzZTtcblx0XHRcdFx0ZWxlbWVudC52aXNpYmxlID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb25maWcgPSBkZWVwQXNzaWduKHt9LCBlbGVtZW50LmNvbmZpZyB8fCB0aGlzJDEuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG5cdFx0XHRpZiAoKCFjb25maWcubW9iaWxlICYmIGlzTW9iaWxlKCkpIHx8ICghY29uZmlnLmRlc2t0b3AgJiYgIWlzTW9iaWxlKCkpKSB7XG5cdFx0XHRcdGlmIChleGlzdGluZ0lkKSB7XG5cdFx0XHRcdFx0Y2xlYW4uY2FsbCh0aGlzJDEsIGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBlbGVtZW50QnVmZmVyIC8vIHNraXAgZWxlbWVudHMgdGhhdCBhcmUgZGlzYWJsZWRcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvbnRhaW5lck5vZGUgPSB0ZWFsaWdodChjb25maWcuY29udGFpbmVyKVswXTtcblx0XHRcdGlmICghY29udGFpbmVyTm9kZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29udGFpbmVyLicpXG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbnRhaW5lck5vZGUuY29udGFpbnMoZWxlbWVudE5vZGUpKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50QnVmZmVyIC8vIHNraXAgZWxlbWVudHMgZm91bmQgb3V0c2lkZSB0aGUgY29udGFpbmVyXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb250YWluZXJJZDtcblx0XHRcdHtcblx0XHRcdFx0Y29udGFpbmVySWQgPSBnZXRDb250YWluZXJJZChcblx0XHRcdFx0XHRjb250YWluZXJOb2RlLFxuXHRcdFx0XHRcdGNvbnRhaW5lckJ1ZmZlcixcblx0XHRcdFx0XHR0aGlzJDEuc3RvcmUuY29udGFpbmVyc1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRpZiAoY29udGFpbmVySWQgPT09IG51bGwpIHtcblx0XHRcdFx0XHRjb250YWluZXJJZCA9IG5leHRVbmlxdWVJZCgpO1xuXHRcdFx0XHRcdGNvbnRhaW5lckJ1ZmZlci5wdXNoKHsgaWQ6IGNvbnRhaW5lcklkLCBub2RlOiBjb250YWluZXJOb2RlIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnQuY29uZmlnID0gY29uZmlnO1xuXHRcdFx0ZWxlbWVudC5jb250YWluZXJJZCA9IGNvbnRhaW5lcklkO1xuXHRcdFx0ZWxlbWVudC5zdHlsZXMgPSBzdHlsZShlbGVtZW50KTtcblxuXHRcdFx0aWYgKHNlcXVlbmNlJCQxKSB7XG5cdFx0XHRcdGVsZW1lbnQuc2VxdWVuY2UgPSB7XG5cdFx0XHRcdFx0aWQ6IHNlcXVlbmNlJCQxLmlkLFxuXHRcdFx0XHRcdGluZGV4OiBzZXF1ZW5jZSQkMS5tZW1iZXJzLmxlbmd0aFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRzZXF1ZW5jZSQkMS5tZW1iZXJzLnB1c2goZWxlbWVudC5pZCk7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnRCdWZmZXIucHVzaChlbGVtZW50KTtcblx0XHRcdHJldHVybiBlbGVtZW50QnVmZmVyXG5cdFx0fSwgW10pO1xuXG5cdFx0LyoqXG5cdFx0ICogTW9kaWZ5aW5nIHRoZSBET00gdmlhIHNldEF0dHJpYnV0ZSBuZWVkcyB0byBiZSBoYW5kbGVkXG5cdFx0ICogc2VwYXJhdGVseSBmcm9tIHJlYWRpbmcgY29tcHV0ZWQgc3R5bGVzIGluIHRoZSBtYXAgYWJvdmVcblx0XHQgKiBmb3IgdGhlIGJyb3dzZXIgdG8gYmF0Y2ggRE9NIGNoYW5nZXMgKGxpbWl0aW5nIHJlZmxvd3MpXG5cdFx0ICovXG5cdFx0ZWFjaChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdHRoaXMkMS5zdG9yZS5lbGVtZW50c1tlbGVtZW50LmlkXSA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXNyLWlkJywgZWxlbWVudC5pZCk7XG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gbG9nZ2VyLmNhbGwodGhpcywgJ1JldmVhbCBmYWlsZWQuJywgZS5tZXNzYWdlKVxuXHR9XG5cblx0LyoqXG5cdCAqIE5vdyB0aGF0IGVsZW1lbnQgc2V0LXVwIGlzIGNvbXBsZXRlLi4uXG5cdCAqIExldOKAmXMgY29tbWl0IGFueSBjb250YWluZXIgYW5kIHNlcXVlbmNlIGRhdGEgd2UgaGF2ZSB0byB0aGUgc3RvcmUuXG5cdCAqL1xuXHRlYWNoKGNvbnRhaW5lckJ1ZmZlciwgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdHRoaXMkMS5zdG9yZS5jb250YWluZXJzW2NvbnRhaW5lci5pZF0gPSB7XG5cdFx0XHRpZDogY29udGFpbmVyLmlkLFxuXHRcdFx0bm9kZTogY29udGFpbmVyLm5vZGVcblx0XHR9O1xuXHR9KTtcblx0aWYgKHNlcXVlbmNlJCQxKSB7XG5cdFx0dGhpcy5zdG9yZS5zZXF1ZW5jZXNbc2VxdWVuY2UkJDEuaWRdID0gc2VxdWVuY2UkJDE7XG5cdH1cblxuXHQvKipcblx0ICogSWYgcmV2ZWFsIHdhc24ndCBpbnZva2VkIGJ5IHN5bmMsIHdlIHdhbnQgdG9cblx0ICogbWFrZSBzdXJlIHRvIGFkZCB0aGlzIGNhbGwgdG8gdGhlIGhpc3RvcnkuXG5cdCAqL1xuXHRpZiAoc3luY2luZyAhPT0gdHJ1ZSkge1xuXHRcdHRoaXMuc3RvcmUuaGlzdG9yeS5wdXNoKHsgdGFyZ2V0OiB0YXJnZXQsIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG5cblx0XHQvKipcblx0XHQgKiBQdXNoIGluaXRpYWxpemF0aW9uIHRvIHRoZSBldmVudCBxdWV1ZSwgZ2l2aW5nXG5cdFx0ICogbXVsdGlwbGUgcmV2ZWFsIGNhbGxzIHRpbWUgdG8gYmUgaW50ZXJwcmV0ZWQuXG5cdFx0ICovXG5cdFx0aWYgKHRoaXMuaW5pdFRpbWVvdXQpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5pbml0VGltZW91dCk7XG5cdFx0fVxuXHRcdHRoaXMuaW5pdFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChpbml0aWFsaXplLmJpbmQodGhpcyksIDApO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcklkKG5vZGUpIHtcblx0dmFyIGNvbGxlY3Rpb25zID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuXHR3aGlsZSAoIGxlbi0tID4gMCApIGNvbGxlY3Rpb25zWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG5cdHZhciBpZCA9IG51bGw7XG5cdGVhY2goY29sbGVjdGlvbnMsIGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG5cdFx0ZWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG5cdFx0XHRpZiAoaWQgPT09IG51bGwgJiYgY29udGFpbmVyLm5vZGUgPT09IG5vZGUpIHtcblx0XHRcdFx0aWQgPSBjb250YWluZXIuaWQ7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gaWRcbn1cblxuLyoqXG4gKiBSZS1ydW5zIHRoZSByZXZlYWwgbWV0aG9kIGZvciBlYWNoIHJlY29yZCBzdG9yZWQgaW4gaGlzdG9yeSxcbiAqIGZvciBjYXB0dXJpbmcgbmV3IGNvbnRlbnQgYXN5bmNocm9ub3VzbHkgbG9hZGVkIGludG8gdGhlIERPTS5cbiAqL1xuZnVuY3Rpb24gc3luYygpIHtcblx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ZWFjaCh0aGlzLnN0b3JlLmhpc3RvcnksIGZ1bmN0aW9uIChyZWNvcmQpIHtcblx0XHRyZXZlYWwuY2FsbCh0aGlzJDEsIHJlY29yZC50YXJnZXQsIHJlY29yZC5vcHRpb25zLCB0cnVlKTtcblx0fSk7XG5cblx0aW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xufVxuXG52YXIgcG9seWZpbGwgPSBmdW5jdGlvbiAoeCkgeyByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7IH07XG52YXIgbWF0aFNpZ24gPSBNYXRoLnNpZ24gfHwgcG9seWZpbGxcblxuLyohIEBsaWNlbnNlIG1pbmlyYWYgdjEuMC4wXG5cblx0Q29weXJpZ2h0IDIwMTggRmlzc3Npb24gTExDLlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcblx0b2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuXHRpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG5cdHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcblx0Y29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5cdGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5cdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0RklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0TElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcblx0T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblx0U09GVFdBUkUuXG5cbiovXG52YXIgcG9seWZpbGwkMSA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciBjbG9jayA9IERhdGUubm93KCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdHZhciBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG5cdFx0aWYgKGN1cnJlbnRUaW1lIC0gY2xvY2sgPiAxNikge1xuXHRcdFx0Y2xvY2sgPSBjdXJyZW50VGltZTtcblx0XHRcdGNhbGxiYWNrKGN1cnJlbnRUaW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBwb2x5ZmlsbCQxKGNhbGxiYWNrKTsgfSwgMCk7XG5cdFx0fVxuXHR9XG59KSgpO1xuXG52YXIgaW5kZXggPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRwb2x5ZmlsbCQxO1xuXG5mdW5jdGlvbiBnZXRHZW9tZXRyeSh0YXJnZXQsIGlzQ29udGFpbmVyKSB7XG5cdC8qKlxuXHQgKiBXZSB3YW50IHRvIGlnbm9yZSBwYWRkaW5nIGFuZCBzY3JvbGxiYXJzIGZvciBjb250YWluZXIgZWxlbWVudHMuXG5cdCAqIE1vcmUgaW5mb3JtYXRpb24gaGVyZTogaHR0cHM6Ly9nb28uZ2wvdk9acGJ6XG5cdCAqL1xuXHR2YXIgaGVpZ2h0ID0gaXNDb250YWluZXIgPyB0YXJnZXQubm9kZS5jbGllbnRIZWlnaHQgOiB0YXJnZXQubm9kZS5vZmZzZXRIZWlnaHQ7XG5cdHZhciB3aWR0aCA9IGlzQ29udGFpbmVyID8gdGFyZ2V0Lm5vZGUuY2xpZW50V2lkdGggOiB0YXJnZXQubm9kZS5vZmZzZXRXaWR0aDtcblxuXHR2YXIgb2Zmc2V0VG9wID0gMDtcblx0dmFyIG9mZnNldExlZnQgPSAwO1xuXHR2YXIgbm9kZSA9IHRhcmdldC5ub2RlO1xuXG5cdGRvIHtcblx0XHRpZiAoIWlzTmFOKG5vZGUub2Zmc2V0VG9wKSkge1xuXHRcdFx0b2Zmc2V0VG9wICs9IG5vZGUub2Zmc2V0VG9wO1xuXHRcdH1cblx0XHRpZiAoIWlzTmFOKG5vZGUub2Zmc2V0TGVmdCkpIHtcblx0XHRcdG9mZnNldExlZnQgKz0gbm9kZS5vZmZzZXRMZWZ0O1xuXHRcdH1cblx0XHRub2RlID0gbm9kZS5vZmZzZXRQYXJlbnQ7XG5cdH0gd2hpbGUgKG5vZGUpXG5cblx0cmV0dXJuIHtcblx0XHRib3VuZHM6IHtcblx0XHRcdHRvcDogb2Zmc2V0VG9wLFxuXHRcdFx0cmlnaHQ6IG9mZnNldExlZnQgKyB3aWR0aCxcblx0XHRcdGJvdHRvbTogb2Zmc2V0VG9wICsgaGVpZ2h0LFxuXHRcdFx0bGVmdDogb2Zmc2V0TGVmdFxuXHRcdH0sXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0d2lkdGg6IHdpZHRoXG5cdH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsZWQoY29udGFpbmVyKSB7XG5cdHZhciB0b3AsIGxlZnQ7XG5cdGlmIChjb250YWluZXIubm9kZSA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG5cdFx0dG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuXHRcdGxlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQ7XG5cdH0gZWxzZSB7XG5cdFx0dG9wID0gY29udGFpbmVyLm5vZGUuc2Nyb2xsVG9wO1xuXHRcdGxlZnQgPSBjb250YWluZXIubm9kZS5zY3JvbGxMZWZ0O1xuXHR9XG5cdHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH1cbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50VmlzaWJsZShlbGVtZW50KSB7XG5cdGlmICggZWxlbWVudCA9PT0gdm9pZCAwICkgZWxlbWVudCA9IHt9O1xuXG5cdHZhciBjb250YWluZXIgPSB0aGlzLnN0b3JlLmNvbnRhaW5lcnNbZWxlbWVudC5jb250YWluZXJJZF07XG5cdGlmICghY29udGFpbmVyKSB7IHJldHVybiB9XG5cblx0dmFyIHZpZXdGYWN0b3IgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBlbGVtZW50LmNvbmZpZy52aWV3RmFjdG9yKSk7XG5cdHZhciB2aWV3T2Zmc2V0ID0gZWxlbWVudC5jb25maWcudmlld09mZnNldDtcblxuXHR2YXIgZWxlbWVudEJvdW5kcyA9IHtcblx0XHR0b3A6IGVsZW1lbnQuZ2VvbWV0cnkuYm91bmRzLnRvcCArIGVsZW1lbnQuZ2VvbWV0cnkuaGVpZ2h0ICogdmlld0ZhY3Rvcixcblx0XHRyaWdodDogZWxlbWVudC5nZW9tZXRyeS5ib3VuZHMucmlnaHQgLSBlbGVtZW50Lmdlb21ldHJ5LndpZHRoICogdmlld0ZhY3Rvcixcblx0XHRib3R0b206IGVsZW1lbnQuZ2VvbWV0cnkuYm91bmRzLmJvdHRvbSAtIGVsZW1lbnQuZ2VvbWV0cnkuaGVpZ2h0ICogdmlld0ZhY3Rvcixcblx0XHRsZWZ0OiBlbGVtZW50Lmdlb21ldHJ5LmJvdW5kcy5sZWZ0ICsgZWxlbWVudC5nZW9tZXRyeS53aWR0aCAqIHZpZXdGYWN0b3Jcblx0fTtcblxuXHR2YXIgY29udGFpbmVyQm91bmRzID0ge1xuXHRcdHRvcDogY29udGFpbmVyLmdlb21ldHJ5LmJvdW5kcy50b3AgKyBjb250YWluZXIuc2Nyb2xsLnRvcCArIHZpZXdPZmZzZXQudG9wLFxuXHRcdHJpZ2h0OiBjb250YWluZXIuZ2VvbWV0cnkuYm91bmRzLnJpZ2h0ICsgY29udGFpbmVyLnNjcm9sbC5sZWZ0IC0gdmlld09mZnNldC5yaWdodCxcblx0XHRib3R0b206XG5cdFx0XHRjb250YWluZXIuZ2VvbWV0cnkuYm91bmRzLmJvdHRvbSArIGNvbnRhaW5lci5zY3JvbGwudG9wIC0gdmlld09mZnNldC5ib3R0b20sXG5cdFx0bGVmdDogY29udGFpbmVyLmdlb21ldHJ5LmJvdW5kcy5sZWZ0ICsgY29udGFpbmVyLnNjcm9sbC5sZWZ0ICsgdmlld09mZnNldC5sZWZ0XG5cdH07XG5cblx0cmV0dXJuIChcblx0XHQoZWxlbWVudEJvdW5kcy50b3AgPCBjb250YWluZXJCb3VuZHMuYm90dG9tICYmXG5cdFx0XHRlbGVtZW50Qm91bmRzLnJpZ2h0ID4gY29udGFpbmVyQm91bmRzLmxlZnQgJiZcblx0XHRcdGVsZW1lbnRCb3VuZHMuYm90dG9tID4gY29udGFpbmVyQm91bmRzLnRvcCAmJlxuXHRcdFx0ZWxlbWVudEJvdW5kcy5sZWZ0IDwgY29udGFpbmVyQm91bmRzLnJpZ2h0KSB8fFxuXHRcdGVsZW1lbnQuc3R5bGVzLnBvc2l0aW9uID09PSAnZml4ZWQnXG5cdClcbn1cblxuZnVuY3Rpb24gZGVsZWdhdGUoXG5cdGV2ZW50LFxuXHRlbGVtZW50c1xuKSB7XG5cdHZhciB0aGlzJDEgPSB0aGlzO1xuXHRpZiAoIGV2ZW50ID09PSB2b2lkIDAgKSBldmVudCA9IHsgdHlwZTogJ2luaXQnIH07XG5cdGlmICggZWxlbWVudHMgPT09IHZvaWQgMCApIGVsZW1lbnRzID0gdGhpcy5zdG9yZS5lbGVtZW50cztcblxuXHRpbmRleChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHN0YWxlID0gZXZlbnQudHlwZSA9PT0gJ2luaXQnIHx8IGV2ZW50LnR5cGUgPT09ICdyZXNpemUnO1xuXG5cdFx0ZWFjaCh0aGlzJDEuc3RvcmUuY29udGFpbmVycywgZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuXHRcdFx0aWYgKHN0YWxlKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5nZW9tZXRyeSA9IGdldEdlb21ldHJ5LmNhbGwodGhpcyQxLCBjb250YWluZXIsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHNjcm9sbCA9IGdldFNjcm9sbGVkLmNhbGwodGhpcyQxLCBjb250YWluZXIpO1xuXHRcdFx0aWYgKGNvbnRhaW5lci5zY3JvbGwpIHtcblx0XHRcdFx0Y29udGFpbmVyLmRpcmVjdGlvbiA9IHtcblx0XHRcdFx0XHR4OiBtYXRoU2lnbihzY3JvbGwubGVmdCAtIGNvbnRhaW5lci5zY3JvbGwubGVmdCksXG5cdFx0XHRcdFx0eTogbWF0aFNpZ24oc2Nyb2xsLnRvcCAtIGNvbnRhaW5lci5zY3JvbGwudG9wKVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Y29udGFpbmVyLnNjcm9sbCA9IHNjcm9sbDtcblx0XHR9KTtcblxuXHRcdC8qKlxuXHRcdCAqIER1ZSB0byBob3cgdGhlIHNlcXVlbmNlciBpcyBpbXBsZW1lbnRlZCwgaXTigJlzXG5cdFx0ICogaW1wb3J0YW50IHRoYXQgd2UgdXBkYXRlIHRoZSBzdGF0ZSBvZiBhbGxcblx0XHQgKiBlbGVtZW50cywgYmVmb3JlIGFueSBhbmltYXRpb24gbG9naWMgaXNcblx0XHQgKiBldmFsdWF0ZWQgKGluIHRoZSBzZWNvbmQgbG9vcCBiZWxvdykuXG5cdFx0ICovXG5cdFx0ZWFjaChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0XHRcdGlmIChzdGFsZSkge1xuXHRcdFx0XHRlbGVtZW50Lmdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkuY2FsbCh0aGlzJDEsIGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudC52aXNpYmxlID0gaXNFbGVtZW50VmlzaWJsZS5jYWxsKHRoaXMkMSwgZWxlbWVudCk7XG5cdFx0fSk7XG5cblx0XHRlYWNoKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0aWYgKGVsZW1lbnQuc2VxdWVuY2UpIHtcblx0XHRcdFx0c2VxdWVuY2UuY2FsbCh0aGlzJDEsIGVsZW1lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YW5pbWF0ZS5jYWxsKHRoaXMkMSwgZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzJDEucHJpc3RpbmUgPSBmYWxzZTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN1cHBvcnRlZCgpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXHRyZXR1cm4gJ3RyYW5zZm9ybScgaW4gc3R5bGUgfHwgJ1dlYmtpdFRyYW5zZm9ybScgaW4gc3R5bGVcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvblN1cHBvcnRlZCgpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXHRyZXR1cm4gJ3RyYW5zaXRpb24nIGluIHN0eWxlIHx8ICdXZWJraXRUcmFuc2l0aW9uJyBpbiBzdHlsZVxufVxuXG52YXIgdmVyc2lvbiA9IFwiNC4wLjVcIjtcblxudmFyIGJvdW5kRGVsZWdhdGU7XG52YXIgYm91bmREZXN0cm95O1xudmFyIGJvdW5kUmV2ZWFsO1xudmFyIGJvdW5kQ2xlYW47XG52YXIgYm91bmRTeW5jO1xudmFyIGNvbmZpZztcbnZhciBkZWJ1ZztcbnZhciBpbnN0YW5jZTtcblxuZnVuY3Rpb24gU2Nyb2xsUmV2ZWFsKG9wdGlvbnMpIHtcblx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cblx0dmFyIGludm9rZWRXaXRob3V0TmV3ID1cblx0XHR0eXBlb2YgdGhpcyA9PT0gJ3VuZGVmaW5lZCcgfHxcblx0XHRPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykgIT09IFNjcm9sbFJldmVhbC5wcm90b3R5cGU7XG5cblx0aWYgKGludm9rZWRXaXRob3V0TmV3KSB7XG5cdFx0cmV0dXJuIG5ldyBTY3JvbGxSZXZlYWwob3B0aW9ucylcblx0fVxuXG5cdGlmICghU2Nyb2xsUmV2ZWFsLmlzU3VwcG9ydGVkKCkpIHtcblx0XHRsb2dnZXIuY2FsbCh0aGlzLCAnSW5zdGFudGlhdGlvbiBmYWlsZWQuJywgJ1RoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdHJldHVybiBtb3VudC5mYWlsdXJlKClcblx0fVxuXG5cdHZhciBidWZmZXI7XG5cdHRyeSB7XG5cdFx0YnVmZmVyID0gY29uZmlnXG5cdFx0XHQ/IGRlZXBBc3NpZ24oe30sIGNvbmZpZywgb3B0aW9ucylcblx0XHRcdDogZGVlcEFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0bG9nZ2VyLmNhbGwodGhpcywgJ0ludmFsaWQgY29uZmlndXJhdGlvbi4nLCBlLm1lc3NhZ2UpO1xuXHRcdHJldHVybiBtb3VudC5mYWlsdXJlKClcblx0fVxuXG5cdHRyeSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRlYWxpZ2h0KGJ1ZmZlci5jb250YWluZXIpWzBdO1xuXHRcdGlmICghY29udGFpbmVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29udGFpbmVyLicpXG5cdFx0fVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0bG9nZ2VyLmNhbGwodGhpcywgZS5tZXNzYWdlKTtcblx0XHRyZXR1cm4gbW91bnQuZmFpbHVyZSgpXG5cdH1cblxuXHRjb25maWcgPSBidWZmZXI7XG5cblx0aWYgKCghY29uZmlnLm1vYmlsZSAmJiBpc01vYmlsZSgpKSB8fCAoIWNvbmZpZy5kZXNrdG9wICYmICFpc01vYmlsZSgpKSkge1xuXHRcdGxvZ2dlci5jYWxsKFxuXHRcdFx0dGhpcyxcblx0XHRcdCdUaGlzIGRldmljZSBpcyBkaXNhYmxlZC4nLFxuXHRcdFx0KFwiZGVza3RvcDogXCIgKyAoY29uZmlnLmRlc2t0b3ApKSxcblx0XHRcdChcIm1vYmlsZTogXCIgKyAoY29uZmlnLm1vYmlsZSkpXG5cdFx0KTtcblx0XHRyZXR1cm4gbW91bnQuZmFpbHVyZSgpXG5cdH1cblxuXHRtb3VudC5zdWNjZXNzKCk7XG5cblx0dGhpcy5zdG9yZSA9IHtcblx0XHRjb250YWluZXJzOiB7fSxcblx0XHRlbGVtZW50czoge30sXG5cdFx0aGlzdG9yeTogW10sXG5cdFx0c2VxdWVuY2VzOiB7fVxuXHR9O1xuXG5cdHRoaXMucHJpc3RpbmUgPSB0cnVlO1xuXG5cdGJvdW5kRGVsZWdhdGUgPSBib3VuZERlbGVnYXRlIHx8IGRlbGVnYXRlLmJpbmQodGhpcyk7XG5cdGJvdW5kRGVzdHJveSA9IGJvdW5kRGVzdHJveSB8fCBkZXN0cm95LmJpbmQodGhpcyk7XG5cdGJvdW5kUmV2ZWFsID0gYm91bmRSZXZlYWwgfHwgcmV2ZWFsLmJpbmQodGhpcyk7XG5cdGJvdW5kQ2xlYW4gPSBib3VuZENsZWFuIHx8IGNsZWFuLmJpbmQodGhpcyk7XG5cdGJvdW5kU3luYyA9IGJvdW5kU3luYyB8fCBzeW5jLmJpbmQodGhpcyk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWxlZ2F0ZScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBib3VuZERlbGVnYXRlOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2Rlc3Ryb3knLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYm91bmREZXN0cm95OyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3JldmVhbCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBib3VuZFJldmVhbDsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjbGVhbicsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBib3VuZENsZWFuOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N5bmMnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYm91bmRTeW5jOyB9IH0pO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZGVmYXVsdHMnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ZlcnNpb24nLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmVyc2lvbjsgfSB9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdub29wJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9IH0pO1xuXG5cdHJldHVybiBpbnN0YW5jZSA/IGluc3RhbmNlIDogKGluc3RhbmNlID0gdGhpcylcbn1cblxuU2Nyb2xsUmV2ZWFsLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNmb3JtU3VwcG9ydGVkKCkgJiYgdHJhbnNpdGlvblN1cHBvcnRlZCgpOyB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2Nyb2xsUmV2ZWFsLCAnZGVidWcnLCB7XG5cdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVidWcgfHwgZmFsc2U7IH0sXG5cdHNldDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAoZGVidWcgPSB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/IHZhbHVlIDogZGVidWcpOyB9XG59KTtcblxuU2Nyb2xsUmV2ZWFsKCk7XG5cbnJldHVybiBTY3JvbGxSZXZlYWw7XG5cbn0pKSk7XG4iLCLvu78vKiBTbXRwSlMuY29tIC0gdjMuMC4wICovXG5cbmZ1bmN0aW9uIGVtYWlsU2VuZChhKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAobiwgZSkge1xuXHRcdGEubm9jYWNoZSA9IE1hdGguZmxvb3IoMWU2ICogTWF0aC5yYW5kb20oKSArIDEpLFxuXHRcdGEuQWN0aW9uID0gXCJTZW5kXCI7IHZhciB0ID0gSlNPTi5zdHJpbmdpZnkoYSk7XG5cblx0XHRlbWFpbEFqYXhQb3N0KFwiaHR0cHM6Ly9zbXRwanMuY29tL3YzL3NtdHBqcy5hc3B4P1wiLCB0LCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0bihlKVxuXHRcdH0pXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGVtYWlsQWpheFBvc3QoZSwgbiwgdCkge1xuXHR2YXIgYSA9IGVtYWlsQ3JlYXRlQ09SU1JlcXVlc3QoXCJQT1NUXCIsIGUpO1xuXHRhLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiksXG5cdGEub25sb2FkID0gZnVuY3Rpb24gKCkgeyB2YXIgZSA9IGEucmVzcG9uc2VUZXh0OyBjb25zb2xlLmxvZyhlKTsgbnVsbCAhPSB0ICYmIHQoZSkgIH0sXG5cdGEuc2VuZChuKVxufVxuXG5mdW5jdGlvbiBlbWFpbEFqYXgoZSwgbikge1xuXHR2YXIgdCA9IGVtYWlsQ3JlYXRlQ09SU1JlcXVlc3QoXCJHRVRcIiwgZSk7XG5cdHQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlID0gdC5yZXNwb25zZVRleHQ7XG5cdFx0bnVsbCAhPSBuICYmIG4oZSlcblx0fSwgdC5zZW5kKClcbn1cblxuZnVuY3Rpb24gZW1haWxDcmVhdGVDT1JTUmVxdWVzdChlLCBuKSB7XG5cdHZhciB0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuXHRyZXR1cm4gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB0ID8gdC5vcGVuKGUsIG4sICEwKSA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ID8gKHQgPSBuZXcgWERvbWFpblJlcXVlc3QpLm9wZW4oZSwgbikgOiB0ID0gbnVsbCwgdFxufVxuXG5leHBvcnQge2VtYWlsU2VuZCwgZW1haWxBamF4UG9zdCwgZW1haWxBamF4LCBlbWFpbENyZWF0ZUNPUlNSZXF1ZXN0fTtcbiIsIi8qIVxuICogVnVlLmpzIHYyLjYuOVxuICogKGMpIDIwMTQtMjAxOSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVnVlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyogICovXG5cbiAgdmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbiAgLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4gIC8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXG4gIGZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gICAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICAgIHJldHVybiB2ID09PSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICAgKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gICAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICAgKi9cbiAgdmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG4gIH1cblxuICAvKipcbiAgICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICAgKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gIH1cblxuICBmdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICAgIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG4gIH1cblxuICBmdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICAgIHJldHVybiAoXG4gICAgICBpc0RlZih2YWwpICYmXG4gICAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAqL1xuICBmdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgICA/ICcnXG4gICAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgICAgOiBTdHJpbmcodmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICAgKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gICAqIGlzIGluIHRoYXQgbWFwLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZU1hcCAoXG4gICAgc3RyLFxuICAgIGV4cGVjdHNMb3dlckNhc2VcbiAgKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAgICovXG4gIHZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gICAqL1xuICB2YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICAgKi9cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gICAqL1xuICB2YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbiAgdmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gICAqL1xuICB2YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxuICB9KTtcblxuICAvKipcbiAgICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAgICovXG4gIHZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG4gIHZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAgICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gICAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICAgKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gICAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICByZXR1cm4gbFxuICAgICAgICA/IGwgPiAxXG4gICAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgICA6IGZuLmNhbGwoY3R4KVxuICAgIH1cblxuICAgIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgICByZXR1cm4gYm91bmRGblxuICB9XG5cbiAgZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICAgIHJldHVybiBmbi5iaW5kKGN0eClcbiAgfVxuXG4gIHZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgICA/IG5hdGl2ZUJpbmRcbiAgICA6IHBvbHlmaWxsQmluZDtcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICAgIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0b1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2ldKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICAgKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAgICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuICAvKipcbiAgICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICovXG4gIHZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAgICovXG4gIHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHN0cmluZyBjb250YWluaW5nIHN0YXRpYyBrZXlzIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gICAgfSwgW10pLmpvaW4oJywnKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICAgKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gICAqL1xuICBmdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICAgIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gICAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICAgKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxuICB2YXIgQVNTRVRfVFlQRVMgPSBbXG4gICAgJ2NvbXBvbmVudCcsXG4gICAgJ2RpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcidcbiAgXTtcblxuICB2YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAgICdiZWZvcmVDcmVhdGUnLFxuICAgICdjcmVhdGVkJyxcbiAgICAnYmVmb3JlTW91bnQnLFxuICAgICdtb3VudGVkJyxcbiAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAndXBkYXRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdhY3RpdmF0ZWQnLFxuICAgICdkZWFjdGl2YXRlZCcsXG4gICAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAgICdzZXJ2ZXJQcmVmZXRjaCdcbiAgXTtcblxuICAvKiAgKi9cblxuXG5cbiAgdmFyIGNvbmZpZyA9ICh7XG4gICAgLyoqXG4gICAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAgICovXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICAgKi9cbiAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICAgKi9cbiAgICBwcm9kdWN0aW9uVGlwOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAgICovXG4gICAgZGV2dG9vbHM6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgICAqL1xuICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAgICovXG4gICAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAgICovXG4gICAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICAgKi9cbiAgICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICAgKi9cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKi9cbiAgICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKi9cbiAgICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgICAqL1xuICAgIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAgICovXG4gICAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAgICovXG4gICAgbXVzdFVzZVByb3A6IG5vLFxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAgICovXG4gICAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1NcbiAgfSk7XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAgICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAgICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICAgKi9cbiAgdmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICAgKi9cbiAgZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gICAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHByb3BlcnR5LlxuICAgKi9cbiAgZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsLFxuICAgICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAgICovXG4gIHZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKChcIlteXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCIuJF9cXFxcZF1cIikpO1xuICBmdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbiAgdmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbiAgLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xuICB2YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xuICB2YXIgd2VleFBsYXRmb3JtID0gaW5XZWV4ICYmIFdYRW52aXJvbm1lbnQucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcbiAgdmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIHZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG4gIHZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xuICB2YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG4gIHZhciBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbiAgdmFyIGlzSU9TID0gKFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSkpIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdpb3MnKTtcbiAgdmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG4gIHZhciBpc1BoYW50b21KUyA9IFVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xuICB2YXIgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XG5cbiAgLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxuICB2YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG4gIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbiAgaWYgKGluQnJvd3Nlcikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIC8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuICAvLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxuICB2YXIgX2lzU2VydmVyO1xuICB2YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfaXNTZXJ2ZXJcbiAgfTtcblxuICAvLyBkZXRlY3QgZGV2dG9vbHNcbiAgdmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG4gIH1cblxuICB2YXIgaGFzU3ltYm9sID1cbiAgICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gICAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbiAgdmFyIF9TZXQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgICBfU2V0ID0gU2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgICBfU2V0ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgICB9O1xuICAgICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gU2V0O1xuICAgIH0oKSk7XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgd2FybiA9IG5vb3A7XG4gIHZhciB0aXAgPSBub29wO1xuICB2YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xuICB2YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuICB7XG4gICAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gICAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICAgICkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgICByZXR1cm4gJzxSb290PidcbiAgICAgIH1cbiAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICAgIDogdm07XG4gICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgICApXG4gICAgfTtcblxuICAgIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgICB2YXIgcmVzID0gJyc7XG4gICAgICB3aGlsZSAobikge1xuICAgICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgICBuID4+PSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH07XG5cbiAgICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgdWlkID0gMDtcblxuICAvKipcbiAgICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gICAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gICAqL1xuICB2YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgICB0aGlzLmlkID0gdWlkKys7XG4gICAgdGhpcy5zdWJzID0gW107XG4gIH07XG5cbiAgRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICAgIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG4gIH07XG5cbiAgRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICAgIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG4gIH07XG5cbiAgRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAgIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gICAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgLy8gc3VicyBhcmVuJ3Qgc29ydGVkIGluIHNjaGVkdWxlciBpZiBub3QgcnVubmluZyBhc3luY1xuICAgICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxuICAgICAgLy8gb3JkZXJcbiAgICAgIHN1YnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4gIC8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuICAvLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbiAgRGVwLnRhcmdldCA9IG51bGw7XG4gIHZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG4gIGZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICAgIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgICBEZXAudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gICAgdGFnLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgdGV4dCxcbiAgICBlbG0sXG4gICAgY29udGV4dCxcbiAgICBjb21wb25lbnRPcHRpb25zLFxuICAgIGFzeW5jRmFjdG9yeVxuICApIHtcbiAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuZWxtID0gZWxtO1xuICAgIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gICAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmF3ID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICAgIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICAgIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICAvLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2VcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICB2YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICAgIG5vZGUudGV4dCA9IHRleHQ7XG4gICAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICAgIHJldHVybiBub2RlXG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxuICB9XG5cbiAgLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbiAgLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuICAvLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbiAgLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbiAgZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgICAgdm5vZGUudGFnLFxuICAgICAgdm5vZGUuZGF0YSxcbiAgICAgIC8vICM3OTc1XG4gICAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAgIC8vIGEgY2hpbGQuXG4gICAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLFxuICAgICAgdm5vZGUudGV4dCxcbiAgICAgIHZub2RlLmVsbSxcbiAgICAgIHZub2RlLmNvbnRleHQsXG4gICAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICAgKTtcbiAgICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICAgIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gICAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICAgIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gICAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICAgIHJldHVybiBjbG9uZWRcbiAgfVxuXG4gIC8qXG4gICAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICAgKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAgICovXG5cbiAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG4gIHZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1xuXG4gIHZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgICAncHVzaCcsXG4gICAgJ3BvcCcsXG4gICAgJ3NoaWZ0JyxcbiAgICAndW5zaGlmdCcsXG4gICAgJ3NwbGljZScsXG4gICAgJ3NvcnQnLFxuICAgICdyZXZlcnNlJ1xuICBdO1xuXG4gIC8qKlxuICAgKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAgICovXG4gIG1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICAgIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgICAgdmFyIGluc2VydGVkO1xuICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyogICovXG5cbiAgdmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbiAgLyoqXG4gICAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICAgKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gICAqL1xuICB2YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbiAgZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICAgIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAgICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICAgKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICAgKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAgICovXG4gIHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgICB0aGlzLnZtQ291bnQgPSAwO1xuICAgIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKGhhc1Byb3RvKSB7XG4gICAgICAgIHByb3RvQXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvcHlBdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gICAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICAgKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAgICovXG4gIE9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGhlbHBlcnNcblxuICAvKipcbiAgICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gICAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gICAqL1xuICBmdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbiAgfVxuXG4gIC8qKlxuICAgKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICAgKiBoaWRkZW4gcHJvcGVydGllcy5cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICAgKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICAgKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAgICovXG4gIGZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvYjtcbiAgICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAgICF2YWx1ZS5faXNWdWVcbiAgICApIHtcbiAgICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICAgIG9iLnZtQ291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIG9iXG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICAgIG9iaixcbiAgICBrZXksXG4gICAgdmFsLFxuICAgIGN1c3RvbVNldHRlcixcbiAgICBzaGFsbG93XG4gICkge1xuICAgIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gICAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuICAgIGlmICgoIWdldHRlciB8fCBzZXR0ZXIpICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhbCA9IG9ialtrZXldO1xuICAgIH1cblxuICAgIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgICAgaWYgKGN1c3RvbVNldHRlcikge1xuICAgICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgICBpZiAoZ2V0dGVyICYmICFzZXR0ZXIpIHsgcmV0dXJuIH1cbiAgICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgICAgZGVwLm5vdGlmeSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICAgKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gICAqIGFscmVhZHkgZXhpc3QuXG4gICAqL1xuICBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgICBpZiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldClcbiAgICApIHtcbiAgICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gICAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gICAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgICApO1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgICBpZiAoIW9iKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICBmdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gICAgaWYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpXG4gICAgKSB7XG4gICAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gICAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICBpZiAoIW9iKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gICAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gICAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZSA9IHZhbHVlW2ldO1xuICAgICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgICBkZXBlbmRBcnJheShlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICAgKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICAgKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAgICovXG4gIHZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4gIC8qKlxuICAgKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gICAqL1xuICB7XG4gICAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgICBpZiAoIXZtKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcblxuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKVxuICAgICAgKSB7XG4gICAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b1xuICB9XG5cbiAgLyoqXG4gICAqIERhdGFcbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bVxuICApIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgICB9XG4gICAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICAgIH1cbiAgICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICAgIDogY2hpbGRWYWw7XG4gICAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bVxuICApIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICAgIH1cblxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxuICB9O1xuXG4gIC8qKlxuICAgKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZUhvb2sgKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbFxuICApIHtcbiAgICB2YXIgcmVzID0gY2hpbGRWYWxcbiAgICAgID8gcGFyZW50VmFsXG4gICAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICAgIDogcGFyZW50VmFsO1xuICAgIHJldHVybiByZXNcbiAgICAgID8gZGVkdXBlSG9va3MocmVzKVxuICAgICAgOiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZHVwZUhvb2tzIChob29rcykge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgICByZXMucHVzaChob29rc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIExJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xuICB9KTtcblxuICAvKipcbiAgICogQXNzZXRzXG4gICAqXG4gICAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAgICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICAgKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWwsXG4gICAgdm0sXG4gICAga2V5XG4gICkge1xuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgICBpZiAoY2hpbGRWYWwpIHtcbiAgICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuICB9XG5cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xuICB9KTtcblxuICAvKipcbiAgICogV2F0Y2hlcnMuXG4gICAqXG4gICAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAgICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gICAqL1xuICBzdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtLFxuICAgIGtleVxuICApIHtcbiAgICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICAgIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICAgIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gICAge1xuICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gICAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgICAgfVxuICAgICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfTtcblxuICAvKipcbiAgICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAgICovXG4gIHN0cmF0cy5wcm9wcyA9XG4gIHN0cmF0cy5tZXRob2RzID1cbiAgc3RyYXRzLmluamVjdCA9XG4gIHN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWwsXG4gICAgdm0sXG4gICAga2V5XG4gICkge1xuICAgIGlmIChjaGlsZFZhbCAmJiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gICAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XG4gICAgcmV0dXJuIHJldFxuICB9O1xuICBzdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gICAqL1xuICB2YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgICAgPyBwYXJlbnRWYWxcbiAgICAgIDogY2hpbGRWYWxcbiAgfTtcblxuICAvKipcbiAgICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gICAqL1xuICBmdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUgKG5hbWUpIHtcbiAgICBpZiAoIW5ldyBSZWdFeHAoKFwiXlthLXpBLVpdW1xcXFwtXFxcXC4wLTlfXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCJdKiRcIikpLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIG5hbWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICAgKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBpLCB2YWwsIG5hbWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgICA/IHZhbFxuICAgICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gICAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICAgIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gICAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICAgIHZhciBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gICAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICAgIHBhcmVudCxcbiAgICBjaGlsZCxcbiAgICB2bVxuICApIHtcbiAgICB7XG4gICAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgICB9XG5cbiAgICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICAgIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICAgIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gICAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAgIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gICAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICAgIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIGFzc2V0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAgICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgICBvcHRpb25zLFxuICAgIHR5cGUsXG4gICAgaWQsXG4gICAgd2Fybk1pc3NpbmdcbiAgKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICAgIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICAgIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gICAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICAgIGlmICh3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAgICBrZXksXG4gICAgcHJvcE9wdGlvbnMsXG4gICAgcHJvcHNEYXRhLFxuICAgIHZtXG4gICkge1xuICAgIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gICAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gICAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICAgIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gICAgfVxuICAgIHtcbiAgICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gICAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gICAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAgIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICAgIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICAgIH1cbiAgICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAgIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICAgID8gZGVmLmNhbGwodm0pXG4gICAgICA6IGRlZlxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICAgIHByb3AsXG4gICAgbmFtZSxcbiAgICB2YWx1ZSxcbiAgICB2bSxcbiAgICBhYnNlbnRcbiAgKSB7XG4gICAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlID0gW3R5cGVdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgd2FybihcbiAgICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuICBmdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICAgIHZhciB2YWxpZDtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogdmFsaWQsXG4gICAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gICAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICAgKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICAgIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICAgIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgICByZXR1cm4gaVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICB2YXIgbWVzc2FnZSA9IFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xuICAgIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICAgIHZhciByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICAgIHZhciBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgICB2YXIgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gICAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyBleHBlY3RlZFZhbHVlO1xuICAgIH1cbiAgICBtZXNzYWdlICs9IFwiLCBnb3QgXCIgKyByZWNlaXZlZFR5cGUgKyBcIiBcIjtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCJ3aXRoIHZhbHVlIFwiICsgcmVjZWl2ZWRWYWx1ZSArIFwiLlwiO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZVxuICB9XG5cbiAgZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICAgIHJldHVybiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICAgIHJldHVybiAoXCJcIiArIChOdW1iZXIodmFsdWUpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlwiICsgdmFsdWUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICAgIHZhciBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gICAgLy8gRGVhY3RpdmF0ZSBkZXBzIHRyYWNraW5nIHdoaWxlIHByb2Nlc3NpbmcgZXJyb3IgaGFuZGxlciB0byBhdm9pZCBwb3NzaWJsZSBpbmZpbml0ZSByZW5kZXJpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHZtKSB7XG4gICAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICAgIGhhbmRsZXIsXG4gICAgY29udGV4dCxcbiAgICBhcmdzLFxuICAgIHZtLFxuICAgIGluZm9cbiAgKSB7XG4gICAgdmFyIHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgICAgcmVzLmNhdGNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyArIFwiIChQcm9taXNlL2FzeW5jKVwiKTsgfSk7XG4gICAgICAgIC8vIGlzc3VlICM5NTExXG4gICAgICAgIC8vIGF2b2lkIGNhdGNoIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgd2hlbiBuZXN0ZWQgY2FsbHNcbiAgICAgICAgcmVzLl9oYW5kbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gICAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSB0aHJvd3MgdGhlIG9yaWdpbmFsIGVycm9yIGluIHRoZSBoYW5kbGVyLFxuICAgICAgICAvLyBkbyBub3QgbG9nIGl0IHR3aWNlXG4gICAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgICB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGlzVXNpbmdNaWNyb1Rhc2sgPSBmYWxzZTtcblxuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIG1pY3JvdGFza3MuXG4gIC8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4gIC8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4gIC8vIChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuICAvLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbiAgLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4gIC8vIFNvIHdlIG5vdyB1c2UgbWljcm90YXNrcyBldmVyeXdoZXJlLCBhZ2Fpbi5cbiAgLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4gIC8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuICAvLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTAsIHdoaWNoIGhhdmUgd29ya2Fyb3VuZHMpXG4gIC8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxuICB2YXIgdGltZXJGdW5jO1xuXG4gIC8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4gIC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuICAvLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbiAgLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbiAgLy8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuICAvLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gICAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgICAvLyBUZWNoaW5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gICAgLy8gYnV0IGl0IGlzIHN0aWxsIGEgYmV0dGVyIGNob2ljZSB0aGFuIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbWFyaztcbiAgdmFyIG1lYXN1cmU7XG5cbiAge1xuICAgIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBwZXJmICYmXG4gICAgICBwZXJmLm1hcmsgJiZcbiAgICAgIHBlcmYubWVhc3VyZSAmJlxuICAgICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgICApIHtcbiAgICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbiAgdmFyIGluaXRQcm94eTtcblxuICB7XG4gICAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICAgKTtcblxuICAgIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgd2FyblJlc2VydmVkUHJlZml4ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXFxcIiRkYXRhLlwiICsga2V5ICsgXCJcXFwiIGJlY2F1c2UgXCIgK1xuICAgICAgICAncHJvcGVydGllcyBzdGFydGluZyB3aXRoIFwiJFwiIG9yIFwiX1wiIGFyZSBub3QgcHJveGllZCBpbiB0aGUgVnVlIGluc3RhbmNlIHRvICcgK1xuICAgICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzJyArXG4gICAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGhhc1Byb3h5ID1cbiAgICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8XG4gICAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRIYW5kbGVyID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICAgKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICAgKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICAgKi9cbiAgZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICAgIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgICB2YXIgaSwga2V5cztcbiAgICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICAgIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodmFsLl9fb2JfXykge1xuICAgICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc2Vlbi5hZGQoZGVwSWQpO1xuICAgIH1cbiAgICBpZiAoaXNBKSB7XG4gICAgICBpID0gdmFsLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICAgIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gICAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gICAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gICAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgICAgcGFzc2l2ZTogcGFzc2l2ZVxuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNsb25lZFtpXSwgbnVsbCwgYXJndW1lbnRzJDEsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgICAgcmV0dXJuIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZucywgbnVsbCwgYXJndW1lbnRzLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIilcbiAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlci5mbnMgPSBmbnM7XG4gICAgcmV0dXJuIGludm9rZXJcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gICAgb24sXG4gICAgb2xkT24sXG4gICAgYWRkLFxuICAgIHJlbW92ZSQkMSxcbiAgICBjcmVhdGVPbmNlSGFuZGxlcixcbiAgICB2bVxuICApIHtcbiAgICB2YXIgbmFtZSwgZGVmJCQxLCBjdXIsIG9sZCwgZXZlbnQ7XG4gICAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIsIHZtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUcnVlKGV2ZW50Lm9uY2UpKSB7XG4gICAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gICAgfVxuICAgIHZhciBpbnZva2VyO1xuICAgIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gICAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gICAgZGF0YSxcbiAgICBDdG9yLFxuICAgIHRhZ1xuICApIHtcbiAgICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICAgIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICAgIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRpcChcbiAgICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgICByZXMsXG4gICAgaGFzaCxcbiAgICBrZXksXG4gICAgYWx0S2V5LFxuICAgIHByZXNlcnZlXG4gICkge1xuICAgIGlmIChpc0RlZihoYXNoKSkge1xuICAgICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKiAgKi9cblxuICAvLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbiAgLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbiAgLy9cbiAgLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbiAgLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuICAvLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbiAgLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAvLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuICAvLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbiAgLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuICBmdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5cbiAgfVxuXG4gIC8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4gIC8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuICAvLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4gIC8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuICBmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICAgIDogdW5kZWZpbmVkXG4gIH1cblxuICBmdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gICAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAgIC8vICBuZXN0ZWRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICAgIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgICBpZiAocHJvdmlkZSkge1xuICAgICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICAgIDogcHJvdmlkZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAge1xuICAgICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG5cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAgICovXG4gIGZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFxuICApIHtcbiAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7fVxuICAgIH1cbiAgICB2YXIgc2xvdHMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgICAgfVxuICAgICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gICAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICAgIHNsb3RzLFxuICAgIG5vcm1hbFNsb3RzLFxuICAgIHByZXZTbG90c1xuICApIHtcbiAgICB2YXIgcmVzO1xuICAgIHZhciBpc1N0YWJsZSA9IHNsb3RzID8gISFzbG90cy4kc3RhYmxlIDogdHJ1ZTtcbiAgICB2YXIgaGFzTm9ybWFsU2xvdHMgPSBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID4gMDtcbiAgICB2YXIga2V5ID0gc2xvdHMgJiYgc2xvdHMuJGtleTtcbiAgICBpZiAoIXNsb3RzKSB7XG4gICAgICByZXMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKHNsb3RzLl9ub3JtYWxpemVkKSB7XG4gICAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpc1N0YWJsZSAmJlxuICAgICAgcHJldlNsb3RzICYmXG4gICAgICBwcmV2U2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmXG4gICAgICBrZXkgPT09IHByZXZTbG90cy4ka2V5ICYmXG4gICAgICAhaGFzTm9ybWFsU2xvdHMgJiZcbiAgICAgICFwcmV2U2xvdHMuJGhhc05vcm1hbFxuICAgICkge1xuICAgICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXG4gICAgICByZXR1cm4gcHJldlNsb3RzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5JDEgaW4gc2xvdHMpIHtcbiAgICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XG4gICAgICAgICAgcmVzW2tleSQxXSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSQxLCBzbG90c1trZXkkMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xuICAgICAgaWYgKCEoa2V5JDIgaW4gcmVzKSkge1xuICAgICAgICByZXNba2V5JDJdID0gcHJveHlOb3JtYWxTbG90KG5vcm1hbFNsb3RzLCBrZXkkMik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgICBpZiAoc2xvdHMgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShzbG90cykpIHtcbiAgICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gICAgfVxuICAgIGRlZihyZXMsICckc3RhYmxlJywgaXNTdGFibGUpO1xuICAgIGRlZihyZXMsICcka2V5Jywga2V5KTtcbiAgICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgICA/IFtyZXNdIC8vIHNpbmdsZSB2bm9kZVxuICAgICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgICByZXR1cm4gcmVzICYmIChcbiAgICAgICAgcmVzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAocmVzLmxlbmd0aCA9PT0gMSAmJiByZXNbMF0uaXNDb21tZW50KSAvLyAjOTY1OFxuICAgICAgKSA/IHVuZGVmaW5lZFxuICAgICAgICA6IHJlc1xuICAgIH07XG4gICAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gICAgLy8gY29tcGlsZWQgYXMgYSBzY29wZWQgc2xvdCwgcmVuZGVyIGZuIHVzZXJzIHdvdWxkIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50XG4gICAgLy8gb24gdGhpcy4kc2xvdHMgYmVjYXVzZSB0aGUgdXNhZ2UgaXMgc2VtYW50aWNhbGx5IGEgbm9ybWFsIHNsb3QuXG4gICAgaWYgKGZuLnByb3h5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsU2xvdHMsIGtleSwge1xuICAgICAgICBnZXQ6IG5vcm1hbGl6ZWQsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkXG4gIH1cblxuICBmdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzbG90c1trZXldOyB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICAgIHZhbCxcbiAgICByZW5kZXJcbiAgKSB7XG4gICAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBpZiAoaGFzU3ltYm9sICYmIHZhbFtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgIHJldCA9IFtdO1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSB2YWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNEZWYocmV0KSkge1xuICAgICAgcmV0ID0gW107XG4gICAgfVxuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICAgIG5hbWUsXG4gICAgZmFsbGJhY2ssXG4gICAgcHJvcHMsXG4gICAgYmluZE9iamVjdFxuICApIHtcbiAgICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gICAgdmFyIG5vZGVzO1xuICAgIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICAgIH1cbiAgICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXSB8fCBmYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGVzXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcbiAgICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICAgKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAgICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAqL1xuICBmdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgICBldmVudEtleUNvZGUsXG4gICAga2V5LFxuICAgIGJ1aWx0SW5LZXlDb2RlLFxuICAgIGV2ZW50S2V5TmFtZSxcbiAgICBidWlsdEluS2V5TmFtZVxuICApIHtcbiAgICB2YXIgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICAgIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICAgIH0gZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICAgIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICAgKi9cbiAgZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgICBkYXRhLFxuICAgIHRhZyxcbiAgICB2YWx1ZSxcbiAgICBhc1Byb3AsXG4gICAgaXNTeW5jXG4gICkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNoO1xuICAgICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgICAgaWYgKCEoY2FtZWxpemVkS2V5IGluIGhhc2gpICYmICEoaHlwaGVuYXRlZEtleSBpbiBoYXNoKSkge1xuICAgICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgICBpbmRleCxcbiAgICBpc0luRm9yXG4gICkge1xuICAgIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gICAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAgIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAgIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICAgIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgICByZXR1cm4gdHJlZVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gICAgdHJlZSA9IGNhY2hlZFtpbmRleF0gPSB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbChcbiAgICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMgLy8gZm9yIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCB0ZW1wbGF0ZXNcbiAgICApO1xuICAgIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICAgKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgICB0cmVlLFxuICAgIGluZGV4LFxuICAgIGtleVxuICApIHtcbiAgICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgICByZXR1cm4gdHJlZVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gICAgdHJlZSxcbiAgICBrZXksXG4gICAgaXNPbmNlXG4gICkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICAgIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICAgIG5vZGUua2V5ID0ga2V5O1xuICAgIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gICAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICAgIHJlcyxcbiAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBhZGRlZCBpbiAyLjZcbiAgICBoYXNEeW5hbWljS2V5cyxcbiAgICBjb250ZW50SGFzaEtleVxuICApIHtcbiAgICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNsb3QgPSBmbnNbaV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XG4gICAgICB9IGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgICAgc2xvdC5mbi5wcm94eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZW50SGFzaEtleSkge1xuICAgICAgKHJlcykuJGtleSA9IGNvbnRlbnRIYXNoS2V5O1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIga2V5ID0gdmFsdWVzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xuICAgICAgfSBlbHNlIGlmIChrZXkgIT09ICcnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBudWxsIGlzIGEgc3BlaWNhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJJbnZhbGlkIHZhbHVlIGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCAoZXhwZWN0ZWQgc3RyaW5nIG9yIG51bGwpOiBcIiArIGtleSksXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFzZU9ialxuICB9XG5cbiAgLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4gIC8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4gIC8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cbiAgZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gICAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gICAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gICAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICAgIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gICAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICAgIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICAgIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gICAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICAgIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICAgIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcbiAgICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBwYXJlbnQsXG4gICAgQ3RvclxuICApIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gICAgdmFyIGNvbnRleHRWbTtcbiAgICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICAgIH1cbiAgICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gICAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICAgIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gICAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcyQxLiRzbG90cykge1xuICAgICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgICBkYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NvcGVkU2xvdHMnLCAoe1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSlcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gICAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pOyB9O1xuICAgIH1cbiAgfVxuXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gICAgQ3RvcixcbiAgICBwcm9wc0RhdGEsXG4gICAgZGF0YSxcbiAgICBjb250ZXh0Vm0sXG4gICAgY2hpbGRyZW5cbiAgKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICAgIH1cblxuICAgIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgICAgZGF0YSxcbiAgICAgIHByb3BzLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBjb250ZXh0Vm0sXG4gICAgICBDdG9yXG4gICAgKTtcblxuICAgIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgIHZhciB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZXNbaV0sIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gICAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gICAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgICB7XG4gICAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgICB9XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyogICovXG5cbiAgLyogICovXG5cbiAgLyogICovXG5cbiAgLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbiAgdmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgaWYgKFxuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXG4gICAgICApIHtcbiAgICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgICBjaGlsZCxcbiAgICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgICBDdG9yLFxuICAgIGRhdGEsXG4gICAgY29udGV4dCxcbiAgICBjaGlsZHJlbixcbiAgICB0YWdcbiAgKSB7XG4gICAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gICAgfVxuXG4gICAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAgIC8vIHJlamVjdC5cbiAgICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBhc3luYyBjb21wb25lbnRcbiAgICB2YXIgYXN5bmNGYWN0b3J5O1xuICAgIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3Rvcik7XG4gICAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICB0YWdcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gICAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAgIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gICAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgcHJvcHNcbiAgICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gICAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAgIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gICAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gICAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgICAvLyBzbyBpdCBnZXRzIHByb2Nlc3NlZCBkdXJpbmcgcGFyZW50IGNvbXBvbmVudCBwYXRjaC5cbiAgICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICAgIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgdmFyIHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgICBkYXRhID0ge307XG4gICAgICBpZiAoc2xvdCkge1xuICAgICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICAgIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcblxuICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gICAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gICAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgICAgYXN5bmNGYWN0b3J5XG4gICAgKTtcblxuICAgIHJldHVybiB2bm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gICAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICAgIHBhcmVudCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICB9O1xuICAgIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gICAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gICAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgICB2YXIgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgICAgdmFyIHRvTWVyZ2UgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSG9vayQxIChmMSwgZjIpIHtcbiAgICB2YXIgbWVyZ2VkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcbiAgICAgIGYxKGEsIGIpO1xuICAgICAgZjIoYSwgYik7XG4gICAgfTtcbiAgICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZFxuICB9XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuICAvLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcbiAgICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnXG4gICAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICB2YXIgZXhpc3RpbmcgPSBvbltldmVudF07XG4gICAgdmFyIGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgICA6IGV4aXN0aW5nICE9PSBjYWxsYmFja1xuICAgICAgKSB7XG4gICAgICAgIG9uW2V2ZW50XSA9IFtjYWxsYmFja10uY29uY2F0KGV4aXN0aW5nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb25bZXZlbnRdID0gY2FsbGJhY2s7XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xuICB2YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbiAgLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2VcbiAgLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICAgIGNvbnRleHQsXG4gICAgdGFnLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgbm9ybWFsaXphdGlvblR5cGUsXG4gICAgYWx3YXlzTm9ybWFsaXplXG4gICkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgICBjb250ZXh0LFxuICAgIHRhZyxcbiAgICBkYXRhLFxuICAgIGNoaWxkcmVuLFxuICAgIG5vcm1hbGl6YXRpb25UeXBlXG4gICkge1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcbiAgICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gICAgfVxuICAgIC8vIG9iamVjdCBzeW50YXggaW4gdi1iaW5kXG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgICB0YWcgPSBkYXRhLmlzO1xuICAgIH1cbiAgICBpZiAoIXRhZykge1xuICAgICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICAgIH1cbiAgICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgICApIHtcbiAgICAgIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgfVxuICAgIHZhciB2bm9kZSwgbnM7XG4gICAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgQ3RvcjtcbiAgICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSBpZiAoKCFkYXRhIHx8ICFkYXRhLnByZSkgJiYgaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9IGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gICAgdm5vZGUubnMgPSBucztcbiAgICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgICBmb3JjZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoXG4gICAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlZiAjNTMxOFxuICAvLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuICAvLyA6Y2xhc3MgYXJlIHVzZWQgb24gc2xvdCBub2Rlc1xuICBmdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICAgIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICAgIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICAgIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICAgIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAgIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAgIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gICAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAgIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gICAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAgIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAgIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICAgIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gICAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gICAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICAgIH0sIHRydWUpO1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgICAvLyBpbnN0YWxsIHJ1bnRpbWUgY29udmVuaWVuY2UgaGVscGVyc1xuICAgIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gICAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgICAgdm0uJHNsb3RzLFxuICAgICAgICAgIHZtLiRzY29wZWRTbG90c1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAgIC8vIHJlbmRlciBzZWxmXG4gICAgICB2YXIgdm5vZGU7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdWVzIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAgIC8vIHdoZW4gcGFyZW50IGNvbXBvbmVudCBpcyBwYXRjaGVkLlxuICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZub2RlID0gdm5vZGVbMF07XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgICAgfVxuICAgICAgLy8gc2V0IHBhcmVudFxuICAgICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgICBpZiAoXG4gICAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgICApIHtcbiAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBpc09iamVjdChjb21wKVxuICAgICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgICAgOiBjb21wXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgICBmYWN0b3J5LFxuICAgIGRhdGEsXG4gICAgY29udGV4dCxcbiAgICBjaGlsZHJlbixcbiAgICB0YWdcbiAgKSB7XG4gICAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICAgIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gICAgZmFjdG9yeSxcbiAgICBiYXNlQ3RvclxuICApIHtcbiAgICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICAgIH1cblxuICAgIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcbiAgICB9XG5cbiAgICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgfVxuXG4gICAgaWYgKG93bmVyICYmICFpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcbiAgICAgIHZhciBvd25lcnMgPSBmYWN0b3J5Lm93bmVycyA9IFtvd25lcl07XG4gICAgICB2YXIgc3luYyA9IHRydWVcblxuICAgICAgOyhvd25lcikuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlbW92ZShvd25lcnMsIG93bmVyKTsgfSk7XG5cbiAgICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgICAgXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3RvcnlcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgICAgcmV0dXJuIGNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAgIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICAgIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGFyZ2V0O1xuXG4gIGZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICAgIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICAgIHZtLFxuICAgIGxpc3RlbmVycyxcbiAgICBvbGRMaXN0ZW5lcnNcbiAgKSB7XG4gICAgdGFyZ2V0ID0gdm07XG4gICAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gICAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBvbi5mbiA9IGZuO1xuICAgICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIC8vIGFsbFxuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICByZXR1cm4gdm1cbiAgICAgIH1cbiAgICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG4gICAgICAgICAgdm0uJG9mZihldmVudFtpJDFdLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgICAgaWYgKCFjYnMpIHtcbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICBpZiAoIWZuKSB7XG4gICAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICB2YXIgY2I7XG4gICAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB7XG4gICAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICAgIGlmIChjYnMpIHtcbiAgICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2JzW2ldLCB2bSwgYXJncywgdm0sIGluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XG4gICAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAgIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICAgIH1cblxuICAgIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gICAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICAgIHZtLiRjaGlsZHJlbiA9IFtdO1xuICAgIHZtLiRyZWZzID0ge307XG5cbiAgICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gICAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyh2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlc1xuICAgICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgICB9XG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgICAgaWYgKHByZXZFbCkge1xuICAgICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodm0uJGVsKSB7XG4gICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgICB9XG4gICAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICAgIH1cbiAgICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgICB9XG4gICAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgICB2bS4kb2ZmKCk7XG4gICAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgIGlmICh2bS4kZWwpIHtcbiAgICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICAgIHZtLFxuICAgIGVsLFxuICAgIGh5ZHJhdGluZ1xuICApIHtcbiAgICB2bS4kZWwgPSBlbDtcbiAgICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICAgIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gICAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHJlbmRlclwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cbiAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSAoKSB7XG4gICAgICAgIGlmICh2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICAgIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gICAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICAgIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gICAgdm0sXG4gICAgcHJvcHNEYXRhLFxuICAgIGxpc3RlbmVycyxcbiAgICBwYXJlbnRWbm9kZSxcbiAgICByZW5kZXJDaGlsZHJlblxuICApIHtcbiAgICB7XG4gICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAgIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAgIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXG4gICAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICAgIHZhciBuZXdTY29wZWRTbG90cyA9IHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHM7XG4gICAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICAgIHZhciBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgICAgKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICAgKG9sZFNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhb2xkU2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAgIChuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSAhPT0gbmV3U2NvcGVkU2xvdHMuJGtleSlcbiAgICApO1xuXG4gICAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAgIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAgIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICAgIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICAgICk7XG5cbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gICAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICAgIH1cbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAgIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAgIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAgIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gICAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gICAgLy8gdXBkYXRlIHByb3BzXG4gICAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICB9XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICAvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG4gICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gICAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gICAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gICAgaWYgKGRpcmVjdCkge1xuICAgICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICAgIGlmIChkaXJlY3QpIHtcbiAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGxpZmVjeWNsZSBob29rc1xuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgICB2YXIgaW5mbyA9IGhvb2sgKyBcIiBob29rXCI7XG4gICAgaWYgKGhhbmRsZXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG4gIHZhciBoYXMgPSB7fTtcbiAgdmFyIGNpcmN1bGFyID0ge307XG4gIHZhciB3YWl0aW5nID0gZmFsc2U7XG4gIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gICAqL1xuICBmdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgaGFzID0ge307XG4gICAge1xuICAgICAgY2lyY3VsYXIgPSB7fTtcbiAgICB9XG4gICAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG4gIH1cblxuICAvLyBBc3luYyBlZGdlIGNhc2UgIzY1NjYgcmVxdWlyZXMgc2F2aW5nIHRoZSB0aW1lc3RhbXAgd2hlbiBldmVudCBsaXN0ZW5lcnMgYXJlXG4gIC8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuICAvLyBpZiB0aGUgcGFnZSBoYXMgdGhvdXNhbmRzIG9mIGV2ZW50IGxpc3RlbmVycy4gSW5zdGVhZCwgd2UgdGFrZSBhIHRpbWVzdGFtcFxuICAvLyBldmVyeSB0aW1lIHRoZSBzY2hlZHVsZXIgZmx1c2hlcyBhbmQgdXNlIHRoYXQgZm9yIGFsbCBldmVudCBsaXN0ZW5lcnNcbiAgLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG4gIHZhciBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSAwO1xuXG4gIC8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG4gIHZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuICAvLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxuICAvLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xuICAvLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbiAgLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxuICBpZiAoXG4gICAgaW5Ccm93c2VyICYmXG4gICAgd2luZG93LnBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCA8PSBwZXJmb3JtYW5jZS5ub3coKVxuICApIHtcbiAgICAvLyBpZiB0aGUgZXZlbnQgdGltZXN0YW1wIGlzIGJpZ2dlciB0aGFuIHRoZSBoaS1yZXMgdGltZXN0YW1wXG4gICAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgbG8tcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGxvLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAgICovXG4gIGZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICAgIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAgIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gICAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gICAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gICAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gICAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICAgIHdhdGNoZXIuYmVmb3JlKCk7XG4gICAgICB9XG4gICAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgICBoYXNbaWRdID0gbnVsbDtcbiAgICAgIHdhdGNoZXIucnVuKCk7XG4gICAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgICBpZiAoaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICAgIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gICAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gICAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gICAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgICAvLyBkZXZ0b29sIGhvb2tcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gICAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAgIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICAgKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAgICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgICB9XG4gICAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICAgIGlmICghd2FpdGluZykge1xuICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgdmFyIHVpZCQyID0gMDtcblxuICAvKipcbiAgICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gICAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICAgKi9cbiAgdmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgICB2bSxcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnMsXG4gICAgaXNSZW5kZXJXYXRjaGVyXG4gICkge1xuICAgIHRoaXMudm0gPSB2bTtcbiAgICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gICAgfVxuICAgIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAgIC8vIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jYiA9IGNiO1xuICAgIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gICAgdGhpcy5kZXBzID0gW107XG4gICAgdGhpcy5uZXdEZXBzID0gW107XG4gICAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMuZ2V0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgcHVzaFRhcmdldCh0aGlzKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIHZtID0gdGhpcy52bTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgICB2YXIgaWQgPSBkZXAuaWQ7XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gICAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICAgIHRtcCA9IHRoaXMuZGVwcztcbiAgICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gICAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICAgIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgdGhpcy5kZWVwXG4gICAgICApIHtcbiAgICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICAgKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBub29wLFxuICAgIHNldDogbm9vcFxuICB9O1xuXG4gIGZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICAgIH07XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICAgIHZtLl93YXRjaGVycyA9IFtdO1xuICAgIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gICAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICAgIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICBpbml0RGF0YSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICAgIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICAgIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gICAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICAgIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICAgIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgICAgOiBkYXRhIHx8IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgd2FybihcbiAgICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAge1xuICAgICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ic2VydmUgZGF0YVxuICAgIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgICAgcmV0dXJuIHt9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHBvcFRhcmdldCgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbiAgZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgICB2bSxcbiAgICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgICBub29wLFxuICAgICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICAgIHRhcmdldCxcbiAgICBrZXksXG4gICAgdXNlckRlZlxuICApIHtcbiAgICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgICA6IG5vb3A7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgICB9XG4gICAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBoYW5kbGVyLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICAgIH1cbiAgICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gICAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICAgIHtcbiAgICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICAgIGV4cE9yRm4sXG4gICAgICBjYixcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgdWlkJDMgPSAwO1xuXG4gIGZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgLy8gYSB1aWRcbiAgICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgfVxuXG4gICAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBpbml0UHJveHkodm0pO1xuICAgICAgfVxuICAgICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgICAgdm0uX3NlbGYgPSB2bTtcbiAgICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgICAgaW5pdFN0YXRlKHZtKTtcbiAgICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICAgIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICAgIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICAgIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICBpZiAoQ3Rvci5zdXBlcikge1xuICAgICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gICAgdmFyIG1vZGlmaWVkO1xuICAgIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gICAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZFxuICB9XG5cbiAgZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgICApIHtcbiAgICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIGluaXRNaXhpbihWdWUpO1xuICBzdGF0ZU1peGluKFZ1ZSk7XG4gIGV2ZW50c01peGluKFZ1ZSk7XG4gIGxpZmVjeWNsZU1peGluKFZ1ZSk7XG4gIHJlbmRlck1peGluKFZ1ZSk7XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gICAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cblxuICAgICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICAgKi9cbiAgICBWdWUuY2lkID0gMDtcbiAgICB2YXIgY2lkID0gMTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAgICovXG4gICAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICAgICk7XG4gICAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICAgIH1cbiAgICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgICB9KTtcbiAgICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgICB9XG5cbiAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgICByZXR1cm4gU3ViXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gICAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICAgKi9cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICAgIGlkLFxuICAgICAgICBkZWZpbml0aW9uXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qICAqL1xuXG5cblxuICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gICAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICAgIGNhY2hlLFxuICAgIGtleSxcbiAgICBrZXlzLFxuICAgIGN1cnJlbnRcbiAgKSB7XG4gICAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICB9XG4gICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gIH1cblxuICB2YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbiAgdmFyIEtlZXBBbGl2ZSA9IHtcbiAgICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgICBwcm9wczoge1xuICAgICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB9LFxuXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICAgIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gICAgLy8gY29uZmlnXG4gICAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICAgIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gICAge1xuICAgICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAgIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAgIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAgIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gICAgVnVlLnV0aWwgPSB7XG4gICAgICB3YXJuOiB3YXJuLFxuICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICAgIH07XG5cbiAgICBWdWUuc2V0ID0gc2V0O1xuICAgIFZ1ZS5kZWxldGUgPSBkZWw7XG4gICAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIG9ic2VydmUob2JqKTtcbiAgICAgIHJldHVybiBvYmpcbiAgICB9O1xuXG4gICAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9KTtcblxuICAgIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICAgIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgICBpbml0VXNlKFZ1ZSk7XG4gICAgaW5pdE1peGluJDEoVnVlKTtcbiAgICBpbml0RXh0ZW5kKFZ1ZSk7XG4gICAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG4gIH1cblxuICBpbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gICAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICAgIH1cbiAgfSk7XG5cbiAgLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbiAgfSk7XG5cbiAgVnVlLnZlcnNpb24gPSAnMi42LjknO1xuXG4gIC8qICAqL1xuXG4gIC8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuICAvLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbiAgdmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuICAvLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG4gIHZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbiAgdmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICAgIHJldHVybiAoXG4gICAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICAgIClcbiAgfTtcblxuICB2YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG4gIHZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbiAgdmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgPyAnZmFsc2UnXG4gICAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiAndHJ1ZSdcbiAgfTtcblxuICB2YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbiAgKTtcblxuICB2YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxuICB2YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xuICB9O1xuXG4gIHZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xuICB9O1xuXG4gIHZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gICAgc3RhdGljQ2xhc3MsXG4gICAgZHluYW1pY0NsYXNzXG4gICkge1xuICAgIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICAgIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICAgIHZhciByZXMgPSAnJztcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgICByZXMgKz0ga2V5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbmFtZXNwYWNlTWFwID0ge1xuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbiAgfTtcblxuICB2YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAgICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAgICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuICApO1xuXG4gIC8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuICAvLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxuICB2YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAgICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgICB0cnVlXG4gICk7XG5cbiAgdmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxuICB2YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gICAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICAgIHJldHVybiAnc3ZnJ1xuICAgIH1cbiAgICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgICByZXR1cm4gJ21hdGgnXG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3Nlcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICAgIH1cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICAgICkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgICB9XG4gIH1cblxuICB2YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RlZFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gICAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgICByZXR1cm4gZWxtXG4gICAgfVxuICAgIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gICAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gICAgfVxuICAgIHJldHVybiBlbG1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG4gIH1cblxuICBmdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG4gIH1cblxuICBmdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG4gIH1cblxuICB2YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG4gICAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gICAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICAgIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gICAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gICAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIHZhciByZWYgPSB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gICAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gICAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gICAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICAgKlxuICAgKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAgICpcbiAgICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICAgKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAgICovXG5cbiAgdmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxuICB2YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuICBmdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgICAgKFxuICAgICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICAgICkgfHwgKFxuICAgICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICAgIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgdmFyIGk7XG4gICAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICAgIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgICB2YXIgaSwga2V5O1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgY2JzID0ge307XG5cbiAgICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgICAgcmV0dXJuIHJlbW92ZSQkMVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAhaW5WUHJlICYmXG4gICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAhKFxuICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgICAgfSlcbiAgICAgICAgKSAmJlxuICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgICApXG4gICAgfVxuXG4gICAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgICB2bm9kZSxcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgIHBhcmVudEVsbSxcbiAgICAgIHJlZkVsbSxcbiAgICAgIG5lc3RlZCxcbiAgICAgIG93bmVyQXJyYXksXG4gICAgICBpbmRleFxuICAgICkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgIH1cblxuICAgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAgIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgICB2YXIgaSwgajtcbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgICB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgICAgb2xkVm5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgIG93bmVyQXJyYXksXG4gICAgICBpbmRleCxcbiAgICAgIHJlbW92ZU9ubHlcbiAgICApIHtcbiAgICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgICApIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gICAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAgIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAgIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICAgIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICAgIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgICAge1xuICAgICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICAgIHJldHVybiB2bm9kZS5lbG1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgZGlyZWN0aXZlcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gICAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gICAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gICAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgICBpZiAoIW9sZERpcikge1xuICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gICAgZGlycyxcbiAgICB2bVxuICApIHtcbiAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoIWRpcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgICB2YXIgaSwgZGlyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkaXIgPSBkaXJzW2ldO1xuICAgICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgICB9XG4gICAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICAgIH1cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICAgIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZU1vZHVsZXMgPSBbXG4gICAgcmVmLFxuICAgIGRpcmVjdGl2ZXNcbiAgXTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBrZXksIGN1ciwgb2xkO1xuICAgIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gICAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICA6IGtleTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXG4gICAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0cnMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICAgIGlmIChcbiAgICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gICAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBjbGFzc1xuICAgIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgICB9XG4gIH1cblxuICB2YXIga2xhc3MgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbiAgZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gICAgdmFyIGN1cmx5ID0gMDtcbiAgICB2YXIgc3F1YXJlID0gMDtcbiAgICB2YXIgcGFyZW4gPSAwO1xuICAgIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICAgIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgICAgcHJldiA9IGM7XG4gICAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICAgKSB7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgICBwdXNoRmlsdGVyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uXG4gIH1cblxuICBmdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICAgIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIGZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gICAgbW9kdWxlcyxcbiAgICBrZXlcbiAgKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNcbiAgICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgICAgOiBbXVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICAgIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgICB2YXIgYXR0cnMgPSBkeW5hbWljXG4gICAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gICAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG4gIGZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UpIHtcbiAgICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICAgIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgICBlbCxcbiAgICBuYW1lLFxuICAgIHJhd05hbWUsXG4gICAgdmFsdWUsXG4gICAgYXJnLFxuICAgIGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnMsXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYXJnOiBhcmcsXG4gICAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgICByZXR1cm4gZHluYW1pY1xuICAgICAgPyAoXCJfcChcIiArIG5hbWUgKyBcIixcXFwiXCIgKyBzeW1ib2wgKyBcIlxcXCIpXCIpXG4gICAgICA6IHN5bWJvbCArIG5hbWUgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICAgIGVsLFxuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzLFxuICAgIGltcG9ydGFudCxcbiAgICB3YXJuLFxuICAgIHJhbmdlLFxuICAgIGR5bmFtaWNcbiAgKSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIHdhcm4gJiZcbiAgICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gICAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICAgIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cztcbiAgICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKTtcbiAgICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gICAgfVxuXG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdXG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICBnZXRTdGF0aWNcbiAgKSB7XG4gICAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gICAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbiAgLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4gIC8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbiAgZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICByZW1vdmVGcm9tTWFwXG4gICkge1xuICAgIHZhciB2YWw7XG4gICAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gbGlzdFtpXTtcbiAgICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGF0dHJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICAgIGl0ZW0sXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICAgIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICAgIGlmICh0cmltKSB7XG4gICAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gICAgfVxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgICB9XG4gICAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICAgIGVsLm1vZGVsID0ge1xuICAgICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gICAqL1xuICBmdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gICAgdmFsdWUsXG4gICAgYXNzaWdubWVudFxuICApIHtcbiAgICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gICAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCIkc2V0KFwiICsgKHJlcy5leHApICsgXCIsIFwiICsgKHJlcy5rZXkpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICAgKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAgICpcbiAgICogUG9zc2libGUgY2FzZXM6XG4gICAqXG4gICAqIC0gdGVzdFxuICAgKiAtIHRlc3Rba2V5XVxuICAgKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAgICogLSB0ZXN0W1wiYVwiXVtrZXldXG4gICAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICAgKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAgICpcbiAgICovXG5cbiAgdmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAgIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAgIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICAgIHZhbCA9IHZhbC50cmltKCk7XG4gICAgbGVuID0gdmFsLmxlbmd0aDtcblxuICAgIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV4cDogdmFsLFxuICAgICAgICAgIGtleTogbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyID0gdmFsO1xuICAgIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICBjaHIgPSBuZXh0KCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG4gIH1cblxuICBmdW5jdGlvbiBlb2YgKCkge1xuICAgIHJldHVybiBpbmRleCQxID49IGxlblxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gICAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4MjdcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gICAgdmFyIGluQnJhY2tldCA9IDE7XG4gICAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gICAgd2hpbGUgKCFlb2YoKSkge1xuICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gICAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICAgIHdoaWxlICghZW9mKCkpIHtcbiAgICAgIGNociA9IG5leHQoKTtcbiAgICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHdhcm4kMTtcblxuICAvLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4gIC8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG4gIHZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xuICB2YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuICBmdW5jdGlvbiBtb2RlbCAoXG4gICAgZWwsXG4gICAgZGlyLFxuICAgIF93YXJuXG4gICkge1xuICAgIHdhcm4kMSA9IF93YXJuO1xuICAgIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgICB2YXIgdGFnID0gZWwudGFnO1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gICAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gICAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gICAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICAgKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgICAgbnVsbCwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICAgIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICAgIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gICAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gICAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4gICkge1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gICAge1xuICAgICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgICBpZiAodmFsdWUkMSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gICAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gICAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICAgIHZhciBldmVudCA9IGxhenlcbiAgICAgID8gJ2NoYW5nZSdcbiAgICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICAgIDogJ2lucHV0JztcblxuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgICB9XG4gICAgaWYgKG51bWJlcikge1xuICAgICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gICAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICAgIH1cblxuICAgIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gICAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbiAgLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuICAvLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4gIC8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICAgIH1cbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAgIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhcmdldCQxO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuICAvLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4gIC8vIHNhZmUgdG8gZXhjbHVkZS5cbiAgdmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbiAgZnVuY3Rpb24gYWRkJDEgKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBjYXB0dXJlLFxuICAgIHBhc3NpdmVcbiAgKSB7XG4gICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gICAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgICAgdmFyIGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgLy8gIzk0NjIgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAgIC8vICM5NjgxIFF0V2ViRW5naW5lIGV2ZW50LnRpbWVTdGFtcCBpcyBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcbiAgICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgICAgLy8gZWxlY3Ryb24vbncuanMgYXBwLCBzaW5jZSBldmVudC50aW1lU3RhbXAgd2lsbCBiZSB1c2luZyBhIGRpZmZlcmVudFxuICAgICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBuYW1lLFxuICAgICAgaGFuZGxlcixcbiAgICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICAgIDogY2FwdHVyZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUkMiAoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIGNhcHR1cmUsXG4gICAgX3RhcmdldFxuICApIHtcbiAgICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIG5hbWUsXG4gICAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsXG4gICAgICBjYXB0dXJlXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gICAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgICBub3JtYWxpemVFdmVudHMob24pO1xuICAgIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gICAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgZXZlbnRzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICAgIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHN2Z0NvbnRhaW5lcjtcblxuICBmdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBrZXksIGN1cjtcbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICAgIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgIGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG4gICAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09PSAndmFsdWUnICYmIGVsbS50YWdOYW1lICE9PSAnUFJPR1JFU1MnKSB7XG4gICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBzdHJDdXIpKSB7XG4gICAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgJiYgaXNTVkcoZWxtLnRhZ05hbWUpICYmIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXG4gICAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IFwiPHN2Zz5cIiArIGN1ciArIFwiPC9zdmc+XCI7XG4gICAgICAgIHZhciBzdmcgPSBzdmdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgICAgLy8gYHZhbHVlYCBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgYmVjYXVzZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxuICAgICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc2FycnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgICAgY3VyICE9PSBvbGRQcm9wc1trZXldXG4gICAgICApIHtcbiAgICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xuICAgICAgICAvLyBlLmcuIGB2YWx1ZWAgb24gPHByb2dyZXNzPiB3LyBub24tZmluaXRlIHZhbHVlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuICBmdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICAgIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgICApKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gICAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gICAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xuICAgIC8vICM2MTU3XG4gICAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gICAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG4gIH1cblxuICBmdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gICAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gICAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICAgIH1cbiAgICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG4gIH1cblxuICB2YXIgZG9tUHJvcHMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICAgIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc1xuICB9KTtcblxuICAvLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuICBmdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gICAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gICAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgICA6IHN0eWxlXG4gIH1cblxuICAvLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICAgIH1cbiAgICByZXR1cm4gYmluZGluZ1N0eWxlXG4gIH1cblxuICAvKipcbiAgICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICAgKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBzdHlsZURhdGE7XG5cbiAgICBpZiAoY2hlY2tDaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgICAgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpXG4gICAgICAgICkge1xuICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgY3NzVmFyUkUgPSAvXi0tLztcbiAgdmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG4gIHZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbiAgdmFyIGVtcHR5U3R5bGU7XG4gIHZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gICAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgICByZXR1cm4gcHJvcFxuICAgIH1cbiAgICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgICByZXR1cm4gbmFtZVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjdXIsIG5hbWU7XG4gICAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICAgIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gICAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICAgIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICAgIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAgIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gICAgLy8gdG8gbXV0YXRlIGl0LlxuICAgIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgICAgOiBzdHlsZTtcblxuICAgIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICAgIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBzdHlsZSA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICAgIHVwZGF0ZTogdXBkYXRlU3R5bGVcbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4gIC8qKlxuICAgKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAgICogU1ZHIGVsZW1lbnRzIGluIElFXG4gICAqL1xuICBmdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gICAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICB9XG4gICAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgICAgfVxuICAgICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICAgIGlmICghZGVmJCQxKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICAgIH1cbiAgICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgICByZXR1cm4gcmVzXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgICB9XG4gIH1cblxuICB2YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gICAgfVxuICB9KTtcblxuICB2YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG4gIHZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuICB2YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbiAgLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xuICB2YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG4gIHZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG4gIHZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG4gIHZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuICBpZiAoaGFzVHJhbnNpdGlvbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gICAgfVxuICAgIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gICAgfVxuICB9XG5cbiAgLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG4gIHZhciByYWYgPSBpbkJyb3dzZXJcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICAgIDogc2V0VGltZW91dFxuICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbigpOyB9O1xuXG4gIGZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgICByYWYoZnVuY3Rpb24gKCkge1xuICAgICAgcmFmKGZuKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICAgIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICAgIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICAgIH1cbiAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gICAgZWwsXG4gICAgZXhwZWN0ZWRUeXBlLFxuICAgIGNiXG4gICkge1xuICAgIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gICAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gICAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gICAgdmFyIGVuZGVkID0gMDtcbiAgICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgICAgY2IoKTtcbiAgICB9O1xuICAgIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICAgIGVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9LCB0aW1lb3V0ICsgMSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICB9XG5cbiAgdmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICAgIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICAgIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICAgIHZhciB0eXBlO1xuICAgIHZhciB0aW1lb3V0ID0gMDtcbiAgICB2YXIgcHJvcENvdW50ID0gMDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICAgIDogQU5JTUFUSU9OXG4gICAgICAgIDogbnVsbDtcbiAgICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IDA7XG4gICAgfVxuICAgIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgICB9KSlcbiAgfVxuXG4gIC8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbiAgLy8gaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxuICAvLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuICAvLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG4gIGZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAgIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gICAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIGVsLl9sZWF2ZUNiKCk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gICAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gICAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gICAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICAgIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICAgIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gICAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gICAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICAgIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gICAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gICAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gICAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICAgIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gICAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICAgIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gICAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gICAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIH1cblxuICAgIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICAgIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICAgID8gYXBwZWFyQ2xhc3NcbiAgICAgIDogZW50ZXJDbGFzcztcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICAgIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgICA6IGVudGVyVG9DbGFzcztcblxuICAgIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgICAgOiBiZWZvcmVFbnRlcjtcbiAgICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICAgIDogZW50ZXI7XG4gICAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgICA6IGFmdGVyRW50ZXI7XG4gICAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gICAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgICAgOiBkdXJhdGlvblxuICAgICk7XG5cbiAgICBpZiAoZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICAgIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgICAgfVxuICAgICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICAgICkge1xuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgICB9XG4gICAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH1cblxuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gICAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gICAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgZWwuX2VudGVyQ2IoKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gICAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIHJldHVybiBybSgpXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICAgIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICAgIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gICAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gICAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gICAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gICAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgICAgOiBkdXJhdGlvblxuICAgICk7XG5cbiAgICBpZiAoaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgICB9KTtcblxuICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgICAgaWYgKCF2bm9kZS5kYXRhLnNob3cgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbiAgZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgICAgd2FybihcbiAgICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAgICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gICAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICAgKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gICAqL1xuICBmdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICAgIGlmIChpc1VuZGVmKGZuKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICAgIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgICAgLy8gaW52b2tlclxuICAgICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgICA6IGludm9rZXJGbnNcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGVudGVyKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgICBjcmVhdGU6IF9lbnRlcixcbiAgICBhY3RpdmF0ZTogX2VudGVyLFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSA6IHt9O1xuXG4gIHZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gICAgYXR0cnMsXG4gICAga2xhc3MsXG4gICAgZXZlbnRzLFxuICAgIGRvbVByb3BzLFxuICAgIHN0eWxlLFxuICAgIHRyYW5zaXRpb25cbiAgXTtcblxuICAvKiAgKi9cblxuICAvLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbiAgLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbiAgdmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxuICB2YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuICAvKipcbiAgICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gICAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gICAqL1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkpIHtcbiAgICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBkaXJlY3RpdmUgPSB7XG4gICAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICAvLyAjNjkwM1xuICAgICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICAgIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNNdWx0aXBsZSkge1xuICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZhbHVlIChvcHRpb24pIHtcbiAgICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICAgIDogb3B0aW9uLnZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAgIC8vIHByZXZlbnQgdHJpZ2dlcmluZyBhbiBpbnB1dCBldmVudCBmb3Igbm8gcmVhc29uXG4gICAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICAgIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICAgIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG4gIH1cblxuICAvKiAgKi9cblxuICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG4gIGZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICAgIDogdm5vZGVcbiAgfVxuXG4gIHZhciBzaG93ID0ge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgICBlbCxcbiAgICAgIGJpbmRpbmcsXG4gICAgICB2bm9kZSxcbiAgICAgIG9sZFZub2RlLFxuICAgICAgaXNEZXN0cm95XG4gICAgKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICAgIG1vZGVsOiBkaXJlY3RpdmUsXG4gICAgc2hvdzogc2hvd1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gICAgbmFtZTogU3RyaW5nLFxuICAgIGFwcGVhcjogQm9vbGVhbixcbiAgICBjc3M6IEJvb2xlYW4sXG4gICAgbW9kZTogU3RyaW5nLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVDbGFzczogU3RyaW5nLFxuICAgIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICAgIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG4gIH07XG5cbiAgLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4gIC8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG4gIGZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICAgIHZhciBkYXRhID0ge307XG4gICAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAgIC8vIHByb3BzXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gICAgfVxuICAgIC8vIGV2ZW50cy5cbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIGZvciAodmFyIGtleSQxIGluIGxpc3RlbmVycykge1xuICAgICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICAgIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbiAgfVxuXG4gIHZhciBpc05vdFRleHROb2RlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfTtcblxuICB2YXIgaXNWU2hvd0RpcmVjdGl2ZSA9IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfTtcblxuICB2YXIgVHJhbnNpdGlvbiA9IHtcbiAgICBuYW1lOiAndHJhbnNpdGlvbicsXG4gICAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgICBhYnN0cmFjdDogdHJ1ZSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICAgIGlmIChtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgICApIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIHJldHVybiByYXdDaGlsZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9XG5cbiAgICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAgIC8vIG1hcmsgdi1zaG93XG4gICAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBvbGRDaGlsZCAmJlxuICAgICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICAgICkge1xuICAgICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgcHJvcHMgPSBleHRlbmQoe1xuICAgIHRhZzogU3RyaW5nLFxuICAgIG1vdmVDbGFzczogU3RyaW5nXG4gIH0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbiAgZGVsZXRlIHByb3BzLm1vZGU7XG5cbiAgdmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICBiZWZvcmVNb3VudDogZnVuY3Rpb24gYmVmb3JlTW91bnQgKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG4gICAgICB0aGlzLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgICAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2UodGhpcyQxKTtcbiAgICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgICAgICB0aGlzJDEuX19wYXRjaF9fKFxuICAgICAgICAgIHRoaXMkMS5fdm5vZGUsXG4gICAgICAgICAgdGhpcyQxLmtlcHQsXG4gICAgICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgICApO1xuICAgICAgICB0aGlzJDEuX3Zub2RlID0gdGhpcyQxLmtlcHQ7XG4gICAgICAgIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSgpO1xuICAgICAgICB1cGRhdGUuY2FsbCh0aGlzJDEsIHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjLnRhZykge1xuICAgICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICAgIH0sXG5cbiAgICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICAgIH1cbiAgICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgICBjLmVsbS5fbW92ZUNiKCk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICAgIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICAgIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICAgIGlmIChkeCB8fCBkeSkge1xuICAgICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICAgIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG4gIH07XG5cbiAgLyogICovXG5cbiAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuICBWdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG4gIFZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG4gIFZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcbiAgVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG4gIFZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbiAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG4gIGV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuICAvLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG4gIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4gIC8vIHB1YmxpYyBtb3VudCBtZXRob2RcbiAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gICAgZWwsXG4gICAgaHlkcmF0aW5nXG4gICkge1xuICAgIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxuICB9O1xuXG4gIC8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmIChpbkJyb3dzZXIpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxccj9cXG4pKz8pXFx9XFx9L2c7XG4gIHZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxuICB2YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICAgIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG4gIH0pO1xuXG5cblxuICBmdW5jdGlvbiBwYXJzZVRleHQgKFxuICAgIHRleHQsXG4gICAgZGVsaW1pdGVyc1xuICApIHtcbiAgICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgdG9rZW5zID0gW107XG4gICAgdmFyIHJhd1Rva2VucyA9IFtdO1xuICAgIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gICAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgICB9XG4gICAgICAvLyB0YWcgdG9rZW5cbiAgICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBleHByZXNzaW9uOiB0b2tlbnMuam9pbignKycpLFxuICAgICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICAgIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICAgIGlmIChzdGF0aWNDbGFzcykge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ2NsYXNzJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgICB9XG4gICAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICAgIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICAgIHZhciBkYXRhID0gJyc7XG4gICAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICB2YXIga2xhc3MkMSA9IHtcbiAgICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gICAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgICBnZW5EYXRhOiBnZW5EYXRhXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICAgIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICAgIGlmIChzdGF0aWNTdHlsZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLFxuICAgICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3N0eWxlJ11cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICAgIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gICAgdmFyIGRhdGEgPSAnJztcbiAgICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgICB9XG4gICAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgdmFyIHN0eWxlJDEgPSB7XG4gICAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgICBnZW5EYXRhOiBnZW5EYXRhJDFcbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgZGVjb2RlcjtcblxuICB2YXIgaGUgPSB7XG4gICAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbiAgICB9XG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAgICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4gICk7XG5cbiAgLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4gIC8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAgICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuICApO1xuXG4gIC8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbiAgLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG4gIHZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAgICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAgICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICAgJ3RpdGxlLHRyLHRyYWNrJ1xuICApO1xuXG4gIC8qKlxuICAgKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAgICovXG5cbiAgLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbiAgdmFyIGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxccyooKD86di1bXFx3LV0rOnxAfDp8IylcXFtbXj1dK1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4gIHZhciBuY25hbWUgPSBcIlthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSpcIjtcbiAgdmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiICsgbmNuYW1lICsgXCJcXFxcOik/XCIgKyBuY25hbWUgKyBcIilcIjtcbiAgdmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoKFwiXjxcIiArIHFuYW1lQ2FwdHVyZSkpO1xuICB2YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xuICB2YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXCJePFxcXFwvXCIgKyBxbmFtZUNhcHR1cmUgKyBcIltePl0qPlwiKSk7XG4gIHZhciBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4gIC8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcbiAgdmFyIGNvbW1lbnQgPSAvXjwhXFwtLS87XG4gIHZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuICAvLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbiAgdmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xuICB2YXIgcmVDYWNoZSA9IHt9O1xuXG4gIHZhciBkZWNvZGluZ01hcCA9IHtcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyYjMTA7JzogJ1xcbicsXG4gICAgJyYjOTsnOiAnXFx0JyxcbiAgICAnJiMzOTsnOiBcIidcIlxuICB9O1xuICB2YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOSk7L2c7XG4gIHZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5fCMxMHwjOSk7L2c7XG5cbiAgLy8gIzU5OTJcbiAgdmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xuICB2YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICAgIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsYXN0LCBsYXN0VGFnO1xuICAgIHdoaWxlIChodG1sKSB7XG4gICAgICBsYXN0ID0gaHRtbDtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpLCBpbmRleCwgaW5kZXggKyBjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhcnRUYWdNYXRjaC50YWdOYW1lLCBodG1sKSkge1xuICAgICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH0pO1xuICAgICAgICBpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QkMS5sZW5ndGg7XG4gICAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgICAgaWYgKCFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICAgIHBhcnNlRW5kVGFnKCk7XG5cbiAgICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgICBpbmRleCArPSBuO1xuICAgICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgICBhdHRyczogW10sXG4gICAgICAgICAgc3RhcnQ6IGluZGV4XG4gICAgICAgIH07XG4gICAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgICAgdmFyIGVuZCwgYXR0cjtcbiAgICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgICBhdHRyLnN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBhcmdzLnN0YXJ0ICsgYXJnc1swXS5tYXRjaCgvXlxccyovKS5sZW5ndGg7XG4gICAgICAgICAgYXR0cnNbaV0uZW5kID0gYXJncy5lbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycywgc3RhcnQ6IG1hdGNoLnN0YXJ0LCBlbmQ6IG1hdGNoLmVuZCB9KTtcbiAgICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG4gICAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgICAgcG9zID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgICAgaWYgKGkgPiBwb3MgfHwgIXRhZ05hbWUgJiZcbiAgICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICAgICkge1xuICAgICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpLFxuICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFja1tpXS5zdGFydCwgZW5kOiBzdGFja1tpXS5lbmQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgb25SRSA9IC9eQHxedi1vbjovO1xuICB2YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbiAgdmFyIGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG4gIHZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuICB2YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbiAgdmFyIGR5bmFtaWNBcmdSRSA9IC9eXFxbLipcXF0kLztcblxuICB2YXIgYXJnUkUgPSAvOiguKikkLztcbiAgdmFyIGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbiAgdmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZztcblxuICB2YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbiAgdmFyIGxpbmVCcmVha1JFID0gL1tcXHJcXG5dLztcbiAgdmFyIHdoaXRlc3BhY2VSRSQxID0gL1xccysvZztcblxuICB2YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxuICB2YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG4gIHZhciBlbXB0eVNsb3RTY29wZVRva2VuID0gXCJfZW1wdHlfXCI7XG5cbiAgLy8gY29uZmlndXJhYmxlIHN0YXRlXG4gIHZhciB3YXJuJDI7XG4gIHZhciBkZWxpbWl0ZXJzO1xuICB2YXIgdHJhbnNmb3JtcztcbiAgdmFyIHByZVRyYW5zZm9ybXM7XG4gIHZhciBwb3N0VHJhbnNmb3JtcztcbiAgdmFyIHBsYXRmb3JtSXNQcmVUYWc7XG4gIHZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xuICB2YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG4gIHZhciBtYXliZUNvbXBvbmVudDtcblxuICBmdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgICB0YWcsXG4gICAgYXR0cnMsXG4gICAgcGFyZW50XG4gICkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAxLFxuICAgICAgdGFnOiB0YWcsXG4gICAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICByYXdBdHRyc01hcDoge30sXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICAgIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICAgIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICAgIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gICAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgbWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG5cbiAgICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gICAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICAgIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gICAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gICAgdmFyIHdoaXRlc3BhY2VPcHRpb24gPSBvcHRpb25zLndoaXRlc3BhY2U7XG4gICAgdmFyIHJvb3Q7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gICAgdmFyIGluVlByZSA9IGZhbHNlO1xuICAgIHZhciBpblByZSA9IGZhbHNlO1xuICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2csIHJhbmdlKSB7XG4gICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICB3YXJuJDIobXNnLCByYW5nZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XG4gICAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICAgIGlmICghaW5WUHJlICYmICFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICBlbGVtZW50ID0gcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghc3RhY2subGVuZ3RoICYmIGVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgICAvLyBrZWVwIGl0IGluIHRoZSBjaGlsZHJlbiBsaXN0IHNvIHRoYXQgdi1lbHNlKC1pZikgY29uZGl0aW9ucyBjYW5cbiAgICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIidcbiAgICAgICAgICAgIDsoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyB8fCAoY3VycmVudFBhcmVudC5zY29wZWRTbG90cyA9IHt9KSlbbmFtZV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmFsIGNoaWxkcmVuIGNsZWFudXBcbiAgICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgICBlbGVtZW50LmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICEoYykuc2xvdFNjb3BlOyB9KTtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyaW1FbmRpbmdXaGl0ZXNwYWNlIChlbCkge1xuICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZVxuICAgICAgaWYgKCFpblByZSkge1xuICAgICAgICB2YXIgbGFzdE5vZGU7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgICBsYXN0Tm9kZS50eXBlID09PSAzICYmXG4gICAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnXG4gICAgICAgICkge1xuICAgICAgICAgIGVsLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgICAgd2Fybjogd2FybiQyLFxuICAgICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgICBvdXRwdXRTb3VyY2VSYW5nZTogb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSxcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0JDEsIGVuZCkge1xuICAgICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG4gICAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3RhcnQgPSBzdGFydCQxO1xuICAgICAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgICByZXR1cm4gY3VtdWxhdGVkXG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gXCIgK1xuICAgICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGVuZDogZnVuY3Rpb24gZW5kICh0YWcsIHN0YXJ0LCBlbmQkMSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBwb3Agc3RhY2tcbiAgICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LicsXG4gICAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XG4gICAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIHdoaXRlc3BhY2Utb25seSBub2RlIHJpZ2h0IGFmdGVyIGFuIG9wZW5pbmcgdGFnXG4gICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgICAvLyBjb25kZW5zZSBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlcyBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSh3aGl0ZXNwYWNlUkUkMSwgJyAnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlcztcbiAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcbiAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICAvLyBhZGRpbmcgYW55dGluZyBhcyBhIHNpYmxpbmcgdG8gdGhlIHJvb3Qgbm9kZSBpcyBmb3JiaWRkZW5cbiAgICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvb3RcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICAgIGVsLnByZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBpZiAobGVuKSB7XG4gICAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGxpc3RbaV0udmFsdWUpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGxpc3RbaV0uc3RhcnQ7XG4gICAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRWxlbWVudCAoXG4gICAgZWxlbWVudCxcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICAgIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAgICFlbGVtZW50LnNjb3BlZFNsb3RzICYmXG4gICAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICAgKTtcblxuICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICAgIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgIH1cbiAgICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gICAgcmV0dXJuIGVsZW1lbnRcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gICAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gICAgaWYgKGV4cCkge1xuICAgICAge1xuICAgICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwuZm9yKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICAgIGlmIChpdGVyYXRvciAmJiBpdGVyYXRvciA9PT0gZXhwICYmIHBhcmVudCAmJiBwYXJlbnQudGFnID09PSAndHJhbnNpdGlvbi1ncm91cCcpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcbiAgICAgICAgICAgICAgXCJ0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLlwiLFxuICAgICAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLFxuICAgICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsLmtleSA9IGV4cDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICAgIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICAgIGlmIChyZWYpIHtcbiAgICAgIGVsLnJlZiA9IHJlZjtcbiAgICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgICB2YXIgZXhwO1xuICAgIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9yIChleHApIHtcbiAgICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgICB2YXIgcmVzID0ge307XG4gICAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICBlbC5pZiA9IGV4cDtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICAgIGV4cDogZXhwLFxuICAgICAgICBibG9jazogZWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgICAgaWYgKGVsc2VpZikge1xuICAgICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICAgIHZhciBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gICAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgICAgYmxvY2s6IGVsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICAgIFwid2lsbCBiZSBpZ25vcmVkLlwiLFxuICAgICAgICAgICAgY2hpbGRyZW5baV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gICAgdmFyIG9uY2UkJDEgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XG4gICAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgICAgZWwub25jZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4gIC8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxuICBmdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQgKGVsKSB7XG4gICAgdmFyIHNsb3RTY29wZTtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHNsb3RTY29wZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICAgIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPFwiICsgKGVsLnRhZykgKyBcIj4gXCIgK1xuICAgICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgICB9XG5cbiAgICAvLyBzbG90PVwieHh4XCJcbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAgICB7XG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICAgIHZhciBzbG90QmluZGluZyA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xuICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgXCI8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIFwiICtcbiAgICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgdGhlIGNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZWYgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICAgICAgICB2YXIgZHluYW1pYyA9IHJlZi5keW5hbWljO1xuICAgICAgICAgIGVsLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcbiAgICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgICAgdmFyIHNsb3RCaW5kaW5nJDEgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgICAgaWYgKHNsb3RCaW5kaW5nJDEpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIW1heWJlQ29tcG9uZW50KGVsKSkge1xuICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgXCJ2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4uXCIsXG4gICAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsXG4gICAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgXCJUbyBhdm9pZCBzY29wZSBhbWJpZ3VpdHksIHRoZSBkZWZhdWx0IHNsb3Qgc2hvdWxkIGFsc28gdXNlIFwiICtcbiAgICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLlwiLFxuICAgICAgICAgICAgICAgIHNsb3RCaW5kaW5nJDFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYWRkIHRoZSBjb21wb25lbnQncyBjaGlsZHJlbiB0byBpdHMgZGVmYXVsdCBzbG90XG4gICAgICAgICAgdmFyIHNsb3RzID0gZWwuc2NvcGVkU2xvdHMgfHwgKGVsLnNjb3BlZFNsb3RzID0ge30pO1xuICAgICAgICAgIHZhciByZWYkMSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nJDEpO1xuICAgICAgICAgIHZhciBuYW1lJDEgPSByZWYkMS5uYW1lO1xuICAgICAgICAgIHZhciBkeW5hbWljJDEgPSByZWYkMS5keW5hbWljO1xuICAgICAgICAgIHZhciBzbG90Q29udGFpbmVyID0gc2xvdHNbbmFtZSQxXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXQgPSBuYW1lJDE7XG4gICAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWMkMTtcbiAgICAgICAgICBzbG90Q29udGFpbmVyLmNoaWxkcmVuID0gZWwuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICBpZiAoIWMuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICAgIGMucGFyZW50ID0gc2xvdENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nJDEudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgICAvLyByZW1vdmUgY2hpbGRyZW4gYXMgdGhleSBhcmUgcmV0dXJuZWQgZnJvbSBzY29wZWRTbG90cyBub3dcbiAgICAgICAgICBlbC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgICB2YXIgbmFtZSA9IGJpbmRpbmcubmFtZS5yZXBsYWNlKHNsb3RSRSwgJycpO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICAgIG5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5cIixcbiAgICAgICAgICBiaW5kaW5nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkeW5hbWljQXJnUkUudGVzdChuYW1lKVxuICAgICAgLy8gZHluYW1pYyBbbmFtZV1cbiAgICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgICAvLyBzdGF0aWMgbmFtZVxuICAgICAgOiB7IG5hbWU6IChcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIiksIGR5bmFtaWM6IGZhbHNlIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSA8c2xvdC8+IG91dGxldHNcbiAgZnVuY3Rpb24gcHJvY2Vzc1Nsb3RPdXRsZXQgKGVsKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgICAgaWYgKGVsLmtleSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJga2V5YCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIFwiICtcbiAgICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiLFxuICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICAgIHZhciBiaW5kaW5nO1xuICAgIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gICAgfVxuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgc3luY0dlbiwgaXNEeW5hbWljO1xuICAgIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAgIC8vIHN1cHBvcnQgLmZvbyBzaG9ydGhhbmQgc3ludGF4IGZvciB0aGUgLnByb3AgbW9kaWZpZXJcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgKFwiVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXFxcInYtYmluZDpcIiArIG5hbWUgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpO1xuICAgICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUobmFtZSkgIT09IGNhbWVsaXplKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGh5cGhlbmF0ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGVyIHcvIGR5bmFtaWMgZXZlbnQgbmFtZVxuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIChcIlxcXCJ1cGRhdGU6XFxcIisoXCIgKyBuYW1lICsgXCIpXCIpLFxuICAgICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgICB0cnVlIC8vIGR5bmFtaWNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgIH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICAgIHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgICBpc0R5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBsaXN0W2ldKTtcbiAgICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcbiAgICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJywgbGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBlbDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gICAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciByZXQgPSB7fTtcbiAgICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuICAgICAgKSB7XG4gICAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICAgIH1cbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbiAgZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICAgIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICAgKSlcbiAgICApXG4gIH1cblxuICB2YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbiAgdmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gICAgdmFyIF9lbCA9IGVsO1xuICAgIHdoaWxlIChfZWwpIHtcbiAgICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgICBcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcbiAgICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgICB2YXIgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZUJpbmRpbmc7XG4gICAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgICB0eXBlQmluZGluZyA9IFwiKFwiICsgKG1hcFsndi1iaW5kJ10pICsgXCIpLnR5cGVcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICAgIHZhciBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcbiAgICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgICAgdmFyIGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXG4gICAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XG4gICAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxuICAgICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cbiAgICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcbiAgICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gMy4gb3RoZXJcbiAgICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDIsICd2LWZvcicsIHRydWUpO1xuICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbHNlSWZDb25kaXRpb24pIHtcbiAgICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBicmFuY2gwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICAgIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbiAgfVxuXG4gIHZhciBtb2RlbCQxID0ge1xuICAgIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbiAgfTtcblxuICB2YXIgbW9kdWxlcyQxID0gW1xuICAgIGtsYXNzJDEsXG4gICAgc3R5bGUkMSxcbiAgICBtb2RlbCQxXG4gIF07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICAgIGlmIChkaXIudmFsdWUpIHtcbiAgICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaHRtbCAoZWwsIGRpcikge1xuICAgIGlmIChkaXIudmFsdWUpIHtcbiAgICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkaXJlY3RpdmVzJDEgPSB7XG4gICAgbW9kZWw6IG1vZGVsLFxuICAgIHRleHQ6IHRleHQsXG4gICAgaHRtbDogaHRtbFxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBiYXNlT3B0aW9ucyA9IHtcbiAgICBleHBlY3RIVE1MOiB0cnVlLFxuICAgIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gICAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICAgIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gICAgbXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gICAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgICBnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcbiAgICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgaXNTdGF0aWNLZXk7XG4gIHZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbiAgdmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyQxKTtcblxuICAvKipcbiAgICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAgICogYW5kIGRldGVjdCBzdWItdHJlZXMgdGhhdCBhcmUgcHVyZWx5IHN0YXRpYywgaS5lLiBwYXJ0cyBvZlxuICAgKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICAgKlxuICAgKiBPbmNlIHdlIGRldGVjdCB0aGVzZSBzdWItdHJlZXMsIHdlIGNhbjpcbiAgICpcbiAgICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICAgKiAgICBjcmVhdGUgZnJlc2ggbm9kZXMgZm9yIHRoZW0gb24gZWFjaCByZS1yZW5kZXI7XG4gICAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICAgKi9cbiAgZnVuY3Rpb24gb3B0aW1pemUgKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgICBtYXJrU3RhdGljJDEocm9vdCk7XG4gICAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICAgIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgICByZXR1cm4gbWFrZU1hcChcbiAgICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICAgIGlmIChcbiAgICAgICAgIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2s7XG4gICAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgICAgfVxuICAgICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgICApKSB7XG4gICAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgICApKVxuICB9XG5cbiAgZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmZvcikge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbiAgdmFyIGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbiAgdmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbiAgLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbiAgdmFyIGtleUNvZGVzID0ge1xuICAgIGVzYzogMjcsXG4gICAgdGFiOiA5LFxuICAgIGVudGVyOiAxMyxcbiAgICBzcGFjZTogMzIsXG4gICAgdXA6IDM4LFxuICAgIGxlZnQ6IDM3LFxuICAgIHJpZ2h0OiAzOSxcbiAgICBkb3duOiA0MCxcbiAgICAnZGVsZXRlJzogWzgsIDQ2XVxuICB9O1xuXG4gIC8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbiAgdmFyIGtleU5hbWVzID0ge1xuICAgIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICAgIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gICAgdGFiOiAnVGFiJyxcbiAgICBlbnRlcjogJ0VudGVyJyxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxuICAgIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICAgIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gICAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICAgIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxuICB9O1xuXG4gIC8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4gIC8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbiAgLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxuICB2YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiAoXCJpZihcIiArIGNvbmRpdGlvbiArIFwiKXJldHVybiBudWxsO1wiKTsgfTtcblxuICB2YXIgbW9kaWZpZXJDb2RlID0ge1xuICAgIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICAgIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxuICAgIHNoaWZ0OiBnZW5HdWFyZChcIiEkZXZlbnQuc2hpZnRLZXlcIiksXG4gICAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICAgIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxuICAgIGxlZnQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBcIiksXG4gICAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICAgIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICAgIGV2ZW50cyxcbiAgICBpc05hdGl2ZVxuICApIHtcbiAgICB2YXIgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICAgIHZhciBzdGF0aWNIYW5kbGVycyA9IFwiXCI7XG4gICAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICAgIHZhciBoYW5kbGVyQ29kZSA9IGdlbkhhbmRsZXIoZXZlbnRzW25hbWVdKTtcbiAgICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgICAgZHluYW1pY0hhbmRsZXJzICs9IG5hbWUgKyBcIixcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgICBpZiAoZHluYW1pY0hhbmRsZXJzKSB7XG4gICAgICByZXR1cm4gcHJlZml4ICsgXCJfZChcIiArIHN0YXRpY0hhbmRsZXJzICsgXCIsW1wiICsgKGR5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSkpICsgXCJdKVwiXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmVmaXggKyBzdGF0aWNIYW5kbGVyc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkhhbmRsZXIgKGhhbmRsZXIpIHtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gICAgfVxuXG4gICAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgICB2YXIgaXNGdW5jdGlvbkludm9jYXRpb24gPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlLnJlcGxhY2UoZm5JbnZva2VSRSwgJycpKTtcblxuICAgIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIudmFsdWVcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvZGUgPSAnJztcbiAgICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICAgIHZhciBrZXlzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleU1vZGlmaWVyKSB7IHJldHVybiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXTsgfSlcbiAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgICAgfVxuICAgICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgICB9XG4gICAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIigkZXZlbnQpXCIpXG4gICAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgICA/IChcInJldHVybiAoXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIikoJGV2ZW50KVwiKVxuICAgICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBrZXkgZmlsdGVycyBvbmx5IGFwcGx5IHRvIEtleWJvYXJkRXZlbnRzXG4gICAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxuICAgICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICAgIFwiaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZcIiArXG4gICAgICAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIlxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuICAgIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICBpZiAoa2V5VmFsKSB7XG4gICAgICByZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcbiAgICB9XG4gICAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICAgIHZhciBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgICByZXR1cm4gKFxuICAgICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgICAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyBcIixcIiArXG4gICAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICAgIFwiXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcbiAgICAgIFwiKVwiXG4gICAgKVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgICBpZiAoZGlyLm1vZGlmaWVycykge1xuICAgICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gICAgfVxuICAgIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICAgIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICAgIG9uOiBvbixcbiAgICBiaW5kOiBiaW5kJDEsXG4gICAgY2xvYWs6IG5vb3BcbiAgfTtcblxuICAvKiAgKi9cblxuXG5cblxuXG4gIHZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gICAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgICB0aGlzLm9uY2VJZCA9IDA7XG4gICAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgICB0aGlzLnByZSA9IGZhbHNlO1xuICB9O1xuXG5cblxuICBmdW5jdGlvbiBnZW5lcmF0ZSAoXG4gICAgYXN0LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gICAgaWYgKGVsLnBhcmVudCkge1xuICAgICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XG4gICAgfVxuXG4gICAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQgJiYgIXN0YXRlLnByZSkge1xuICAgICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgICB2YXIgY29kZTtcbiAgICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcbiAgICAgICAgICBkYXRhID0gZ2VuRGF0YSQyKGVsLCBzdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgICBjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuICAgICAgfVxuICAgICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZVxuICAgIH1cbiAgfVxuXG4gIC8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG4gIGZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gICAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gICAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICAgIHZhciBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xuICAgIGlmIChlbC5wcmUpIHtcbiAgICAgIHN0YXRlLnByZSA9IGVsLnByZTtcbiAgICB9XG4gICAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gICAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9XG5cbiAgLy8gdi1vbmNlXG4gIGZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICAgIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICAgIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgICAgdmFyIGtleSA9ICcnO1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5KSB7XG4gICAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgICAgXCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiAoXCJfbyhcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCIsXCIgKyAoc3RhdGUub25jZUlkKyspICsgXCIsXCIgKyBrZXkgKyBcIilcIilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSWYgKFxuICAgIGVsLFxuICAgIHN0YXRlLFxuICAgIGFsdEdlbixcbiAgICBhbHRFbXB0eVxuICApIHtcbiAgICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgICBjb25kaXRpb25zLFxuICAgIHN0YXRlLFxuICAgIGFsdEdlbixcbiAgICBhbHRFbXB0eVxuICApIHtcbiAgICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknXG4gICAgfVxuXG4gICAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICAgIH1cblxuICAgIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgICAgcmV0dXJuIGFsdEdlblxuICAgICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICAgIDogZWwub25jZVxuICAgICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5Gb3IgKFxuICAgIGVsLFxuICAgIHN0YXRlLFxuICAgIGFsdEdlbixcbiAgICBhbHRIZWxwZXJcbiAgKSB7XG4gICAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gICAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gICAgaWYgKHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgIWVsLmtleVxuICAgICkge1xuICAgICAgc3RhdGUud2FybihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICAgIFwidi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gXCIgK1xuICAgICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddLFxuICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgICBcInJldHVybiBcIiArICgoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSkpICtcbiAgICAgICd9KSdcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIGRhdGEgPSAneyc7XG5cbiAgICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAgIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gICAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cbiAgICAvLyBrZXlcbiAgICBpZiAoZWwua2V5KSB7XG4gICAgICBkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcbiAgICB9XG4gICAgLy8gcmVmXG4gICAgaWYgKGVsLnJlZikge1xuICAgICAgZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5yZWZJbkZvcikge1xuICAgICAgZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG4gICAgfVxuICAgIC8vIHByZVxuICAgIGlmIChlbC5wcmUpIHtcbiAgICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgICB9XG4gICAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgICB9XG4gICAgLy8gYXR0cmlidXRlc1xuICAgIGlmIChlbC5hdHRycykge1xuICAgICAgZGF0YSArPSBcImF0dHJzOlwiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIixcIjtcbiAgICB9XG4gICAgLy8gRE9NIHByb3BzXG4gICAgaWYgKGVsLnByb3BzKSB7XG4gICAgICBkYXRhICs9IFwiZG9tUHJvcHM6XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBldmVudCBoYW5kbGVyc1xuICAgIGlmIChlbC5ldmVudHMpIHtcbiAgICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpKSArIFwiLFwiO1xuICAgIH1cbiAgICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBzbG90IHRhcmdldFxuICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBzY29wZWQgc2xvdHNcbiAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICAgIGlmIChlbC5tb2RlbCkge1xuICAgICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICAgIH1cbiAgICAvLyBpbmxpbmUtdGVtcGxhdGVcbiAgICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gICAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gICAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgICAgZGF0YSA9IFwiX2IoXCIgKyBkYXRhICsgXCIsXFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCIgKyAoZ2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKSkgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICAgIGlmIChlbC53cmFwRGF0YSkge1xuICAgICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICAgIH1cbiAgICAvLyB2LW9uIGRhdGEgd3JhcFxuICAgIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICAgIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG4gICAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGRpciA9IGRpcnNbaV07XG4gICAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgICBpZiAoZ2VuKSB7XG4gICAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XCIgKyAoZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiAoXCJcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikpKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzUnVudGltZSkge1xuICAgICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICAgIGlmIChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDEpIHtcbiAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgICB2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICAgIGVsLFxuICAgIHNsb3RzLFxuICAgIHN0YXRlXG4gICkge1xuICAgIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gICAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gICAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxuICAgIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgICByZXR1cm4gKFxuICAgICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICAgIHNsb3QuaWYgfHxcbiAgICAgICAgc2xvdC5mb3IgfHxcbiAgICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICAgIClcbiAgICB9KTtcblxuICAgIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIHNhbWUgY29tcG9uZW50IHRvIGJlIHJldXNlZCBidXQgd2l0aCBkaWZmZXJlbnRcbiAgICAvLyBjb21waWxlZCBzbG90IGNvbnRlbnQuIFRvIGF2b2lkIHRoYXQsIHdlIGdlbmVyYXRlIGEgdW5pcXVlIGtleSBiYXNlZCBvblxuICAgIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gICAgdmFyIG5lZWRzS2V5ID0gISFlbC5pZjtcblxuICAgIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3Qgb3Igdi1mb3IgKHRoZSByZWFjdGl2aXR5IG1heSBiZVxuICAgIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgICAvLyAjOTQzOCwgIzk1MDZcbiAgICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBmdXJ0aGVyIG9wdGltaXplZCBieSBwcm9wZXJseSBhbmFseXppbmcgaW4tc2NvcGUgYmluZGluZ3NcbiAgICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gICAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikgfHxcbiAgICAgICAgICBwYXJlbnQuZm9yXG4gICAgICAgICkge1xuICAgICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudC5pZikge1xuICAgICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZWRTbG90cyA9IE9iamVjdC5rZXlzKHNsb3RzKVxuICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAgIC5qb2luKCcsJyk7XG5cbiAgICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgZ2VuZXJhdGVkU2xvdHMgKyBcIl1cIiArIChuZWVkc0ZvcmNlVXBkYXRlID8gXCIsbnVsbCx0cnVlXCIgOiBcIlwiKSArICghbmVlZHNGb3JjZVVwZGF0ZSAmJiBuZWVkc0tleSA/IChcIixudWxsLGZhbHNlLFwiICsgKGhhc2goZ2VuZXJhdGVkU2xvdHMpKSkgOiBcIlwiKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICB2YXIgaGFzaCA9IDUzODE7XG4gICAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlKGkpIHtcbiAgICAgIGhhc2ggPSAoaGFzaCAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoID4+PiAwXG4gIH1cblxuICBmdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgICBpZiAoZWwudHlwZSA9PT0gMSkge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgICBlbCxcbiAgICBzdGF0ZVxuICApIHtcbiAgICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xuICAgIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQgJiYgIWlzTGVnYWN5U3ludGF4KSB7XG4gICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgICB9XG4gICAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgICB9XG4gICAgdmFyIHNsb3RTY29wZSA9IGVsLnNsb3RTY29wZSA9PT0gZW1wdHlTbG90U2NvcGVUb2tlblxuICAgICAgPyBcIlwiXG4gICAgICA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xuICAgIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyBzbG90U2NvcGUgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcbiAgICAgICAgICA/IChcIihcIiArIChlbC5pZikgKyBcIik/XCIgKyAoZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJykgKyBcIjp1bmRlZmluZWRcIilcbiAgICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gICAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICAgIHJldHVybiAoXCJ7a2V5OlwiICsgKGVsLnNsb3RUYXJnZXQgfHwgXCJcXFwiZGVmYXVsdFxcXCJcIikgKyBcIixmbjpcIiArIGZuICsgcmV2ZXJzZVByb3h5ICsgXCJ9XCIpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gICAgZWwsXG4gICAgc3RhdGUsXG4gICAgY2hlY2tTa2lwLFxuICAgIGFsdEdlbkVsZW1lbnQsXG4gICAgYWx0R2VuTm9kZVxuICApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGVsJDEuZm9yICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICAgICkge1xuICAgICAgICB2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgICAgICA/IHN0YXRlLm1heWJlQ29tcG9uZW50KGVsJDEpID8gXCIsMVwiIDogXCIsMFwiXG4gICAgICAgICAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gKFwiXCIgKyAoKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpKSArIG5vcm1hbGl6YXRpb25UeXBlKVxuICAgICAgfVxuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICAgIDogMDtcbiAgICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlJDEgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSQxKSA6ICcnKSlcbiAgICB9XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4gIC8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4gIC8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbiAgLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuICBmdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gICAgY2hpbGRyZW4sXG4gICAgbWF5YmVDb21wb25lbnRcbiAgKSB7XG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuICAgICAgICByZXMgPSAyO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICAgIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICAgIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICAgIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiAoe1xuICAgICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgICAgdmFsdWU6IGF0dHIudmFsdWUsXG4gICAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICAgIH0pOyB9KSlcbiAgICAgIDogbnVsbDtcbiAgICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgICAgcmVzICs9IFwiLG51bGxcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJzKSB7XG4gICAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgICB9XG4gICAgaWYgKGJpbmQkJDEpIHtcbiAgICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzICsgJyknXG4gIH1cblxuICAvLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG4gIGZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gICAgY29tcG9uZW50TmFtZSxcbiAgICBlbCxcbiAgICBzdGF0ZVxuICApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICAgIHZhciBzdGF0aWNQcm9wcyA9IFwiXCI7XG4gICAgdmFyIGR5bmFtaWNQcm9wcyA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgICAgZHluYW1pY1Byb3BzICs9IChwcm9wLm5hbWUpICsgXCIsXCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGljUHJvcHMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArIHZhbHVlICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpY1Byb3BzID0gXCJ7XCIgKyAoc3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICAgIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICAgIHJldHVybiAoXCJfZChcIiArIHN0YXRpY1Byb3BzICsgXCIsW1wiICsgKGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJdKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgICB9XG4gIH1cblxuICAvLyAjMzg5NSwgIzQyNjhcbiAgZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHRcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2VcbiAgLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuICB2YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuICApLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4gIC8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG4gIHZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAgICdkZWxldGUsdHlwZW9mLHZvaWQnXG4gICkuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4gIC8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbiAgdmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuICAvLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuICBmdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICAgIGlmIChhc3QpIHtcbiAgICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgd2Fybiwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgICAgd2FybihcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKSxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfVxuICAgIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICAgIGlkZW50LFxuICAgIHR5cGUsXG4gICAgdGV4dCxcbiAgICB3YXJuLFxuICAgIHJhbmdlXG4gICkge1xuICAgIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgd2FybigoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSksIHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgICAgcmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIixcbiAgICAgICAgICByYW5nZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciByYW5nZSA9IDI7XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICAgIHNvdXJjZSxcbiAgICBzdGFydCxcbiAgICBlbmRcbiAgKSB7XG4gICAgaWYgKCBzdGFydCA9PT0gdm9pZCAwICkgc3RhcnQgPSAwO1xuICAgIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgICBmb3IgKHZhciBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgICByZXMucHVzaCgoXCJcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCkpICsgXCJ8ICBcIiArIChsaW5lc1tqXSkpKTtcbiAgICAgICAgICB2YXIgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICAgIHZhciBwYWQgPSBzdGFydCAtIChjb3VudCAtIGxpbmVMZW5ndGgpICsgMTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIiBcIiwgcGFkKSArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgICAgdmFyIGxlbmd0aCQxID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCJeXCIsIGxlbmd0aCQxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwZWF0JDEgKHN0ciwgbikge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBpZiAobiA+IDApIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgaWYgKG4gJiAxKSB7IHJlc3VsdCArPSBzdHI7IH1cbiAgICAgICAgbiA+Pj49IDE7XG4gICAgICAgIGlmIChuIDw9IDApIHsgYnJlYWsgfVxuICAgICAgICBzdHIgKz0gc3RyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gICAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zLFxuICAgICAgdm1cbiAgICApIHtcbiAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgICA6IHRlbXBsYXRlO1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICAgIH1cblxuICAgICAgLy8gY29tcGlsZVxuICAgICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAgICB7XG4gICAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICAgIFwiRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcblwiICsgKGUubXNnKSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICAgICAgdm1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gdGlwKGUubXNnLCB2bSk7IH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcbiAgICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICkge1xuICAgICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgdmFyIHRpcHMgPSBbXTtcblxuICAgICAgICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7IG1zZzogbXNnIH07XG4gICAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGF0YS5lbmQgPSByYW5nZS5lbmQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgICAge1xuICAgICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICAgIHJldHVybiBjb21waWxlZFxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgICBjb21waWxlVG9GdW5jdGlvbnM6IGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4gIC8vIHBhcnNlci9vcHRpbWl6ZXIvY29kZWdlbiwgZS5nIHRoZSBTU1Igb3B0aW1pemluZyBjb21waWxlci5cbiAgLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG4gIHZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN0OiBhc3QsXG4gICAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICAgIH1cbiAgfSk7XG5cbiAgLyogICovXG5cbiAgdmFyIHJlZiQxID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xuICB2YXIgY29tcGlsZSA9IHJlZiQxLmNvbXBpbGU7XG4gIHZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbiAgLyogICovXG5cbiAgLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbiAgdmFyIGRpdjtcbiAgZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gICAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5pbm5lckhUTUwgPSBocmVmID8gXCI8YSBocmVmPVxcXCJcXG5cXFwiLz5cIiA6IFwiPGRpdiBhPVxcXCJcXG5cXFwiLz5cIjtcbiAgICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxuICB9XG5cbiAgLy8gIzM2NjM6IElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbiAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xuICAvLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG4gIHZhciBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuICAvKiAgKi9cblxuICB2YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG4gIH0pO1xuXG4gIHZhciBtb3VudCA9IFZ1ZS5wcm90b3R5cGUuJG1vdW50O1xuICBWdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgICBlbCxcbiAgICBoeWRyYXRpbmdcbiAgKSB7XG4gICAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gICAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgICB9XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcbiAgICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gICAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICAgIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICAgIH1cbiAgfVxuXG4gIFZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4gIHJldHVybiBWdWU7XG5cbn0pKTtcbiJdfQ==
